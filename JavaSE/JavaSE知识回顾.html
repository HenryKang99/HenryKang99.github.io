<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaSE知识回顾 | HenryKang的博客</title><meta name="keywords" content="JavaSE"><meta name="author" content="HenryKang"><meta name="copyright" content="HenryKang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="0verview"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE知识回顾"><meta property="og:url" content="https://henrykang99.github.io/JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html"><meta property="og:site_name" content="HenryKang的博客"><meta property="og:description" content="0verview"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/XX6kRgAlUcwx.webp"><meta property="article:published_time" content="2020-02-02T16:00:00.000Z"><meta property="article:modified_time" content="2020-11-08T05:06:13.370Z"><meta property="article:author" content="HenryKang"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/XX6kRgAlUcwx.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/logo.png"><link rel="canonical" href="https://henrykang99.github.io/JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: HenryKang","link":"链接: ","source":"来源: HenryKang的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自用,平等,公正,法制,爱国,敬业,诚信,友善","fontSize":"15px"},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-11-08 2020-11-08T13:06:13+08:00"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/avatar.gif" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i> <span>博客</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></div><div class="menus_item"><a class="site-page" href="/balabala/"><i class="fa-fw far fa-meh-blank"></i> <span>逼逼叨</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HenryKang的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i> <span>博客</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i> <span>Music</span></a></div><div class="menus_item"><a class="site-page" href="/balabala/"><i class="fa-fw far fa-meh-blank"></i> <span>逼逼叨</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaSE知识回顾</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-02-02T16:00:00.000Z" title="undefined 2020-02-03 2020-02-03T00:00:00+08:00">2020-02-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html" itemprop="commentCount"></span></a></span></div></div></div><article class="post-content" id="article-container"><h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><a id="more"></a><h3 id="1-数据类型-amp-运算符"><a href="#1-数据类型-amp-运算符" class="headerlink" title="1. 数据类型 &amp; 运算符"></a>1. 数据类型 &amp; 运算符</h3><ul><li><p><strong>数据类型</strong></p><table><thead><tr><th>类型</th><th align="center">长度/字节</th><th align="left">备注</th><th>对应包装类</th></tr></thead><tbody><tr><td>byte</td><td align="center">1</td><td align="left">-128~127</td><td>Byte</td></tr><tr><td>short</td><td align="center">2</td><td align="left">2^15=32768</td><td>Short</td></tr><tr><td>int</td><td align="center">4</td><td align="left">2^31=2147483648</td><td>Integer</td></tr><tr><td>long</td><td align="center">8</td><td align="left">2^63</td><td>Long</td></tr><tr><td>float（F）</td><td align="center">4</td><td align="left">7~8有效位</td><td>Float</td></tr><tr><td>double</td><td align="center">8</td><td align="left">16有效位</td><td>Double</td></tr><tr><td>char</td><td align="center">2</td><td align="left">Unicode编码</td><td>Character</td></tr><tr><td>boolean</td><td align="center">1</td><td align="left">只有true和false两种表示形式</td><td>Boolean</td></tr><tr><td>String</td><td align="center">*</td><td align="left">不可变类</td><td>*</td></tr><tr><td>数组</td><td align="center">*</td><td align="left">特殊的Object</td><td>*</td></tr></tbody></table><br></li><li><p><strong>注意：</strong></p><ul><li><p>Java没有无符号形式；</p></li><li><p>byte 能表示 -128~127 是因为补码表示有两种零（0/1,000 0000），所以用负零1,000 0000表示-128，还有就是因为 -127=（1,000 0001）再减1就变成了-128=（1,000 0000）；</p></li><li><p>局部变量使用前必须要初始化，成员变量在类加载准备阶段赋“0”值，初始化阶段赋初值；</p></li><li><p>boolean默认为false，string默认为空串“ ”；</p></li><li><p>Java整形默认为int，浮点型默认为double，float需要加后缀F；</p></li><li><p>byte 和 short 做运算为了不溢出都会转成 int；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//b1 = b1 + b2; 报错</span></span><br><span class="line">b1 = (<span class="keyword">byte</span>) (b1 + b2); <span class="comment">// √ 溢出会截掉高位</span></span><br></pre></td></tr></table></figure></li><li><p>字面量可以使用下划线分割，编译器会去除他们：1_000_000;</p></li><li><p>char 赋值时字面量要用单引号括起来 <code>char c1 = &#39;A&#39;</code> ，JVM使用UTF-16编码，赋编码值不用单引号<code>char c2 = 65</code>；</p></li></ul></li><li><p><strong>Unicode VS UTF-8</strong>：</p><ul><li><p>Unicode 是<strong>字符集</strong>，为每一个字符分配一个二进制ID（称为<strong>码点</strong>、码位、CodePoint），虽然定义了码点，但是没有规定如何存储与读取。例如UCS-4标准使用4个字节为全世界的字符分配了ID，但是我们知道英文的ID都是靠前的（想想ASCII编码，一字节就够了），如果都用Unicode作为编码表示，那英文前面一串0，浪费了太多空间，所有才有了一系列的编码规则。</p><ul><li>UCS-2 标准就分配够了常用汉字的ID，因此Unicode 2 字节就够表示汉字。也因为这样，使用了UTF-16编码的 JVM 中 char 能表示汉字。从4E00(100 1110 0000 0000) 到 9FA5(1001 1111 1010 0101)，共20902个。<a target="_blank" rel="noopener" href="http://www.chi2ko.com/tool/CJK.htm">在这里查</a></li><li>JVM 内部使用的是UTF-16编码，所有字符都是俩字节，一般我们说JVM使用Unicode编码其实是不严谨的；</li></ul></li><li><p>UTF-8 是 <strong>编码规则</strong>，定义了<strong>将码点转换为字节序列</strong>的规则，是Unicode的一种实现方式；具体实现如下：</p><ul><li><p>对于单字节的符号，字节的第一位设为 0，后面7位为这个符号的 Unicode 码；</p></li><li><p>对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1（这样做计算机读到几个1就知道了要往后读几个字节），第 n + 1 位设为 0，后面字节的前两位一律设为10，空余的二进制位从后往前依次填充这个符号的 Unicode 码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">  (十六进制)         |         （二进制）</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></li><li><p>现在知道为什么UTF-8汉字占三字节，因为上面说到汉字Unicode从4E00-9FA6，要15-16位，而UTF-8 的第二行只有11个空位，不够，所以用第三行，即占三个字节；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;字&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>).length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">&quot;字&quot;</span>.getBytes(<span class="string">&quot;utf-16&quot;</span>).length);<span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="string">&quot;汉字&quot;</span>.getBytes(<span class="string">&quot;utf-16&quot;</span>).length);<span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 为什么是4和6，因为前面有个FE或FF表示大小端</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0b0100_1110_0000_0000</span>; <span class="comment">// 4E00 表示 ‘一’</span></span><br><span class="line">System.out.println(c);<span class="comment">// 一</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>　　</p><ul><li><p><strong>类型转换</strong></p><ul><li><p>自动转换：char&gt;int&gt;<strong>long&gt;float</strong>&gt;double</p></li><li><p>强转字节不够的时候会直接截断高位，产生错误结果，例如 (byte) (0x1_0000_0000) = 0;</p></li><li><p>任何类型和String做运算都会自动转型成String；</p></li><li><p>装箱、拆箱、字符串转化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer aa;</span><br><span class="line">String str；</span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line">aa = Integer.valueOf(a);</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line">aa.intValue(); <span class="comment">// 其实就相当于get方法，get Value属性；</span></span><br><span class="line"><span class="comment">//Object-&gt;字符串</span></span><br><span class="line">str = String.ValueOf(a);</span><br><span class="line">str = a + <span class="string">&quot;&quot;</span>;<span class="comment">// 这个最方便</span></span><br><span class="line"><span class="comment">//字符串-&gt;基本型</span></span><br><span class="line">a = Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>包装类</strong></p><ul><li>整形和浮点型都继承了抽象类 Number；</li><li>包装类有一个属性value放基本型，而且一旦包装就不能再改变；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java 中四种整形包装类都用数组缓存了-128~127，因此在用==比较这个范围的包装类时返回true；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Byte中的一个内部类 ，其他整形同理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Byte 的valueOf方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Integer 中的 valueOf方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是new Integer(int x)的话，== 返回false</span></span><br></pre></td></tr></table></figure><ul><li>Boolean 中参数为String的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((s != <span class="keyword">null</span>) &amp;&amp; s.equalsIgnoreCase(<span class="string">&quot;true&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new Boolean(&quot;tRuE&quot;); 传参只要是忽略大小写的true就是true，其他false；</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>String</strong></p><ul><li><p>本质是一个final char[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类中属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></li><li><p><code>intern()</code> 方法:</p><ul><li>JDK 1.7 之前，常量池位于方法区，intern方法会将首次遇到的字符串<strong>实例复制</strong>到常量池中，再返回其引用；</li><li>JDK 1.8 之后，常量池搬移到堆中，intern方法会将首次遇到的字符串实例的<strong>引用添加</strong>到常量池中，再返回其引用；</li><li>下面代码环境均为jdk1.8：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;					<span class="comment">// 首次遇到“abc”，加入到常量池</span></span><br><span class="line">String str2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;				<span class="comment">// 编译时优化，就是“abc”</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;	<span class="comment">// 新开辟一个空间 存“abc”，即和上面俩没关系	</span></span><br><span class="line">System.out.println(str1 == str2);		<span class="comment">//true	</span></span><br><span class="line">System.out.println(str1 == str3);		<span class="comment">//false </span></span><br><span class="line">System.out.println(str1 == str3.intern());<span class="comment">//true 常量池中有“abc”的引用</span></span><br><span class="line">System.out.println(str3 == str3.intern());<span class="comment">//false intern返回的是str1的引用（因为“abc”首次出现是str1），和str3指向的堆内存的“abc”不是同一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线，和上面代码无关----------------</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(str1.intern() == str1); <span class="comment">// true 常量池中的“abc”就是引用自new 的“abc”，因为首次出现</span></span><br></pre></td></tr></table></figure></li><li><p>new String 不会将字符串的引用放入常量池中（误）：</p><ul><li>new String(“abc”)中的参数abc字符串在类加载的时候也会存入常量池，但是new的时候是复制了一份放在堆中，并返回引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);	<span class="comment">//false,说明new String没往常量池中添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线---</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">str1.intern();						<span class="comment">//调用intern()才会添加</span></span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 侧面说明直接创建字符串会添加到常量池，所以不推荐使用new创建String；编译时就将已知的str（双引号创建的str）加入到了该类静态常量池，类加载时进入运行时常量池。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组</strong></p><ul><li><p>数组是一个特殊的对象，也继承自Object，它也封装了属性和一些方法，那它到底是什么类型呢？</p><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/hV6qqssz9bH0.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过getClass.getName看看它是什么类型</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">Integer[] arr2 = <span class="keyword">new</span> Integer[<span class="number">0</span>];</span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">String[][] arr4 = <span class="keyword">new</span> String[<span class="number">0</span>][];</span><br><span class="line"></span><br><span class="line">System.out.println(arr1.getClass().getName());</span><br><span class="line">System.out.println(arr2.getClass().getName());</span><br><span class="line">System.out.println(arr3.getClass().getName());</span><br><span class="line">System.out.println(arr4.getClass().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下:</span></span><br><span class="line"><span class="comment">//  [I</span></span><br><span class="line"><span class="comment">//  [Ljava.lang.Integer</span></span><br><span class="line"><span class="comment">//  [Ljava.lang.String</span></span><br><span class="line"><span class="comment">//  [[Ljava.lang.String</span></span><br><span class="line"><span class="comment">// 使用IDE也搜不到这几个类，可以理解为数组类是JVM内部维护的类。</span></span><br></pre></td></tr></table></figure><ul><li>简单理解就是：数组是一个数据结构，体现在内存上就是一块连续的内存分成若干小块，每个小块可以存储相同类型数据，而JVM帮我们把它封装成了一个特殊的对象，可以通过<code>[ ]</code>访问它的属性，还可以调用它的方法。</li></ul></li></ul></li><li><p>一维数组声明时必须指定长度，初始化值为0；</p></li><li><p>二维数组声明必须指定行数，初始化值为0；实质是数组的数组，所以每一行可以有不同数的列；</p></li><li><p>Java允许数组长度可以为零；</p></li><li><p>String 数组元素默认初始化为 null 而不是空串“ ”；</p></li><li><p>Arrays.toString(Object []) 返回一个包含数组所有元素的字符串[1,2,3,…]；</p></li><li><p>数组拷贝使用 Arrays.copyOf(s,s.length());</p></li></ul><ul><li><p>运算符</p><ul><li><p>两个操作数都是整数时，是整数运算；否则都会扩展精度；</p></li><li><p>整数/0 = 算数异常；</p></li><li><p>浮点数/0 = infinity 无穷大；</p></li><li><p>逻辑运算符：&amp;&amp; || ! == !=</p></li><li><p>位运算：&amp; | ~ ^(异或) &lt;&lt; &gt;&gt; &gt;&gt;&gt;</p><ul><li>&gt;&gt; 算术移位，高位填符号位；</li><li>&gt;&gt;&gt; 逻辑移位，高位填0；</li><li>不存在 <code>&lt;&lt;&lt;</code> 因为 原码补码左移低位都填0，其实算数移位和逻辑移位也就只是针对补码(而且是表示负数的补码)的右移来说的；</li></ul></li><li><p><strong>&amp; 和 &amp;&amp; 的区别</strong></p><ul><li>都是可以当做逻辑运算符，要求两个操作数都是boolean型；而且&amp;&amp; 具有短路功能，即第一个条件为false，第二个不用判断。</li><li>&amp; 还可以作为位运算符，要求操作数不是boolean，有啥用呢，比如我们可以使用下面的操作来取一个整形的低几位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%x&quot;</span>, <span class="number">0xff</span> &amp; <span class="number">128</span>);<span class="comment">// 7f ，即低八位</span></span><br></pre></td></tr></table></figure><ul><li>判断奇偶：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a &amp; <span class="number">0b1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>优先级与结合性：</p><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/z1f5ElyVm8DI.png" alt="mark"></p></li></ul><hr><h3 id="2-对象-amp-类"><a href="#2-对象-amp-类" class="headerlink" title="2. 对象 &amp; 类"></a>2. 对象 &amp; 类</h3><ul><li>一些概念：<ul><li>现实中万事万物皆是对象，编程世界中对象是具有一定属性和方法的封装体；计算机中对象是一块内存；</li><li>类是对象的模板，是一系列具有相同属性和方法的对象的抽象集合。</li><li>封装：隐藏自己的成员属性和某些方法，只将对外提供的方法暴露出来；</li><li>继承：基于一个已存在的类构造一个新类；</li><li>多态：多种状态；</li></ul></li><li>构造方法：<ul><li>没有返回值，与类同名；伴随着new操作被调用；</li><li>子类初始化一定会调用父类构造方法（抽象类也有构造方法）；</li><li>子类构造方法调用父类构造方法必须写在第一行，没有显式调用会自动调用父类默认构造方法（无参构造方法），若父类无默认构造方法，则编译会报错；</li><li>静态块：static{ }，类加载时候执行；<ul><li>注意：静态变量的赋值语句和静态块同等级，按代码书写顺序执行。</li></ul></li><li>初始化块：{ }，随着对象的创建而执行，<strong>在构造方法之前执行</strong>；</li></ul></li><li>析构方法：<ul><li>会在GC回收对象之前调用，但不保证会执行完成；</li><li>一般不建议使用，因为我们不知道GC回收对象的准确时机，也就不知道析构执行的时机；</li><li>一个对象只会执行一次；</li></ul></li><li>静态属性与静态方法：<ul><li>属于类但不属于对象的属性和方法，随着类的加载而加载；</li><li>静态变量：static属性由所有实例共享，例如可以使用静态变量统计一下这个类new了多少次实例；</li><li>静态常量：使用 static final 修饰，例如定义很多常量值，还有经常使用的 System.out 就是一个PrintStream静态常量；</li><li>静态方法：静态方法不能访问对象的状态，只能访问类中的静态属性；可以由类名.方法名调用，当然也可以使用对象名调用但是容易造成混淆一般不使用；<ul><li>main()方法：程序的入口，每一个类可以有一个main方法，使用java命令执行哪个类就会从哪个类进入，如果一个类中有main方法但是没有从它进入，那这个main永远不会执行。</li></ul></li></ul></li><li>参数传递：<ul><li>基本类型按值传递，引用类型按引用传递。虽然这个说法具有一定广泛性但却是<strong>错误</strong>的；</li><li>实际上引用类型传递的是引用的拷贝，也是值传递，代码验证：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stu x = <span class="keyword">new</span> Stu(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Stu y = <span class="keyword">new</span> Stu(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">swap(x,y);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line">    Stu temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样想要交换两个对象是不行的，交换的是引用的值，对象在内存中并没有发生交换。</span></span><br></pre></td></tr></table></figure><ul><li><p>方法重载：</p><ul><li>一个类中有多个方法具有相同的方法名，不同的参数列表，称为重载；<ul><li><strong>方法签名 = 方法名 + 参数列表</strong>；</li></ul></li><li>关于异常抛出、修饰符、返回值都没有限制；</li></ul></li><li><p>可变参数：</p><ul><li>可变参数等价于数组，可以互相替换，代表同样的参数列表，即不能把二者互相替换达到重载的目的；</li><li>必须放在最后，否则会引起歧义；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span> <span class="params">(<span class="keyword">double</span> ... values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> largest = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">double</span> v : values) <span class="keyword">if</span>(v &gt; largest) largest = v;</span><br><span class="line">	<span class="keyword">return</span> largest ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包：</p><ul><li>包的作用是确定唯一的类，因此建议包名为公司域名反写，因为域名肯定是唯一的；</li><li>静态导入（不常用）：导入静态方法和静态属性；例如可以使用import static java.lang.System.* ，这样输出的时候可以直接写out.println(); 甚至导入 java.lang.System.out 可以直接写println()， 当然前提是没有冲突。</li><li>可以通过打jar包的方式将包密封起来。</li></ul></li><li><p>访问权限修饰符：</p><ul><li>类：只有public 和 缺省<ul><li>每个 .java 文件只能有一个public的class，且必须和文件名相同；；<ul><li>可以没有public的class</li></ul></li><li><strong>内部类</strong>相当于类的成员，可以使用protected、private修饰，可见性同成员变量一样；</li><li>缺省则只能被同包访问；</li></ul></li><li>方法与属性：</li></ul></li></ul><table><thead><tr><th align="left">作用域与可见性</th><th align="center">public</th><th align="center">protected</th><th align="center">default</th><th align="center">private</th></tr></thead><tbody><tr><td align="left">当前类</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">同包类（包括其它类+子类）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">x</td></tr><tr><td align="left">不同包子类</td><td align="center">√</td><td align="center">√</td><td align="center">x</td><td align="center">x</td></tr><tr><td align="left">其他</td><td align="center">√</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><ul><li><p>关于继承：</p><ul><li>概念：<strong>基于一个已存在的类构造一个新类</strong>；</li><li>类只能单继承，可以多实现；接口无限制但不能循环，接口的实现也具有传递性；</li><li>子类初始化前必须先初始化父类；若父接口中有default方法，或使用了父接口的常量，则必须先初始化父接口，否则不需要初始化父接口；</li><li><strong>子类可以继承父类所有成员方法和属性；</strong><ul><li>对于private也能继承，只不过不能直接访问，需要通过访问器，通过this都不行；</li><li>对于static方法和属性（包括static final属性），继承的是使用权，即（在有访问权限的前提下）可以通过子类的类名或实例名调用父类中的静态方法和属性，不存在重写一说，若企图“重写”则会隐藏父类的静态方法；<ul><li>如果这点不考虑的话，其实可以说成是：子类可以继承父类所有的<strong>成员</strong>变量和方法，静态是属于类的，不属于类的实例；</li></ul></li><li>对于final方法与属性，方法可以继承但是无法重写，父类final属性若在父类构造器或初始化块中赋值，则可以通过子类构造器或初始化块对继承下来的final属性赋值，否则无法修改；</li></ul></li><li>子类无法删除继承下来的任何属性和方法，可以通过声明同名属性来隐藏父类属性；</li></ul></li></ul><ul><li><p>方法重写：</p><ul><li>子类方法和父类方法拥有<strong>相同的方法签名</strong>，且返回值必须<strong>兼容</strong>；<ul><li>这个兼容有个名词叫<strong>协变</strong>，就是子类重写的返回值范围要<u>小于等于</u>父类的返回值范围。</li></ul></li><li>修饰符：<ul><li>子类访问修饰符必须大于等于父类访问修饰符。</li><li>final 和 static 都不能重写，但是子类按照相同的方法签名“重写”不会报错，这时因为编译器将这个“重写”的方法当做子类自己的方法；通过声明父类创建子类，再调用该方法即可证明，发现调用的始终是父类的方法，即没有发生多态，也就没有发生重写。</li></ul></li><li>异常：不能抛出比父类范围大的异常；</li></ul></li></ul><ul><li><p>多态：</p><ul><li><p>可以<strong>声明父类创建子类</strong>，即父类引用可以指向子类对象，反之不能；</p><ul><li>父类能出现的地方都可以使用子类置换；</li></ul></li><li><p>声明父类就只能调用父类拥有的方法；</p><ul><li>即不能调用子类独有的方法，只能调用父类拥有的方法，但是会调用子类重写的方法；</li><li>这时候想要调用子类独有方法就得<strong>强转</strong>为子类；</li></ul></li><li><p>避免多态的例子：</p><ul><li>子类数组的引用可以直接赋值给父类数组引用，这时父子类引用都指向同一个含有子类元素的数组，这时假设通过父类引用<code>father[0]</code>在数组里面添加一个父类元素，再通过子类引用<code>son[0]</code>去调用子类独有的方法，就会报<strong>ArrayStoreException</strong>，因为实际存的是父类元素，并没有子类独有的方法。</li><li>上面是书上看到的，测试的时候发现父类元素放不进去（jdk1.8），直接报异常，不知道是不是JDK后面版本优化了：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Son[] sonArray = <span class="keyword">new</span> Son[<span class="number">3</span>];</span><br><span class="line">sonArray[<span class="number">1</span>] = <span class="keyword">new</span> Son();</span><br><span class="line">sonArray[<span class="number">2</span>] = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">Father[] fatherArray= sonArray;</span><br><span class="line">fatherArray[<span class="number">0</span>] = <span class="keyword">new</span> Father();<span class="comment">// java.lang.ArrayStoreException</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>强转：</p><ul><li>使用强转前最好使用instanceof进行判断，因为有可能会报ClassCastException；<ul><li>null instanceof object 会返回 false；</li></ul></li></ul></li><li><p>final：</p><ul><li>final 修饰的类不能被继承，<strong>类中方法也默认变为 final</strong>；</li><li>final 修饰的方法可以被继承但不能被重写；</li><li>final 修饰的属性构造后不能再赋值（引用不能修改，引用的内容可以）；</li></ul></li><li><p>抽象类：</p><ul><li>关键字abstract声明的类称为抽象类，与普通类的最大区别是不能实例化；</li><li>不含抽象方法的类也可以声明为abstract类，含有抽象方法的类必须声明为abstract类；</li><li>可以声明抽象类创建非抽象子类；</li></ul></li><li><p>枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如没有枚举</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Week1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">     MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">     THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>枚举类<strong>本质</strong>是一个继承java.lang.Enum的final类，枚举值就是该类的实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ javap Week.class</span><br><span class="line">Compiled from <span class="string">&quot;TestEnum.java&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Week</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MONDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUESDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WEDNESDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THURSDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRIDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SATURDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUNDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Week[] values();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>接口：</p><ul><li><p>概念：接口不是类，而是对类的一组规则的描述，一个类要实现某接口就要遵从该接口定义的规则，即实现接口中的方法；</p><ul><li>接口中的方法默认都是public abstract，属性默认都是public static finall，不能含有普通成员变量；</li><li>传递性：父类实现了接口，子类也就实现了该接口（instance 返回 true），继承了父类重写接口的方法。</li></ul></li></ul></li><li><p>Java SE8 允许接口中增加静态方法，目的是减少<strong>伴随类</strong>，比如：我们有时候想要调用某一个类的某个非常简单地静态方法，若这个方法在这个类实现的接口中实现了，那么我们就可以通过接口来使用该方法，而不用再加载这个类。</p></li><li><p>可以将接口中方法声明为<strong>default</strong>并提供默认实现，这样做的意义就在于：假如某个接口中有多个方法，而我们常用的就只是一两个，实现该接口还要重写其他不用的方法，非常不方便，而且代码看起来也杂乱；使用default对方法修饰就可以提供默认实现（实现类中就不会提示重写），注意区别于静态方法，default 方法不能通过接口调用，需要实现类的对象来进行调用；</p></li><li><p>标记接口：只有一个空接口，唯一的目的就是标记身份，使用 instanceof 判断；</p></li><li><p><strong>默认方法冲突</strong>：</p><ul><li>超类优先，由此可以看出来，尽量不要让接口中的default方法重写Object中的toString、equals等方法，因为默认情况下使用的还是Object类的方法；<ul><li>接口IA和IB有相同方法声明（返回值、名称、参数列表）的方法，分下面情况：<ul><li>只要有一个接口中的该方法声明为default，就会冲突，需要在实现的时明确指定，例如<code>return IA.super.function()</code>；</li><li>两接口的该方法都没有声明default，就不会冲突，因为实现类要么实现要么不实现，随实现类而定；</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FA.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IA.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IB.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonA</span> <span class="keyword">extends</span> <span class="title">FA</span> <span class="keyword">implements</span> <span class="title">IA</span>, <span class="title">IB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SonA s1 = <span class="keyword">new</span> SonA();</span><br><span class="line">        s1.print();		<span class="comment">// 不重写的话默认调用父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.print();	   <span class="comment">//指定调用父类，等价于不重写</span></span><br><span class="line">      <span class="comment">//IA.super.print();  //指定调用IA</span></span><br><span class="line">      <span class="comment">//IB.super.print();  //指定调用IB    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>内部类：</strong></p><ul><li><p>当两个对象有<strong>紧密的组合关系</strong>时，使用内部类。例如 Person 类包含 Heart 类，如果Heart类来自外部则无法说明其关系的紧密，也无法使用内部类的一些特性；</p></li><li><p><strong>本质</strong>也是一个类的成员属性，可以用修饰符修饰；</p></li><li><p>内部类编译后生成独立的<code>外部类$内部类.class</code>，没有<strong>主动引用</strong>的话，外部类加载不会引发内部类加载；</p><ul><li>所以可以用来实现懒加载单例。</li></ul></li><li><p>内部类可以访问其外部类的<strong>所有</strong>数据；外部类要访问内部类的成员时，必须要建立内部类的对象；</p><ul><li>（非静态）内部类对象不能独立于外部类对象而存在；</li><li>内部类中隐藏了指向外部类的引用<code>OuterClass.this</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内部类的方式</span></span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//或者：（即必须借助外部类）</span></span></span><br><span class="line"><span class="function">Outer outer </span>= <span class="keyword">new</span> Outer();</span><br><span class="line">Inner inner = outer.n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> alive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (alive)</span><br><span class="line">                System.out.println(<span class="string">&quot;-^-^-^&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 可以直接访问外部类私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlive</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 内部类中外部类引用不再是this，而是 外围类.this；</span></span><br><span class="line">            Person.<span class="keyword">this</span>.alive = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person.Heart heart = <span class="keyword">new</span> Person().n<span class="function">ew <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line">        heart.jump();           <span class="comment">// -^-^-^</span></span><br><span class="line">        heart.setAlive(<span class="keyword">false</span>);</span><br><span class="line">        heart.jump();           <span class="comment">// -------</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>非静态内部类中所有的静态属性都必须是 final</strong>；</p><ul><li>这里的final静态属性指编译期常量，即基本型和用引号创建的String；非静态内部类中不能有非编译期常量，即<code>static final String str = new String(&quot;xxx&quot;);</code>这样的写法；</li><li>非静态内部类中暗含了一个指向外部类的引用（通过内部类的构造方法传递），也是通过这个引用来引用外部类的属性，所以非静态内部类依赖于外部类，即<strong>加载内部类之前必须先加载外部类</strong>，体现在代码上就是要用具体的外部类对象去创建内部类对象；</li><li>现在假设非静态内部类中存在static属性，则理应可以通过类名<code>Outer.Inner.属性名</code>直接访问，但如果Inner没有被初始化过，这就会出错。Inner的初始化依赖于Outer，Inner虽然是一个类，但本质是Outer的一个属性；声明为final的常量在编译期间就可以确认，通过<code>Outer.Inner.属性名</code>调用会经过<strong>常量传递优化</strong>，直接将此常量传递到调用者的常量池中，不会引发内部类的加载，所以非静态内部类中只能有编译期常量；</li></ul></li><li><p><strong>非静态内部类不能有 static 方法</strong>；</p><ul><li>道理同上。</li></ul></li><li><p><strong>静态内部类</strong></p><ul><li>在<strong>内部类不需要访问外围类对象的时候 ，使用静态内部类</strong>。此时静态内部类就和外部类的其他静态属性一样，外部类加载的时候加载，可以独立于外部类存在；</li><li>静态内部类只能访问外部类的静态属性，原因和静态方法不能访问非静态属性一样，是由于生命周期造成的；</li><li>静态内部类不存在上述 static 必须修饰为 final 的问题；</li><li>打个比方：内部类描述了两个类之间的组合关系，如Person类、Heart类、Hair类；而关系紧密的使用普通内部类，如Heart类不能独立于Person；关系不密切的使用静态内部类，如Hair类可以独立于外部类。</li></ul></li><li><p><strong>局部内部类</strong></p><ul><li>不能使用修饰符，作用域只在声明他的方法体中；</li><li>对外部完全隐藏，只有声明他的方法知道他的存在；</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li><p>本质：是一个<strong>匿名的带有具体实现的子类</strong>；</p></li><li><p>不使用匿名内部类，我们需要：定义子类，重写方法，new 子类对象，调用方法；</p></li><li><p>使用内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People p = <span class="keyword">new</span> People()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;p talk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.talk();</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h3><ul><li>声明 –&gt; 捕获 –&gt; 抛出<ul><li><strong>声明throw：</strong>声明代码可能引发的异常；</li><li><strong>捕获catch：</strong>当异常发生时，应当获取异常信息并作相应处理，通常是给用户以反馈；</li><li><strong>抛出throws：</strong>将控制权从错误产生的地方转移给能够处理这种情况的错误处理器；</li></ul></li><li>继承结构：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/YEi7albKgRKK.png" alt="mark"></p><ul><li><p>Error：通常是系统内部的错误，如资源耗尽等，遇到此类错误，除了通知用户、保存当前数据外一般只能停机，我们对此没有控制能力；</p></li><li><p>Exception：</p><ul><li>IOException：一般程序本身没有问题，但由于外部资源的异常而引发；</li><li>RuntimeException：程序本身错误导致的异常；<ul><li>注意：Runtime 具有混淆性，其实异常都是运行时期产生的；</li></ul></li></ul></li><li><p><strong>Checked 与 Unchecked 异常：</strong></p><ul><li>Error 和 RuntimeException 称为非受查（Unchecked）异常，其他异常（IO、直接继承Exception的自定义异常等）称为受查（checked）异常；</li><li><strong>任何代码都具有抛出unchecked异常的潜力</strong>，即我们 <strong>不用throws和catch</strong> unchecked异常，例如 ArrayIndexOutOfBoundsException，我们应集中注意去避免这些异常，而不是声明它发生的可能性；如果发生了，虚拟机会帮catch（打印信息，停机）；</li><li>我们何时应该 **throws或catch **checked异常：<ul><li>当调用了抛出checked异常的方法时；</li><li>当方法内 throw new checked异常时；</li></ul></li><li>子类方法重写抛出的受查异常范围不能比父类方法大，若父类方法没有抛出异常，则子类重写时也不能抛出，只能自己catch；</li></ul></li><li><p>自定义异常：</p><ul><li>继承 Exception 或其子类；</li><li>两个构造器：默认 + 传递字符串，Throwable的toString将会打印这个字符串；</li></ul></li><li><p>捕获异常：</p><ul><li>try-catch-finally<ul><li>try中代码抛出了一个catch中声明的异常类，那么try块剩余代码不执行，转去执行catch块代码；</li><li>如果try块中抛出了一个catch中未声明的异常，那么该方法将立即退出；</li><li>finally最后都会执行；</li></ul></li><li>catch还是throws：<ul><li>知道怎么样处理就catch，否则就throws；</li><li>子类重写父类方法，父类方法又没有抛出异常，则子类只能自己catch；</li></ul></li><li>catch 中还可以再 throw new异常，目的是为了转换异常类型；</li><li>注意：有 <strong>return</strong> 时，return在try块中，会在return执行之前执行finally，若finally块也有return则会覆盖try块中的return；</li></ul></li><li><p>​ Closeable 接口：</p><ul><li>我们通常使用finally释放资源，但当try块与finally块同时发生异常抛出时，finally抛出的异常会覆盖掉try块抛出的异常，而我们通常需要的恰好就是try抛出的异常信息，JavaSE7 中实现了这个释放资源的快捷方式 try-with-resources；</li><li>凡是实现了Closeable接口的资源都可以通过声明在try(…)中来自动释放；</li></ul></li></ul><hr><h3 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h3><ul><li><p>为什么要使用泛型：</p><ul><li>使用泛型可以使我们编写的代码被不同类型的对象所重用；</li><li>一些情形下我们不需要再使用Object、强转等操作；</li><li>使得程序具有更好的可读性和安全性（编译器会进行类型检查）；</li></ul></li><li><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">G</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> F second;</span><br><span class="line">    <span class="keyword">private</span> G third;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(T first, F second, G third)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">        <span class="keyword">this</span>.third = third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericClass&lt;Integer, String, Boolean&gt;(<span class="number">1</span>, <span class="string">&quot;泛型类&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>泛型方法：</p><ul><li>泛型方法不必一定定义在泛型类中；</li><li>使用 <code>extends</code> <strong>限定</strong><code>T</code>的范围，使用<code>&amp;</code>分割多个，称为<strong>限定类型</strong>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable &amp; Serializable&gt; <span class="function">T <span class="title">max</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    T max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (T t : a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.compareTo(max) &gt; <span class="number">0</span>) max = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">GenericClass.&lt;Integer&gt;max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//一般不用写&lt;&gt;，编译器会根据我们写的参数自动确定类型</span></span><br><span class="line">GenericClass.max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>类型擦除</strong>：</p><ul><li>Java 实现的泛型是一种“伪泛型”，使用类型擦除机制；C++ 为每一个模板类型产生真实的类型，称为“模板代码膨胀”；</li><li>泛型类型对应着一个<strong>原始类型</strong>，类名就是擦除类型参数后的泛型类名；变量类型就是擦除类型变量，并替换为第一个限定类型（没限定类型就是Object）；如GenericClass&lt;T&gt;擦除后成为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    <span class="keyword">private</span> Object third;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(Object first, Object second, Object third)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">        <span class="keyword">this</span>.third = third;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型擦除对<strong>参数或返回值是类型参数类型的方法</strong>造成的影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair类 封装某类型为一对</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DateInterval类 表示一时间段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 重写父类方法，保证时间段为正值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(<span class="keyword">this</span>.getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;DateInterval&gt; clazz = DateInterval.class;</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印一下DateInterval的运行时方法发现结果包含下面两条setSecond方法：</span></span><br><span class="line"><span class="comment">// 1. public void DateInterval.setSecond(java.time.LocalDate)</span></span><br><span class="line"><span class="comment">// 2. public void DateInterval.setSecond(java.lang.Object)</span></span><br><span class="line"><span class="comment">//----上面是重写的，下面是继承的-----</span></span><br><span class="line"><span class="comment">// 对比get方法与setFirst方法：</span></span><br><span class="line"><span class="comment">// 3. public java.lang.Object Pair.getFirst()</span></span><br><span class="line"><span class="comment">// 4. public java.lang.Object Pair.getSecond()</span></span><br><span class="line"><span class="comment">// 5. public void Pair.setFirst(java.lang.Object)</span></span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure></li><li><p><strong>分析：</strong></p><ul><li><p>很明显，由于类型擦除，继承<code>Pair&lt;LocalDate&gt;</code>，实际继承的是<code>Pair</code>，类型参数都替换为了<code>Object</code>，那为什么我们还可以重写<code>setSecond(LocalDate second)</code>方法而不报错呢？这就是<strong>类型擦除与多态发生的冲突</strong>；</p></li><li><p>当我们<strong>试图重写</strong>诸如此类方法，编译器为我们在DateInterval中生成<strong>桥方法（bridge method）</strong>来解决这个问题：</p><ul><li>为什么说是试图重写，因为这本来是不符合语法的，从父类继承下来的方法中并没有参数为 LocalDate 的 setSecond 方法；但是我们确实有这样的开发需求，所以让编译器为我们解决；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述 2. public void DateInterval.setSecond(java.lang.Object)就是桥方法，方法体为：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setSecond((LocalDate)second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即就是调用我们重写的setSecond(LocalDate second)方法</span></span><br></pre></td></tr></table></figure><ul><li>总结一下：编译器会根据我们是否重写了此类方法，而帮我们生成桥方法，生成桥方法也是重写父类方法的过程，即根据我们试图重写的方法，帮我们重写了参数为Object的方法；</li></ul></li><li><p>重写中的返回值协变规则也是运用桥方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写DateInterval 的 clone方法</span></span><br><span class="line"><span class="comment">// 实际类中存在两个clone方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DateInterval <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.CloneNotSupportedException</span>;</span><br><span class="line"><span class="keyword">protected</span> java.lang.<span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.CloneNotSupportedException</span></span><br></pre></td></tr></table></figure></li><li><p>那对于get方法这样返回类型是类型参数类型的呢？</p><ul><li><p>像这样的方法，我们一般不会重写，因为调用这样的get方法，编译器会帮我们自动强转；</p></li><li><p>而非要重写的话，结论还是同上，可以重写生成桥方法，但是会生成两个返回值类型不同，方法签名相同的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Object DateInterval.getSecond()</span><br><span class="line">  <span class="keyword">public</span> java.time.LocalDate DateInterval.getSecond()</span><br></pre></td></tr></table></figure></li><li><p>虽然编译器禁止我们写出这样的重载代码，但是它自己就这样写了，这是个特例；</p></li></ul></li></ul></li></ul><ul><li><p>其他要<strong>注意：</strong>（大都是因为类型擦除所引起）</p><ul><li><p>instanceof 与强转只能跟<strong>原始类型</strong>做判断；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种表达都是错误的</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;);</span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a;</span><br></pre></td></tr></table></figure></li><li><p>不要创建数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] pairs = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 分析：擦除后pairs变成了Pair[] 类型；</span></span><br></pre></td></tr></table></figure></li><li><p>不要使用带有类型变量的静态属性与方法；</p><ul><li>泛型类的静态上下文中类型变量无效</li></ul></li><li><p>注意擦除后的冲突；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T)</span> </span>;</span><br><span class="line"><span class="comment">// 擦除后，发生冲突</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Pair&lt;Father&gt; 与 Pair&lt;Son&gt;没有继承关系；</p><ul><li>即不能企图声明父类指向子类；</li></ul></li></ul></li></ul><ul><li><p>**通配符<code>?</code>**：</p><ul><li>子类限定<code>&lt;? extends Father&gt;</code>，只读；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function">extends Father <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setValue</span><span class="params">(? extends Father)</span>	<span class="comment">// 编译错误</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>超类限定<code>&lt;? super Father&gt;</code>，只写；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function"><span class="keyword">super</span> Father <span class="title">getValue</span><span class="params">()</span>	<span class="comment">// 编译错误</span></span></span><br><span class="line"><span class="function"><span class="title">setValue</span><span class="params">(? <span class="keyword">super</span> Father)</span></span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="5-集合"><a href="#5-集合" class="headerlink" title="5. 集合"></a>5. 集合</h3><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/76iRq4NO3oKA.png" alt="mark" style="zoom:67%"><br><ul><li><p>List 插入有序，可重复</p><ul><li><p>ArrayList 查询快、增删慢，线程不安全</p></li><li><p>Vector 查询快、增删慢，线程安全</p></li><li><p>LinkedList 查询慢、增删快，线程不安全</p></li></ul></li></ul><ul><li><p>Set 唯一，依赖于<code>hashCode()</code>和<code>equals()</code>方法</p><ul><li><p>HashSet 底层=hash表，无序，可以有null值</p></li><li><p>LinkedHashSet 底层=链表+hash表，插入有序，可以有null值</p></li><li><p>TreeSet 底层=红黑树，有序，不能有null值</p></li></ul></li></ul><ul><li><p>Map 键值对，键唯一</p><ul><li>HashMap 无序，线程不安全，可以有null值</li><li>HashTable（父类是Dictionary） 无序，线程安全，不能有null值</li><li>LinkedHashMap 无序</li><li>TreeMap 有序</li></ul></li></ul><hr><h3 id="6-注解-Annotation"><a href="#6-注解-Annotation" class="headerlink" title="6. 注解 Annotation"></a>6. 注解 Annotation</h3><ul><li><p>本质是一个接口，继承<code>java.lang.annotation.Annotation</code>接口；</p><ul><li>注解的属性就是接口中的抽象方法；</li><li>可以使用<code>default</code>给属性赋默认值；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Override 注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @SuppressWarnings 注解</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    属性列表 <span class="keyword">default</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>元注解：</strong>描述注解的注解：</p><ul><li><strong>@Target</strong> 声明注解的位置，属性 ElementType<ul><li>TYPE：类与接口上；</li><li>FIELD：成员变量上；</li><li>METHOD：方法体上；</li><li>PARAMETER：方法参数上；</li><li>……</li></ul></li><li><strong>@Retention</strong> 声明注解将被保留的阶段，属性 RetentionPolicy<ul><li>SOURCE：只保留在源文件，编译成class文件时就不再存在；<ul><li>检查性作用，@Override、@SuppressWarning</li></ul></li><li>CLASS（默认）：保留到class文件，加载class时遗弃；<ul><li>编译期生成辅助性代码，@Lombok</li></ul></li><li>RUNTIME：保存到class文件中，随class文件一起被加载进 JVM；<ul><li>运行时获取（通过反射）</li></ul></li></ul></li><li><strong>@Inherited</strong> 声明注解是否被子类继承；</li></ul></li></ul><ul><li><p><strong>反射获取运行时注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> ClassInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldInfo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MethodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClassInfo(&quot;MyAnnotationTest&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FieldInfo</span></span><br><span class="line">    <span class="keyword">int</span> anno;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FieldInfo(888)</span></span><br><span class="line">    <span class="keyword">int</span> tation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MethodInfo(name = &quot;myPrint&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyAnnotation.class;</span><br><span class="line"></span><br><span class="line">        ClassInfo classInfo = clazz.getAnnotation(ClassInfo.class);</span><br><span class="line">        System.out.println(classInfo.value());</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        FieldInfo fieldInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            fieldInfo = field.getAnnotation(FieldInfo.class);</span><br><span class="line">            System.out.println(fieldInfo.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">        MethodInfo methodInfo = method.getAnnotation(MethodInfo.class);</span><br><span class="line">        System.out.println(methodInfo.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-反射-Reflection"><a href="#7-反射-Reflection" class="headerlink" title="7.  反射 Reflection"></a>7. 反射 Reflection</h3><ul><li><p>Java 是静态语言，但具有一定的动态性。反射就是一个体现，它可以让我们在运行时分析一个类。JVM加载一个类后会为该类生成一个Class&lt;T&gt;类的对象，这个Class对象就封装了类的各个部分信息，我们可以通过Class对象来在运行时对类进行分析，执行其相应方法。</p></li><li><p>获取Class对象的三种方式：</p><ul><li><code>对象名.getClass()</code>，一般不用；</li><li><code>类名.class</code>必须导包，依赖太强，不用；<ul><li>不会初始化 Class对象；</li></ul></li><li><code>Class.forName(全类名)</code>最常用；<ul><li>会初始化 Class对象；</li></ul></li></ul></li><li><p><strong>使用反射</strong></p><ul><li>先定义一个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> publicField;</span><br><span class="line">    <span class="keyword">private</span> String privateField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyReflection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公有无参构造函数执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyReflection</span><span class="params">(<span class="keyword">int</span> publicField, String privateField)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publicField = publicField;</span><br><span class="line">        <span class="keyword">this</span>.privateField = privateField;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有带参构造函数执行了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get、set方法...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public方法被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private方法被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>获取并执行构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Class对象</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有公有构造方法</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有构造方法，包括私有等</span></span><br><span class="line">    constructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">	System.out.println(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定构造方法，参数为要获取的构造方法的参数的class对象；</span></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class);</span><br><span class="line">    <span class="comment">// 暴力反射，忽略访问修饰符</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 执行构造方法</span></span><br><span class="line">    MyReflection o = (MyReflection) constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印验证</span></span><br><span class="line">    System.out.println(o.getPrivateField() + o.getPublicField());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------执行结果--------</span></span><br><span class="line"><span class="keyword">public</span> com.reflection.MyReflection()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> com.reflection.MyReflection()</span><br><span class="line"><span class="keyword">private</span> com.reflection.MyReflection(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line"></span><br><span class="line">私有带参构造函数执行了</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>获取成员变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有公有属性-----&quot;</span>);</span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有属性-----&quot;</span>);</span><br><span class="line">    fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取指定属性，并调用-----&quot;</span>);</span><br><span class="line">    Field privateField = clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">    privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    MyReflection o = (MyReflection) clazz.getConstructor(<span class="keyword">null</span>).newInstance();</span><br><span class="line">    privateField.set(o,<span class="string">&quot;反射修改了私有属性&quot;</span>);</span><br><span class="line">    System.out.println(o.getPrivateField());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------结果------------</span></span><br><span class="line">-----获取所有公有属性-----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> com.reflection.MyReflection.publicField</span><br><span class="line">-----获取所有属性-----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> com.reflection.MyReflection.publicField</span><br><span class="line"><span class="keyword">private</span> java.lang.String com.reflection.MyReflection.privateField</span><br><span class="line">-----获取指定属性，并调用-----</span><br><span class="line">公有无参构造函数执行了</span><br><span class="line">反射修改了私有属性</span><br></pre></td></tr></table></figure></li><li><p><strong>获取方法并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有公有方法-----&quot;</span>);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有方法-----&quot;</span>);</span><br><span class="line">    methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取指定方法，并调用-----&quot;</span>);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">&quot;showStatic&quot;</span>,String.class);</span><br><span class="line">    <span class="comment">// 参数：执行对象 与 传参</span></span><br><span class="line">    <span class="comment">// 因为是静态方法，所以传递 null</span></span><br><span class="line">    method.invoke(<span class="keyword">null</span>, <span class="string">&quot;静态方法执行了&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    method = clazz.getDeclaredMethod(<span class="string">&quot;showPrivate&quot;</span>);</span><br><span class="line">    MyReflection o = (MyReflection) clazz.getConstructor(<span class="keyword">null</span>).newInstance();</span><br><span class="line">    method.invoke(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----结果-----</span></span><br><span class="line">-----获取所有公有方法-----</span><br><span class="line">    略</span><br><span class="line">-----获取所有方法-----</span><br><span class="line">    略</span><br><span class="line">-----获取指定方法，并调用-----</span><br><span class="line">静态方法执行了</span><br><span class="line">公有无参构造函数执行了</span><br><span class="line"><span class="keyword">private</span>方法被调用了</span><br></pre></td></tr></table></figure></li></ul><ul><li>应用场景：获取运行时注解，读取配置文件反射创建对象……</li></ul><hr><h3 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8. 多线程"></a>8. 多线程</h3><blockquote><p>　　一个程序同时执行多个任务，通常每一个任务称为一个线程（ thread），可以同时运行一个以上线程的程序称为多线程程序（ multi-threaded ) 。</p></blockquote><ul><li><p><strong>进程（process） VS 线程（thread）</strong></p><ul><li>进程是操作系统资源分配的基本单位，是程序的一次执行过程。进程间隔离性强，较安全但是进程间通信效率低；</li><li>线程是CPU进行调度的基本单位，是进程内的一个执行单元。进程间可以共享内存，便于通信但是伴随着风险，同时线程调度也要耗费一定资源；</li></ul><p>　　运行一个Java程序，开启一个JVM就是一个进程；一个Java程序最少有两个线程，即main线程和GC线程；</p></li><li><p><strong>Java中创建多线程</strong></p><ol><li>继承Thread类或实现Runnable接口（是一个函数式接口）；</li><li>重写run方法，run方法就是线程要做的工作；</li></ol></li></ul><ol start="3"><li>创建Thread类对象调用start方法启动线程；</li></ol><ul><li><p><strong>线程安全问题</strong></p><p>当多个线程同时对公有变量进行读写、写写操作时就可能出现线程安全问题；</p><ul><li>同步代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个锁对象</span></span><br><span class="line">Object lock = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="comment">// 获取锁对象，没有获取到则进入阻塞</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同步方法</p><ul><li>对于普通方法，锁是this；对于static方法，锁是该类的class对象；</li></ul></li><li><p>可重入锁 reentrantlock</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lock.lock(); </span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock(); </span><br></pre></td></tr></table></figure></li><li><p><strong>线程的状态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/g2Qt5IlyFOWy.png" alt="mark"></p></li></ul><ol><li><p>New 新创建：即 new Thread(r) 后还没有调用start方法时，线程还没有开始运行；</p></li><li><p>Runnable 可运行：线程处在随时可以运行的状态，但可能在运行也可能没有运行，取决于是否得到了时间片；</p></li><li><p>Blocked 被阻塞 ；</p></li><li><p>Waiting 等待；</p></li><li><p>Timed Waiting 计时等待；</p><blockquote><p>　　当线程处于被阻塞或等待状态时，它暂时不活动 ，它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。</p><p>　　当一个线程试图获得另一个线程持有的锁时，进入阻塞；</p><p>　　当线程等待另一个线程通知调度器一个<strong>条件</strong>时（线程通信），进入等待；</p><p>　　当调用了<code>Thread.sleep</code>、<code>Object.wait</code>、<code>Thread.join</code>、<code>Lock.tryLock</code>以及<code>Condition.await</code>的方法时进入计时等待；</p></blockquote></li><li><p>Terminated 被终止：run方法正常结束，或因为一个没有捕获的异常导致run方法终止，则线程死亡。</p></li></ol><ul><li><strong>线程的属性</strong></li></ul><ol><li><p>优先级：Java中使用<code>setPriority</code>方法设置线程优先级在[1,10]之间越来越高，默认为5；</p><ul><li><p>线程优先级高度依赖于宿主机系统的实现，即Java将优先级映射到宿主机的线程实现机制上，例如 Windows 有7个优先级，Oracle为Linux提供的 JVM 中没有线程优先级；</p></li><li><p>若高优先级的线程没有进入非活动状态，那么低优先级的线程可能会饿死；</p></li><li><p><code>static void yield()</code>，线程礼让；</p></li></ul></li><li><p>守护线程：在线程启动之前调用<code>thread.setDaemon(true)</code>声明该线程为守护线程，守护线程唯一的作用是为其他线程提供服务，例如计时线程；</p></li></ol><ul><li><p><strong>线程通信</strong></p><p>线程之间不仅仅只有竞争关系，还有协作关系；当一个线程进人临界区，却发现在某一条件满足（或者说其他线程执行完某一操作）之后它才能执行，这时要使用一个<strong>条件对象</strong>来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p><ul><li>一个锁对象可以有一个或多个相关的条件对象，使用<code>new Condition</code>获取一个条件对象，习惯命名为能反映该条件的名称；当一个线程获得了锁但是发现执行的条件不足时，会<strong>使用条件对象调用</strong><code>await</code>方法，主动放弃该锁，进入Waiting状态，注意区别于线程调用await方法。这时只能等待另一线程调用同一条件上的<code>signalAll</code>方法才会被唤醒，被唤醒后还要重新加入对锁的竞争行列；</li><li>await 和 signalAll 对应着 wait 和 notifyAll 方法；</li></ul></li><li><p><strong>线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(线程数);</span><br><span class="line"><span class="comment">// 获取线程对象并执行</span></span><br><span class="line">service.submit(runnable);</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-IO流"><a href="#9-IO流" class="headerlink" title="9. IO流"></a>9. IO流</h3><p>（插眼）</p><hr><h3 id="10-网络编程"><a href="#10-网络编程" class="headerlink" title="10. 网络编程"></a>10. 网络编程</h3><p>（插眼）</p><hr><h3 id="11-lambda-amp-函数式接口-amp-Stream流"><a href="#11-lambda-amp-函数式接口-amp-Stream流" class="headerlink" title="11. lambda &amp; 函数式接口 &amp; Stream流"></a>11. lambda &amp; 函数式接口 &amp; Stream流</h3><ul><li>lambda 表达式是一个可以<strong>推导、传递</strong>的<strong>代码块</strong>，主要解决了 Java 过分面向对象的缺点，因为我们有时候<strong>只关注做什么产生什么结果</strong>，而不关注是<strong>”谁“</strong>用什么方法产生的这个结果，这个”谁“就是lambda帮我们省略的对象；</li><li><strong>格式：</strong><ul><li><code>()</code> 表示参数列表，无参为空，参数类型一定时可以省略类型；</li><li><code>-&gt;</code> 表示推导传递之意；</li><li><code>&#123; &#125;</code> 表示方法体，只有一条语句时可以省略花括号、分号和return；</li></ul></li><li><strong>lambda的推导作用：</strong><ul><li>回想匿名内部类解决了什么样的问题，原本我们需要写一个类、继承接口、实现方法、在需要的地方new对象调用方法，匿名内部类让我们可以直接声明接口创建匿名实现类，并直接重写其方法，从而简化了步骤；而lambda表达式在这一基础上再次简化，更加方便我们使用，但是使用 lambda推导是有条件的，那就是进行推导的接口必须是一个函数式接口；<ul><li>函数式接口：有且只有一个抽象方法的接口，重载也不行；默认方法、静态方法、重新声明的Object方法都不考虑；</li><li><code>@FunctionalInterface</code>注解可以检查该接口是否满足函数式接口条件；</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法参数有一个函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">talkSth</span><span class="params">(String s, People p)</span> </span>&#123;</span><br><span class="line">        p.talk(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类方式</span></span><br><span class="line">    MyLambda.talkSth(<span class="string">&quot;使用匿名内部类&quot;</span>, <span class="keyword">new</span> People() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// lambda方式</span></span><br><span class="line">    MyLambda.talkSth(<span class="string">&quot;使用lambda表达式&quot;</span>, (s) -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>lambda传递作用——方法引用</strong></p><ul><li>上面 lambda方式的代码还是显得有点冗余，可以传递方法引用简化之：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLambda.talkSth(<span class="string">&quot;使用lambda表达式&quot;</span>, System.out::println);</span><br></pre></td></tr></table></figure><ul><li>说明：<code>::</code> 是方法引用符；lambda推导时我们使用自己重写的方法，而传递方法引用可以让我们使用已有的方法；</li></ul></li></ul><ul><li><p><strong>常用函数式接口</strong></p><ul><li><code>java.util.function</code>包下</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/a5aHeF0nttmC.png" alt="mark"></p></li></ul><ul><li><p><strong>Stream 流思想</strong></p><ul><li><p>获取流：</p><ul><li>Collection 集合通过默认方法 stream() 获取；</li><li>数组通过Stream&lt;T&gt; 接口的of方法获取；</li><li>Map 要将keyValue封装成entry再调用stream()方法获取；</li></ul></li><li><p>常用流处理方法：</p><ul><li>返回值不为 Stream 即会终结流；</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void forEach(Consumer&lt;? super T&gt; action)</code></td><td>将流中每一个元素交给Consumer处理</td></tr><tr><td><code>long count()</code></td><td>返回流中元素个数</td></tr><tr><td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td>接受Predicate作为筛选条件，返回true则保留元素，否则剔除元素</td></tr><tr><td><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td><td>将T类型转换为R类型</td></tr><tr><td><code>Stream&lt;T&gt; limit(long maxSize)</code></td><td>保留前几个元素</td></tr><tr><td><code>Stream&lt;T&gt; skip(long n)</code></td><td>删除前几个元素</td></tr><tr><td><code>Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td><td>合并流</td></tr></tbody></table></li></ul></li></ul><hr><h3 id="12-常用类与接口"><a href="#12-常用类与接口" class="headerlink" title="12. 常用类与接口"></a>12. 常用类与接口</h3><p>　　Java 包结构：</p><p><img src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/4N3oz33zbRAK.png" alt="mark"></p><p>　</p><ul><li><p><strong>Scanner</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure></li><li><p><strong>Random</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// 返回 [0，10）之间的随机数</span></span><br><span class="line"><span class="keyword">int</span> i = r.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Math</strong></p><ul><li>StrictMath　更加精确，但是效率没有Math高；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.abs();	  <span class="comment">// 取绝对值</span></span><br><span class="line">Math.ceil();  <span class="comment">// 向上取整</span></span><br><span class="line">Math.floor(); <span class="comment">// 向下取整</span></span><br><span class="line">Math.round(); <span class="comment">// 四舍五入</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Arrays</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString(arr);</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.copyOf(arr,<span class="keyword">int</span> newLength);</span><br><span class="line"><span class="comment">// copyOf底层调用的是System的 arraycopy方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date构造</span></span><br><span class="line">Date();</span><br><span class="line">Date(<span class="keyword">long</span> 毫秒值);</span><br><span class="line"><span class="comment">// DateFormat的实现类SimpleDateFormat，进行格式化</span></span><br><span class="line">SimpleDateFormat(String pattern); <span class="comment">//yyyy-MM-dd HH-mm-ss</span></span><br><span class="line">sdf.format(date);<span class="comment">//日期-&gt;字符串</span></span><br><span class="line">sdf.parse(str);<span class="comment">//字符串-&gt;日期</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Calendar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span>;<span class="comment">// 获取</span></span><br><span class="line"><span class="function">Date <span class="title">getTime</span><span class="params">()</span></span>;<span class="comment">// 转化为Date</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>; <span class="comment">// 根据域获取值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span></span>;<span class="comment">// 根据域设置值</span></span><br><span class="line"><span class="comment">/* filed 取值：</span></span><br><span class="line"><span class="comment">	YEAR,MONTH,DAY_OF_MONTH;</span></span><br><span class="line"><span class="comment">	HOUR,HOUR_OF_DAY;</span></span><br><span class="line"><span class="comment">	MINUTE,SECOND;</span></span><br><span class="line"><span class="comment">	DAY_OF_WEEK;(周日为1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>**StringBuilder **</p><p>Stringbuffer 线程安全；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder(<span class="keyword">int</span> capacity);<span class="comment">// 默认16</span></span><br><span class="line">StringBuilder(String str);</span><br><span class="line">append();</span><br><span class="line">toString();</span><br></pre></td></tr></table></figure></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">HenryKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://henrykang99.github.io/JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html">https://henrykang99.github.io/JavaSE/JavaSE知识回顾.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://henrykang99.github.io" target="_blank">HenryKang的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/XX6kRgAlUcwx.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JavaSE/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Alu2Purh9qqp.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">正则表达式</div></div></a></div><div class="next-post pull-right"><a href="/Others/hello-world.html"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/helloworld_Pexels-photo-346885.jpeg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello Hexo</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JavaSE/正则表达式.html" title="正则表达式"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Alu2Purh9qqp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-04</div><div class="title">正则表达式</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/avatar.gif" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/friend_404.gif"' alt="avatar"><div class="author-info__name">HenryKang</div><div class="author-info__description">往日不可谏 来者犹可追</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" href="/message"><i class="fas fa-pencil-alt"></i><span>给我留言！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1278315651&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/wechat.png" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:henrykang99@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来访！</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0verview"><span class="toc-text">0verview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1. 数据类型 &amp; 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1-amp-%E7%B1%BB"><span class="toc-text">2. 对象 &amp; 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8"><span class="toc-text">3. 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%9B%E5%9E%8B"><span class="toc-text">4. 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88"><span class="toc-text">5. 集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-text">6. 注解 Annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8F%8D%E5%B0%84-Reflection"><span class="toc-text">7. 反射 Reflection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">8. 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-IO%E6%B5%81"><span class="toc-text">9. IO流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">10. 网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-lambda-amp-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-amp-Stream%E6%B5%81"><span class="toc-text">11. lambda &amp; 函数式接口 &amp; Stream流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">12. 常用类与接口</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JVM/JVM%E4%B8%8E%E5%A4%9A%E6%80%81.html" title="JVM 方法调用与多态"><img data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/af618a5d547.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"' alt="JVM 方法调用与多态"></a><div class="content"><a class="title" href="/JVM/JVM%E4%B8%8E%E5%A4%9A%E6%80%81.html" title="JVM 方法调用与多态">JVM 方法调用与多态</a><time datetime="2020-08-08T16:00:00.000Z" title="发表于 2020-08-09 2020-08-09T00:00:00+08:00">2020-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html" title="JVM内存模型与锁优化"><img data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/1f5b9e6728c.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"' alt="JVM内存模型与锁优化"></a><div class="content"><a class="title" href="/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html" title="JVM内存模型与锁优化">JVM内存模型与锁优化</a><time datetime="2020-08-06T16:00:00.000Z" title="发表于 2020-08-07 2020-08-07T00:00:00+08:00">2020-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html" title="计网小结"><img data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/04681ffa824.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"' alt="计网小结"></a><div class="content"><a class="title" href="/Networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html" title="计网小结">计网小结</a><time datetime="2020-08-04T16:00:00.000Z" title="发表于 2020-08-05 2020-08-05T00:00:00+08:00">2020-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Database/MySQL%E6%97%A5%E5%BF%97.html" title="MySQL日志：binlog 和 redolog"><img data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/1f5b9e6728c.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"' alt="MySQL日志：binlog 和 redolog"></a><div class="content"><a class="title" href="/Database/MySQL%E6%97%A5%E5%BF%97.html" title="MySQL日志：binlog 和 redolog">MySQL日志：binlog 和 redolog</a><time datetime="2020-06-17T16:00:00.000Z" title="发表于 2020-06-18 2020-06-18T00:00:00+08:00">2020-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Database/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81.html" title="MySQL事务与并发控制和锁"><img data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/9148b9293d9.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/aKOcLiyPl2JQdFD.webp"' alt="MySQL事务与并发控制和锁"></a><div class="content"><a class="title" href="/Database/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81.html" title="MySQL事务与并发控制和锁">MySQL事务与并发控制和锁</a><time datetime="2020-06-13T16:00:00.000Z" title="发表于 2020-06-14 2020-06-14T00:00:00+08:00">2020-06-14</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By HenryKang</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():$.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js",function(){window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()}))</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'e14MB9CAUNFcLNr1zJcICtL0-gzGzoHsz',
      appKey: 'KWl3jnLuGGg4Mwkfle447t0B',
      placeholder: '输入邮箱，也收不到回复提醒(滑稽)……',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://e14mb9ca.lc-cn-n1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '83e42816f7a40c1058ea',
      clientSecret: '0cc3525beed9f758cc01ccc3e978f6e6828223af',
      repo: 'blog_comment',
      owner: 'henrykang99',
      admin: ['henrykang99'],
      id: '591126f7fc98b909ee6539cbba920b97',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<[^>]+>/g,"") // remove html tag
    content = content.replace(/(http(s?):)([/|.|\w|\s|-])*\.(?:jpg|jpeg|gif|png|webp)/g, '') // remove image link
    content = content.replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi, '') // remove url

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon 
    let defaultIcon = ''
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    for (let i = 0; i < array.length; i++) {
      result += '<div class=\'aside-list-item\'>'

      if (true) {
        result += `<a href='${array[i].url}' class="thumbnail"><img src='${getIcon(array[i].avatar, array[i].mail)}' alt='${array[i].nick}'></a>`
      }

      result += `<div class='content'>
      <a class='comment' href='${array[i].url}'>${array[i].content}</a>
      <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
      </div></div>`
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.pjax && window.pjax.refresh($dom)
  }

  const getValineData = () => {
      let serverURL = ''
      if (true) {
        serverURL = 'https://e14mb9ca.lc-cn-n1-shared.com'
      } else {
        serverURL = 'https://e14MB9CA.api.lncldglobal.com'
      }

    var settings = {
      "url": `${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,
      "method": "GET",
      "timeout": 0,
      "headers": {
        "X-LC-Id": 'e14MB9CAUNFcLNr1zJcICtL0-gzGzoHsz',
        "X-LC-Key": 'KWl3jnLuGGg4Mwkfle447t0B',
        "Content-Type": "application/json"
      },
    }

    $.ajax(settings).done((response) => {
      var valineArray = []
      response.results.forEach((e)=>{
        valineArray.push({
          'avatar': e.QQAvatar,
          'content': changeContent(e.comment),
          'mail': e.mail,
          'nick': e.nick,
          'url': e.url,
          'date': e.createdAt,
        })
      })
      
      saveToLocal.set('leancloud-newest-comments', JSON.stringify(valineArray), 10/(60*24))
      generateHtml(valineArray)

    }).fail(()=>{
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.innerHTML= "无法获取资料，请确认相关配置是否正确"
    })
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('leancloud-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getValineData()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="117434339" data-server="netease" data-type="playlist" data-lrctype="-1" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/balabala/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div></body></html>