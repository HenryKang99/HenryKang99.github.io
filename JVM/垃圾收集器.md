### 0verview

### 1. 谁是垃圾？

　　当一个对象不再被外界引用时，就成为了垃圾；GC主要回收的区域是**堆和方法区**，因为程序计数器和栈的生命周期和线程相同。

#### 1.1 堆的回收

　　怎样确定哪些是垃圾，主要有下面两种方法：

1. 引用计数法

   > 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

   　　引用计数法难以解决间接引用或循环引用问题：

   ```java
   class A{
       Object b = null;
   }
   public static void main(String s[]){
       A a = new A();
       B b = new B();
       a.b = b;
       a = null;
       b = null;
   }
   // 不能在一轮中回收a和b，因为a对象中有一个属性引用到b对象，只有a回收了，b才能回收；
   // 还有可能循环引用，就是上述 a和b中的属性互相引用b和a对象，这时候引用计数法永远无法回收a和b；
   ```

   

2. 可达性分析法

   >　　这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![mark](https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/hsIScu10IJtV.png)

- **哪些可以当做 GC Roots 对象：**

  - 栈中的局部变量，因为方法执行过程中使用到的对象资源当然不能被回收；
  - 类的静态引用型变量，只要类不卸载，这些引用就一直存在；
  - JVM内常驻内存的对象，如基本型的Class对象、异常对象、类加载器等；
  - 本地方法栈中 JNI （Native方法）引用的对象；
  - ……

- **过程分析：**

  假如有一个静态引用型变量 obj，它就可以作为GC Roots中的一员，从它向下搜索，对引用链上的对象进行标记，如 obj 内有一个A成员对象，A又有B、C两个成员对象，那A、B、C就不会被回收；把GC Roots中的根节点全部按此方法操作一番，剩下没标记的就是垃圾，等待被回收。

#### 1.2 方法区的回收

　　主要回收**常量池**和卸载**类信息**。

1. 判定废弃的常量比较容易，像回收堆中对象一样，若没有指向该常量的引用，就可以回收了；
2. 判定不再使用的类非常困难，需要满足下面的条件：
   - 所有该类及其子类的实例都被回收了；
   - 该类的Class对象没有被引用；
   - 加载该类的类加载器已经被回收；
     - 这一点很难实现，因为大多都是采用默认加载器加载，我们不可能让默认加载器被回收；但其实这些类不卸载也没关系，它们一般不会占太大空间；需要注意的是我们自定义加载器，动态生成的类信息，这些类信息可能会膨胀而需要回收。

---

### 2. 垃圾收集思想

#### 2.1 分代回收理论

　　收集器将堆划分成具有不同年龄的区域，主要目的是对其进行不同频率的回收。至少分为**新生代**与**老年代**，随着收集次数的增加，那些存活下来的“年长的对象“被转移到老年代，**老年代的对象往往有生命周期往更长发展的趋向性**，我们就可以减少老年代回收垃圾的频率，以提升整个GC的效率。

　　MinorGC、MajorGC、FullGC 分别对应着新生代回收、老年代回收、整堆回收；GC是很耗费资源的，而FullGC的代价更不用说（一般会进行碎片整理），针对不同的区域采用合适的垃圾回收算法，可以减少FullGC的次数；后面会提到G1收集器，它属于MixedGC 混合回收。

　　分代回收有一个非常大的问题就是，两代对象之间可能存在**跨代引用**，这样在MinorGC过程中就不得不再遍历老年代对象。而经过实践证明或者由我们猜想可以得知：**存在互相引用关系的两个对象有共存亡的趋向性**。再结合上面说到的老年代有更年长的趋向性可以知道，跨代引用中的新生代对象有着很大的概率也会迈向老年代。因此我们可以不为跨代引用去遍历老年代。



#### 2.2 垃圾收集算法

1. **标记-清除（Mark-Sweep）**

   根据前面说的判断垃圾的方法，对需要回收的对象进行标记，标记完之后进行统一回收；

    　　**缺点**：产生大量零头，后面如果碰到大对象而没有合适大小内存分配，有可能会引发FullGC；还有就是效率不稳定，随着对象数量的增加，不论是标记还是清除耗费的时间都是**不可控**的。后面会讲到GC追求低延迟，这就要求在时间上要有一定程度的可控性。

   <br/>

2. **标记-复制（Mark-Copying）**

   复制算法解决了清除算法产生大量零头的问题；

    　　该算法将内存分成1:1的A、B两块，每次只用其中一块，当 A 满了之后进行标记，将要存活下来的对象复制到另一块 B 上，然后清除 A 块，不断往复。**主要运用于新生代**；

    　　**缺点**：显而易见，浪费了很大的空间，同时在存活对象较多时复制操作效率也比较低。

    　　经验发现，新生代对象有将近98%都逃不过第一次回收，即不需要对内存进行1:1的划分，因此又有了下面的**变体形式**：

    　　将新生代内存分为两块较小的Survivor空间和一块较大的Eden空间，HotSpot默认比例为1:1:8，每次只用Eden和Survivor中的一块，方法和标记-复制一样，每次将存活下来的对象复制到另一块Survivor上；

    　　**注意**：

   - 当存活的对象超过一块Survivor大小时，通常需要由老年代内存进行**分配担保**，即有可能将“年龄不够”的对象**提前转入老年代**。
   - 有一些大对象，如大数组、字符串，会直接进入老年代，避免在新生代的Eden和Survivor之间来回复制。

   <br/>

3. **标记-整理（Mark-Compact）**

   整理算法和复制算法有异曲同工之妙，它通过移动对象来消除了复制算法中浪费的内存；

   　　标记完之后将存活的对象都向内存的一端移动，然后清除边界以后的对象。**主要用于老年代**

   　　**缺点**：整理非常耗费时间，不但如此，移动对象并更新引用还会使**用户进程被暂停**，被形象成为“Stop The World”；

   　　STW主要是由于枚举根节点造成的，因为用户线程运行中的引用关系可能会发生改变，影响根节点枚举结果的准确性，所以必须暂停用户线程；查找引用链工作可以与用户线程并发执行。

　　<br/>

---

### 3. 垃圾收集器

> JDK1.8 默认使用 ParallelScavenge + ParallelOld 收集器；
>
> JDK1.9 默认使用 G1 收集器。

![mark](http://image.henrykang.site/blog/20200314/R7utwIia1JKj.png)

　　![mark](https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/nOFD4ePsMtDj.png)

　　可以看到上面显示HotSpot工作在Server模式，相对的还有Client模式，二者的主要区别就在于JVM默认的一些参数和垃圾收集器的选用上有所不同，因为一般桌面端与服务器端的硬件差别是非常大的，在不同的应用场景下选择不同的垃圾收集器可以让用户获取更好的体验。

#### 3.1 新生代收集器

1. **Serial收集器**

　　单线程收集器，进行回收时必须暂停其他线程，但是它简单高效，只专心于做垃圾回收没有额外的线程交互开销，因此是HotSpot虚拟机Client模式下默认的新生代收集器。

2. **ParNew收集器**

　　是Serial收集器的多线程版，主要用于Server模式，在进行回收时仍会STW。

3. **ParallelScavenge收集器**

 　　在ParNew的基础上追求更高的吞吐量，这就要使垃圾回收时STW的最大时间尽可能的可控。

　　-XX：MaxGCPauseMillis 设置最大垃圾收集停顿时间，设置太小反而会频繁GC；

　　-XX：GCTimeRatio 设置GC时间比率，取0-99，即GC占总运行时间的倒数 ；

　　-XX：+UseAdaptiveSizePolicy 自适应调节，运行期间收集数据动态去调整各个参数；



#### 3.2 老年代收集器

1. **SerialOld收集器**

　　Serial收集器的老年代版，单线程，主要用于Client端，可以配合Serial、ParNew工作。

2. **ParallelOld收集器**

　　ParallelScavenge的老年代版，多线程，在其出现之前，ParallelScavenge只能和SerialOld配合工作，拖慢了整个服务器端GC的速度。

3. **CMS收集器**

　　上面的收集器新生代均基于复制算法，老年代基于整理算法，因此回收时都会STW（枚举根节点、复制、整理不可避免STW）。CMS（Concurrent Mark Sweep）收集器追求最短的STW时间，所以采用的是**标记-清除**算法。

- 运作机制分为下面四个步骤：
  1. 初始标记：速度很快，只标记根节点能直接关联到的对象，枚举根节点会STW；
  2. 并发标记：遍历整个引用链进行标记，速度较慢；
  3. 重新标记：重新标记第2步执行过程中用户线程运作导致的变化，会STW；
  4. 并发清除：清除；

- 缺点：不必说的就是产生大量零头，可能会提前引发FullGC；无法处理“浮动垃圾”（即并发期间产生的新垃圾），只能下一次处理；并发虽然不会STW，但是占用了一部分线程，降低了吞吐量。

#### 3.3 整堆收集器

　　**GarbageFirst**（G1收集器）主要使用在Server端，它基于将内存划分为很多区域（Region）的思想，实现了**局部回收**的功能。可以通过-XX：MaxGCPauseMillis参数设置一个GC停顿时间的**期望值**，一定程度上达到停顿时间可控。

　　G1收集器打破了传统的分代回收思想，它将堆划分为多个大小相等的Region，在进行回收时不再判断对象属于哪一代，而是判断哪块Region垃圾最多，回收价值最高，优先去回收这些区域，这也是为什么叫G1收集器。当然G1也没有抛弃分代思想，因为分代很大程度上提升了GC的效率。每一块Region都有其“年龄”，这样GC就可以对这块Region该不该回收根据其年龄进行权衡。

- 步骤：

  1. 初始标记：枚举根节点，会STW；

  2. 并发标记：可以与用户线程并发；

  3. 最终标记：会STW；

     前三步与CMS类似；

  4. 筛选回收：根据回收效益对每个Region的进行优先级排序，再根据用户设置的停顿期望值指定回收计划，将要回收的Region中的存活对象**复制**到另一块空Region上，再清除掉旧Region。当然因为复制移动了对象所以会STW；

- **存在的问题**：首先可以看到的是清理不干净，但是这换来了其他地方的提升，只要回收的速度快于分配的速度，那就不会出问题；跨代跨区引用使得G1得在内存中维护大量的表……