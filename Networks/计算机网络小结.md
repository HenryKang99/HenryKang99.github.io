### 0verview

- **OSI模型**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

  - 着重于计算机网络问题的讨论。

- **TCP/IP模型**：链路层、互联网层、传输层、应用层。

  - 着重于讨论协议。

    <img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200905201340736.png" alt="image-20200905201340736" style="zoom: 80%;" />

- 一般学习按照下面五层展开讨论：

  - **物理层**：关注比特作为信号如何传输的问题，如电气特性、物理接口等。
  - **数据链路层**：关注两台相邻的机器之间如何<u>可靠的传递信息块</u>，包括封装成帧、检验纠错、控制速率。
    - MAC帧的信息部分，即 IP 数据报，长度不超过 1500 字节。
    - 传输速率：电路中 2/3 c、光纤中 9/10 c
  - **网络层**：关注数据包如何在路由器之间转发，为上层提供<u>可靠的数据包交付</u>服务。
  - **传输层**：在两台计算机的进程之间传递数据。
  - **应用层**：为了使用下层提供的网络传输服务，为某一类问题定义精确地通信规则（协议）。

## 3. 网络层

> 　　向上层提供尽最大努力的数据报交付服务，即可靠交付应该由上层（传输层）来保证，IP层甚至不对数据部分进行校验，这也使得现在普通路由设备更加简单、便宜，促进了互联网的发展。

### 3.1 虚电路服务 VS 数据报服务

- 虚电路：模拟打电话所使用的面向连接的通信方式，当两台计算机要进行通信时，先建立一条虚拟的连接，<u>预留</u>出双方通信所需要的<u>一切网络资源</u>。

| **对比的方面**             | **虚电路服务**                                   | **数据报服务**                                     |
| :------------------------- | ------------------------------------------------ | -------------------------------------------------- |
| 思路                       | 可靠通信应当由网络来保证                         | 可靠通信应当由用户主机来保证                       |
| 连接的建立                 | 必须有                                           | 不需要                                             |
| 终点地址                   | 仅在连接建立阶段使用，每个分组使用短的虚电路号   | 每个分组都有终点的完整地址                         |
| 分组的转发                 | 属于同一条虚电路的分组**均按照同一路由进行转发** | 每个分组**独立选择路由进行转发**                   |
| 当结点出故障时             | 所有通过出故障的结点的虚电路均不能工作           | 出故障的结点可能会丢失分组，一些路由可能会发生变化 |
| 分组的顺序                 | 总是按发送顺序到达终点                           | 到达终点的时间不一定按发送顺序                     |
| 端到端的差错处理和流量控制 | 可以由网络负责，也可以由用户主机负责             | 由用户主机负责                                     |

### 3.2 IP协议

　　在网络层与IP协议配套使用的还有几个协议：

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00258.jpg" alt="img" style="zoom:50%;" />

1. **ARP**，Address resolution Protocol，地址解析协议，用于获取同一个网络内其他主机的MAC地址；
2. **ICMP**，Internet Control Message Protocol，网际控制报文协议；
3. **IGMP**，Internet Group Message Protocol，网际组管理协议。

#### 3.2.1 IP地址

> IP 地址的编址方法经历了三个阶段：分类的 IP 地址、子网的划分、构造超网。

##### 1. 分类的 IP 地址

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00131.jpg" alt="img" style="zoom: 50%;" />

　　常用的三类IP地址：

| 网络类别    | 网络号                                                | 主机号                                                   | 备注  |
| ----------- | ----------------------------------------------------- | -------------------------------------------------------- | ----- |
| A类  0...   | 全0是保留地址<br />全1，即127... 是环回地址           | 全0表示本主机所连接的网络<br />全1表示该网络上的所有主机 | 50%   |
| B类  128... | 不会出现全0或全1的情况<br />但是128.0.0.0规定不能指派 | 同上                                                     | 25%   |
| C类  192... | 同上，192.0.0.0不能指派                               | 同上                                                     | 12.5% |

---

##### 2. 子网的划分

> 　　两级IP不够灵活，还造成了IP地址的浪费，所以使用子网掩码将两级IP划分为三级IP。

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00137.jpg" alt="img" style="zoom:50%;" />

<br>

**使用子网时的分组转发：**

1. 先判断是否为直接交付，即使用IP地址和与路由器直接相连的网络的子网掩码相与；
2. 看是否有特定路由；
3. 查路由表的每一行，按顺序与其中的子网掩码相与，看是否等于对应的网络号；
4. 是否有默认路由；
5. ICMP报告分转发出错。

**注意：**

- 子网掩码没有硬性规定一定要是连续的 1，但建议这样做。
- 同样的IP和不同的子网掩码相与，可能得到相同的网络地址。

----

##### 3. 构造超网

> 为缓解IP地址的消耗，使用**无分类域间路由选择** CIDR，是一种**无分类编址**方法。
>
> 定义为： IP地址 ::= {<网络前缀>，<主机号>}

#### 3.2.2 ARP协议

> 　　ARP，Address Resolution Protocol，地址解析协议，用于获取本网络上其他主机的MAC地址。
>
> 　　还有RARP协议，逆地址解析，从MAC地址得到IP地址，但后来的DHCP已经包含了这个功能，所以RARP已经不用了。

　　**解析过程：**

　　当主机A要向**本局域网**上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。

　　也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址：

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00231.jpg" alt="img" style="zoom: 50%;" />

#### 3.2.3 IP数据报

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00240.jpg" alt="img" style="zoom:50%;" />

**注意：**

- **生存时间**：TTL（Time To Live），现指IP数据报经过路由器的**跳数限制**，8位，最大值255。
- **协议：**指出此数据报携带的数据使用的是何种协议（运输层传来的），以便于IP层知道将数据交给上层的哪个协议处理。
  - 由此，可以知道不同协议可以使用相同端口号。
- **首部校验和：**注意IP层只对IP数据报的首部进行差错检验，可靠的信息传输用由运输层保证，由运输层检验数据。

- IP数据报的长度不能超过数据链路层规定的**最大传送单元** MTU（Maximum Transfer Unit）的值，1500 字节。

#### 3.2.4 ICMP协议

> ICMP（Internet Control Message Protocol），网际控制报文协议

- 分类：
  - ICMP差错报告报文
    - 终点不可达
    - 时间超过：TTL为0
    - 参数问题
    - 重定向
  - ICMP询问报文
- 应用举例：
  - PING（Packet InterNet Groper），分组网间探测。
    - 是应用层直接使用网络层的一个应用，没有经过运输层。
  - Traceroute，跟踪一个分组从源点到终点的路径，可以基于UDP或ICMP实现。
    - 从源主机向目标主机发送一连串的IP数据报，数据是无法交付的UDP用户数据报，TTL依次设置为1,2,3...，以此来获得**ICMP时间超过**差错控制报文，直到收到一条**ICMP终点不可达**报文，从而知道路由轨迹。

#### 3.2.5 内部网关协议

##### 1. RIP

> 　　Routing Information Protocol，路由信息协议，是一种基于距离向量的路由选择协议，最大的优点是简单，<u>每一个路由器都记录了自己到其他目的网络的距离</u>。

- **约定：**从某一路由器到其直接连接的网络的距离为1,，到非直接相连的网络的距离为经过的路由器数+1。

- **注意：**RIP 协议规定一条路径最多只能包含15个路由器，即最大距离为16，超过16即认为不可达。

- **步骤：**

  对**相邻路由器**发送过来的RIP报文：

  1. 对地址为 X 的路由器发来的信息 “到目的网络，距离，下一跳”，如“net A，B，C” 意为 我到网络 A 需要经过下一跳路由器 C，距离为 B。

     更改距离为原距离+1，更改下一跳为 X，即“net A，B+1，X”，意为当前路由器要到网络 A，需要经过路由器 X，距离为 B+1，只是记录下来，此时还没有更新到路由表。

  2. 对记录的信息进行如下判断：

     - 若原路由表不包含目的网络A的条目，则新增信息到路由表；
     - 若原路由表包含目的网络N的条目，判断：
       - 若下一跳地址是 X，则直接更新路由表为最新信息；
       - 若下一跳地址不是 X，则比较距离，新距离小于旧距离则更新。

  3. 三分钟没有收到相邻路由器的RIP报文，则标记其举例为16，即不可达。

  4. 依据：设X是结点A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X和X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。

- **特点：**

  - 位于应用层，使用 UDP；
  - 只和相邻的路由器交换信息；
    - 定时交换，交换的是本路由器所<u>知道的所有信息</u>，因此网络不能太大；
  - 每个路由器记录的都是能到达的网络的最短举例；
  - 好消息传播的快，坏消息传播的慢；
  - 实现简单，开销较小。

##### 2. OSPF

> Open shortest Path First，开放最短路径优先。

- **特点：**
  - 与当前自治系统内的所有路由器交换信息，成为洪泛法；
  - 发送的信息是与当前路由器相邻的所有路由器的**链路状态**，包含当前路由器和谁<u>相邻</u>，和到达这些路由器的<u>代价</u>；
    - 度量：费用、距离、时延、带宽等；
  - 只有链路状态发生变化时，才会交换信息；
  - 所有路由器都会维护一个链路状态数据库，是一张全网的拓扑结构图；
  - 位于网络层，不像RIP使用 UDP，直接使用IP数据报发送数据。

#### 3.2.6 外部网关协议

##### 1. BGP

> BGP，边界网关协议。

- **特点：**
  - 每个自治系统选出一个发言人，即边界路由器；
  - 发言人之间使用 TCP 交流信息；
  - 交流的信息包括要到达某个网络需要经过的自治系统；
  - 位于应用层。

----

## 4. 传输层

> 　　提供端到端的通信，只有主机的协议栈才由运输层，路由部分只会使用到下三层的功能。任务还要包含对报文的差错检测，因为IP层只对IP数据报的首部进行校验，可靠传输由传输层来保证。

### 4.0 一些使用UDP、TCP的协议

| **应用**       | **应用层协议**           | **运输层协议** |
| -------------- | ------------------------ | -------------- |
| 名字转换       | DNS（域名系统）          | UDP            |
| 文件传送       | TFTP（简单文件传送协议） | UDP            |
| 路由选择协议   | RIP（路由信息协议）      | UDP            |
| IP地址配置     | DHCP（动态主机配置协议） | UDP            |
| 网络管理       | SNMP（简单网络管理协议） | UDP            |
| 远程文件服务器 | NFS（网络文件系统）      | UDP            |
| IP电话         | 专用协议                 | UDP            |
| 流式多媒体通信 | 专用协议                 | UDP            |
| 多播           | IGMP（网际组管理协议）   | UDP            |
| 电子邮件       | SMTP（简单邮件传送协议） | TCP            |
| 远程终端接入   | TELNET（远程终端协议）   | TCP            |
| 万维网         | HTTP（超文本传送协议）   | TCP            |
| 文件传送       | FTP（文件传送协议）      | TCP            |

### 4.1 UDP

> 　　User Datagram Protocol，用户数据报协议。不需要建立连接和确认，如果想要实现可靠的UDP传输，需要在应用层实现。

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00006.jpg" alt="img" style="zoom: 50%;" />

- **特点：**
  - 无连接的、尽最大努力交付；
  - **面向报文**的，即对应用层传下来的报文，不合并也不拆分直接加上UDP头部，就交给IP层；
    - 因此应用层一定要注意报文长度，避免其加上UDP头部后超过MTU，IP层就不得不对其进行拆分，影响效率；
  - 没有拥塞控制、实时性高，适合IP电话、视频会议等；
  - 支持一对一、一对多、多对一和多对多的交互通信；
  - 首部开销小，只有8字节，其实只是对IP层扩充了一些功能，即复用、分用和差错校验。
    - 但在计算校验和的时候会加上12字节的伪首部，伪首部不会传输，只用来计算检验和。

### 4.2 TCP

> 　　Transmission Control Protocol，传输控制协议。提供可靠的、面向连接的服务，不提供广播或多播服务。

- **特点：**
  - 面向连接，体现在维护连接状态表；
  - 只能一对一；
  - 提供全双工通信，有发送缓冲和接收缓冲；
  - **面向字节流**，TCP协议将应用层传下来的数据看作是无结构的字节流；
    - 即会合并、拆分，由 TCP 来控制传递给 IP 层的数据包大小，应用层协议需要有识别这些字节流的能力；

<br>

　　下面记录如何实现可靠的传输服务。

#### 4.2.1 停止等待协议

> 停止等待就是每发送完一个分组就等待对方的确认，收到确认后再发送下一个分组。

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00022.jpg" alt="停止等待协议" style="zoom: 50%;" />

**发送出现差错：**

- 接收方收到错误的分组或没有收到分组，都不用发送确定分组；
- 发送方超过一段时间没有收到确认就认为刚才发送的分组丢失了，就会重新发送刚才的分组；

<br>

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00018.jpg" alt="img" style="zoom:50%;" />

**确认出现差错：**

- 确认丢失：发送方误以为分组丢失了，于是超时重传，接收方收到重复的分组后丢弃之，并重新发送确认；
- 确认迟到：发送方误以为分组丢失了，于是超时重传，接收方收到重复的分组后丢弃之，并重新发送确认，发送方收到过期的确认什么都不做。

<br>

　　基于上述的可靠传输协议，可以称为ARQ（Automatic Repeat reQuest），自动重传请求。因为重传请求不需要依赖于接收方，完全是自动的。

**信道利用率：**

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00013.jpg" alt="img" style="zoom:50%;" />

<br>

公式：
$$
U=\frac{T_D}{T_D+RTT+T_A}
$$


　　停止等待协议简单但是信道利用率太低，需要使用连续ARQ协议和滑动窗口协议来改善。

#### 4.2.2 连续 ARQ 协议

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00004.jpg" alt="img" style="zoom:50%;" />

**原理：**

- **发送方：**不需要每次都等待接收方的确认，而是维护一个发送窗口，在窗口内的分组都可以直接发送不需要等待确认；

- 接收方：不需要对每个接收到的分组都进行确认，而是采用**累计确认**的方式，对**按序到达的最后一个分组**进行确认；

- **收到确认后：**根据确认分组号可以把发送窗口向前推进；
- **缺点：**发送方不能知道接收方已接受的所有分组的情况，存在**回退N问题**。如接收方接收到了分组1、2、5、6、7，只能发送确认分组2已被正确收到的消息，发送方不知道接收方正确收到了分组5、6、7，只能重新发送。

<br>

#### 4.2.3 滑动窗口协议

- 滑动窗口的**序号以字节为单位**，占32位，循环使用。

  - 一般情况下（慢速），不会出现重复序号，若发送速率极快，则需要借助时间戳来防止序号绕回。

- TCP 规定累计确认时间不得超过 0.5s；

- **超时重传时间RTO**的选择：

  - 使用**报文段往返时间RTT**的加权平均，公式：

  $$
  新的RTT_S=\left ( 1- α\right )*(旧的RTT_S)+α*新的RTT样本
  $$

  ​			其中s表示smoothed，平滑的，α建议取值1/8。

  - 超时重传时间，应该略大于RTT，于是建议加上RTT<sub>D</sub>表示RTT的**偏差的加权平均**：
    $$
    RTO=RTT_s + 4 * RTT_D
    $$

    $$
    新的RTT_D=(1-β)*(旧的RTT_D)+β*\left | RTT_S-新的RTT样本 \right |
    $$

    ​	第一次测量时，RTT<sub>D</sub>取RTT的一半，β小于1，建议取值1/4；

  - 一种情况：若发生了超时重传，同时发送方收到了对旧报文的确认，则发送方可能会将这个确认当做是超时重传的报文的确认，这时候RTO就会越来越小，导致不停地重传。

    - 因此若发生重传则不能使用上述算法，而是每次发生重传都将 RTO<sub>new </sub>= 2 * RTO<sub>old</sub>；

### 4.3 TCP 首部格式

> TCP 的功能就体现在首部字段。

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00003.jpg" alt="img" style="zoom: 50%;" />



1. **源端口和目的端口**；
2. **序号**：4 Byte，循环使用，<u>单位是字节</u>，指向本报文要发送的第一个字节序号；
3. **确认号：**4 Byte，指向期望接受的报文的第一个字节序号；
   - 若确认号＝*N* ，则表明：到序号*N* –1为止的所有数据都已正确收到；
4. **数据偏移**：4 bit，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，单位是每4 Byte；
5. **保留**：6 bit；
6. **紧急** URG（URGent）：当URG＝1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送，发送方TCP会把紧急数据插入到本报文段数据的**最前面**，使用紧急指针记录紧急数据的字节数；
7. **确认** ACK（ACKnowledgment）：仅当ACK＝1时确认号字段才有效。当ACK＝0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1；
8. **推送** PSH（PuSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH＝1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付；
9. **复位** RST（ReSeT）：当RST＝1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位；
10. **同步** SYN（SYNchronization）：在连接建立时用来同步序号。当SYN＝1而ACK＝0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN＝1和ACK＝1。因此，SYN置为1就表示这是一个连接请求或连接接受报文；
11. **终止** FIN（FINish）：用来释放一个连接。当FIN＝1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接；
12. **窗口**：2 Byte，指的是发送本报文段的一方的**接收窗口** ，**告诉对方** ：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）；
13. **检验和**：2 Byte，计算检验和时，和UDP一样也要加12 Byte的伪首部；
14. **紧急指针**：2 Byte，仅在URG＝1时才有意义，指出本报文段中的紧急数据的字节数，**即使窗口为零时也可发送紧急数据**；
15. **选项**：长度可变，最长可达40字节，用于扩展功能，如窗口扩大、SACK、时间戳等；
16. **填充**：对齐填充。

### 4.4 流量控制、拥塞控制

#### 4.1.1 流量控制

> 流量控制就是不要让发送方发送太快而淹没接收方，使用TCP 报头的“窗口”字段实现。

- **窗口：**指示了从本报文的确认号开始计算，还能接收多少**字节**的数据，用rwnd表示。
- 存在一个**问题**：当接收方的窗口为0时，发送方会等待接收方发送一个窗口非0的消息，若此消息丢失，则会一直等待下去，为了解决该问题：
  - **持续计时器**，当一方收到0窗口消息时，就启动持续计时器，到时后，发送一个0窗口探测报文，以探测另一方的接收窗口值，若得到的消息仍是0窗口，就重置持续计时器。

</br>

#### 4.4.2 拥塞控制

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00099.jpg" alt="img" style="zoom: 50%;" />

</br>

　　TCP 使用**慢开始** （slow-start）、**拥塞避免** （congestion avoidance）、**快重传** （fast retransmit）和**快恢复**（fast recovery）进行拥塞控制。

 　　起初，处于`慢开始阶段`，拥塞窗口 cwnd=1，窗口的增长速率比较快，当到达慢开始门限时，进入`拥塞避免阶段`，降低窗口的增大速率，改为加法增大，当发生拥塞时，重新回到慢开始阶段。

　　那么**如何判断是否发生了拥塞**？

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00098.jpg" alt="img" style="zoom:50%;" />

　　发送方认为发生了重传即产生了阻塞，但这是不准确的，使用`快重传`方法让发送方尽早知道没有发生阻塞。发送方一连收到三个重复确认，即可以知晓可能并不是阻塞了，遂不执行慢开始，而是执行`快恢复阶段`。

　　引入了阻塞窗口 cwnd 后，应该知道 `发送窗口 = Min（rwnd，cwnd）`。

### 4.5 三次握手、四次挥手

#### 4.5.1 三报文握手

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00094.jpg" alt="img" style="zoom:50%;" />

**步骤：**

　　第一步：A 发送 `SYN = 1`序号为`x`的**连接请求报文**，TCP规定，连接请求报文不能携带数据，但要**消耗掉一个序号** ；

　　第二步：B 发送`SYN = 1,ACK = 1`的**连接请求确认报文**；

　　第三步：A 对连接请求确认报文再次进行确认，当B收到确认的确认后，连接建立完成。

**问题：**

- 为什么要有第三步对确认的确认？

　　防止已失效的连接请求报文段突然又传送到了B。

>  　　假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。

- 若第三次确认丢失会怎样？

　　第三次确认可能丢失，也可能如上面第一个问题描述的情况，B收到了已经失效的连接请求报文，此时A其实并不想建立连接。

　　回忆 ARQ 的含义，自动重传请求，第三次确认丢失，B 会认为是第二步的连接请求报文丢失而超时重传，这时 A 就可以重新发送第三次确认。如果B重传一定次数后仍未收到第三步的确认，则会自动关闭链接。

#### 4.5.2 四报文挥手

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00093.jpg" alt="img" style="zoom:50%;" />

**步骤：**

　　第一步：一方发出`FIN = 1`的**链接释放请求报文**，A 不再发送数据；

　　第二步：发送正常确认，确认**我收到了你的链接释放请求报文**，此时B也许还会有数据发送；

　　第三步：若 B 也没有数据发送时，则发送`FIN = 1,ACK = 1`的**连接释放请求确认报文**；

　　第四步：A 再发送**确认的确认**，若 B 收到后即可释放连接，但此时 A 还要等待**2MSL**；

**问题：**

- 为什么是 2MSL？

  MSL（Maximum Segment Lifetime），最长报文段寿命。因为要保证A发送的ACK能被B正确收到，若收不到B就会重传FIN。

    　　去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)就是2MSL。

- 为什么需要 2MSL？

  1. 保证第四步 A 发送的`确认的确认`能够到达 B ，因为若确认的确认丢失，B 会认为`确认`丢失，而重传`确认`，这时 A 就可以重传`确认的确认`，同时会重新设置 2MSL 计时器；
  2. 保证本链接持续时间内所产生的所有报文段都从网络中消失，以此防止旧链接中的报文和新链接中的报文混淆。

----

## 5. 应用层

### 5.1 DNS

> Domain Name System，域名系统。

- 两种查询方式：迭代查询、递归查询

![DNS 查询方式](https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20201107112407705.png)

### 5.2 DHCP

> 　　Dynamic Host Configuration Protocal，动态主机配置协议。允许一台新加入网络的计算机自动获取相应的网络配置信息。配置项包括：IP、子网掩码、默认路由的IP、域名服务器的IP。默认路由IP，对我们使用PC机来说可以理解为就是网关。

**过程：**

　　DHCP使用客户服务器方式（使用UDP协议）。需要IP地址的主机在启动时就向DHCP服务器广播发送**发现报文** （DHCPDISCOVER）（将目的IP地址置为全1，即255.255.255.255），这时该主机就成为DHCP客户。发送广播报文是因为现在还不知道DHCP服务器在什么地方，因此要发现（DISCOVER）DHCP服务器的IP地址。这台主机目前还没有自己的IP地址，因此它将IP数据报的源IP地址设为全0。这样，在本地网络上的所有主机都能够收到这个广播报文，但只有DHCP服务器才对此广播报文进行回答。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP地址池（address pool）中取一个地址分配给该计算机。DHCP服务器的回答报文叫做**提供报文** （DHCPOFFER），表示“提供”了IP地址等配置信息。

### 5.3 HTTP

>基于 TCP 协议。

1xx表示通知信息，如请求收到了或正在进行处理。

2xx表示成功，如接受或知道了。

3xx表示重定向，如要完成请求还必须采取进一步的行动。

4xx表示客户的差错，如请求中有错误的语法或不能完成。

5xx表示服务器的差错，如服务器失效无法完成请求。

#### 5.3.1 HTTP 版本主要区别

[参考自这里](https://segmentfault.com/a/1190000016656529)

<img src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00195.jpg" alt="img" style="zoom:50%;" />

- **HTTP 1.0**（1996）
  - 请求一个万维网文档所需的时间是**该文档的传输时间**（与文档大小成正比）**加上两倍往返时间RTT**（一个RTT用于连接TCP连接，另一个RTT用于请求和接收万维网文档。TCP建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文）。
  - 缺点：HTTP 1.0 每次请求都要加上两倍的 RTT 开销，因为每个TCP连接上只能发送一次请求。

- **HTTP 1.1**（1999）

  - 增加了一些头和响应码，如用于记录域名的 HOST 头；
  - 长连接，允许在一条 TCP 连接上，传送多次 HTTP 请求，分类；
    - 非流水线方式：客户端收到前一个响应后才可以发送下一个请求；
    - 流水线方式：有一个请求队列，不需要等待上一个响应，提高了性能，但仍存在队列头阻塞的问题。

- **HTTP 2.0**（2015）

  - **二进制传输**（核心）：在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。

  - **多路复用：**有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。
  - **Header压缩：**一方面体现在使用了压缩算法，另一方面现在两端维护了一个索引表，记录曾出现过的Header键名，对端收到后可以通过键找到相应的值。

**文本文件 VS 二进制文件？**

　　读文件分为两个转化过程：**磁盘 --> 文件缓冲区 --> 应用程序内存空间**。从第一个过程来看，两种文件没有本质区别，都是读二进制的 0 和 1。

　　一个文件包含两部分信息：**控制信息+内容信息**。控制信息即文件的头部，告诉软件怎么打开该文件。可以理解为：文本文件是一种特殊的二进制文件，区别在于不同应用程序对其的解释方式。

　　那么二进制为什么效率高，举例，如文本文件使用ASCII编码表示65535需要5 Byte，二进制只需要使用 2Byte。

#### 5.3.2 HTTPS

> - 端口 443。
>
> - 使用**对称加密和非对称加密结合**的方式。
>   - 因为对称加密效率高，但对称加密的密钥协商是个问题，故使用非对称加密来加密对称加密的密钥。

**工作原理：**

　　HTTP 协议是明文传输，不安全主要体现在容易被**截取破解**、**篡改伪造**。下面就看HTTPS是怎么解决这两个问题的。

- 考虑如果只使用对称加密的方式，第一步肯定是客户端和服务器以<u>明文方式协商对称密钥</u>，但这时候密钥也有可能被中间者获取。

  **如何防止中间者获取密钥？**

- 这时候就需要非对称加密，浏览器随机生成对称密钥，并使用服务器提供的公钥进行加密后再传输，服务器收到后使用私钥解密即可获得对称密钥，而中间者因为没有私钥而难以破解信息。但公钥可能会被中间者伪造。

  **客户端要如何安全的知道公钥？**

- 因为我们不可能保存所有网站的公钥，所以需要引入一个受信任的第三方机构，**CA 机构**。网站向CA机构申请安全证书，证书内容包括网站公钥、域名、有效时间等信息，CA机构使用自己的私钥对证书进行加密后颁发给网站。每当浏览器请求HTTPS网站时，服务器会首先返回这个安全证书，客户端使用CA机构的公钥解密证书，无法解密成功则说明这个加密证书有可能被篡改了。

  - 受信任的CA机构的公钥不会很多，一般会预置在系统中。

  - 证书不会被篡改，因为首先即使中间者获得了证书信息，篡改了其中的条目，但没有CA机构的私钥就无法再次加密；其次，即使中间者是用自己向CA机构申请的真实证书来替换原服务器的证书发送给客户端，客户端也会根据证书中的其他信息来判断证书是否安全，如根据域名判断。

#### 5.3.3 url+回车

　　传输层是面向通信部分的最高层，是面向用户功能的最底层。

- 从面向用户功能来看：
  - URL -- DNS解析 -- 生成HTTP报文 -- 建立TCP链接 -- 发送请求 -- 服务器处理请求 -- 返回数据 -- 浏览器解析渲染 -- 释放TCP链接
- 从面向通信来看：
  - 应用层：DNS解析、生成HTTP报文
  - 传输层：建立TCP链接
  - 网络层：RIP或OSPF、BGP、IP协议、ARP获取MAC地址
  - 数据链路层：发送数据

