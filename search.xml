<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM 方法调用与多态</title>
      <link href="JVM/JVM%E4%B8%8E%E5%A4%9A%E6%80%81.html"/>
      <url>JVM/JVM%E4%B8%8E%E5%A4%9A%E6%80%81.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　了解字节码文件结构、运行时栈帧结构、JVM 怎么匹配多态方法。</p></blockquote><p>　　简记一下字节码文件的结构的知识，为后面铺垫：</p><ul><li><p><strong>数据类型</strong></p><ol><li><code>无符号数</code>：用来描述数字、引用、数量值或以UTF-8编码的字符串。</li><li><code>表</code>：由多个无符号数或其他表组成的复合数据类型。</li></ol><p>　　Class 文件严格按照大端存储，且任何编码的 .java 源文件，编译时字符串都会转化为 utf-8 编码，但加载到 JVM 内部时，使用utf-16 编码。<a href="https://www.zhihu.com/question/30977092">参考</a></p></li></ul><blockquote><p>下面开始文件包含的信息：</p></blockquote><ul><li><p><strong>控制信息</strong>：魔数、版本号等。</p></li><li><p><strong>常量池</strong>：包括字面量和符号引用。作用主要是供 Class 文件中的其他结构所引用，字段表、方法表、属性表大量引用常量。</p><ul><li>字面量：文本字符串、final常量值。</li><li>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符……</li></ul></li><li><p><strong>访问标志</strong>：常量池紧接着 2 Byte，用于描述类或接口的访问信息，如是否 public、final、abstract、注解、枚举……</p></li><li><p><strong>类索引、父类索引、接口集合</strong>：用于确定类或接口的继承关系。</p></li><li><p><strong>字段表集合</strong>：描述类或接口中声明的字段，包括类变量和实例变量，不包括方法内部声明的局部变量。除了字段的修饰符，如public、static等是固定的，其他像是字段的名称、数据类型等信息都是无法固定的，所以引用自常量池中的常量。</p><ul><li>字段表可能会携带属性表集合，如记录类常量的初值，放在属性表集合的 ConstantValue 字段中。</li><li>Class文件中修饰符不同，名称相同也可以，但源码中不可。</li></ul></li><li><p><strong>方法表集合</strong>：用于记录类或接口中的方法信息。同字段表一样，包含访问标志、引用自常量池的名称索引、描述符索引、<u>属性表集合</u>等。</p><ul><li>方法中的代码经编译后形成字节码指令，存放在属性表集合中一个名为 Code 的属性中。</li></ul></li><li><p><strong>属性表集合</strong>：用于记录一些其他附加的专有信息，供Class文件、字段表、方法表使用。他有很多字段属性，如前面提到的 ConstantValue 、Code 属性。</p></li></ul><br><p>　　Class文件中的常量池也称为静态常量池，类加载时会装入运行时常量池（在方法区/堆中）；常量池后面的几个部分，组成了类结构信息，加载进方法区/元空间中。</p><hr><a id="more"></a><h3 id="1-栈帧"><a href="#1-栈帧" class="headerlink" title="1. 栈帧"></a>1. 栈帧</h3><p>　　栈帧是虚拟机栈中的元素，一个方法的调用和返回对应一个栈帧的入栈和出栈。每个栈帧中包括：局部变量表、操作数栈、动态链接、方法返回地址、附加信息。其中局部变量表和操作数栈的大小编译时即可确定。</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200928001033555.png" alt="栈帧" style="zoom: 67%;" /><h4 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a><strong>1.1 局部变量表</strong></h4><p>　　<code>局部变量表</code>是一组变量值的存储空间，存放<strong>方法参数</strong>和<strong>局部变量</strong>。编译时即可确定局部变量表的大小，单位<strong>是变量槽</strong>，变量槽的大小取决于具体的虚拟机实现。</p><ul><li><p><strong>变量槽的复用可以影响垃圾回收。</strong></p><p>　　当 PC 指针已经超出方法内某个变量的作用域时，即这个变量不会再被使用了，这时该变量所占用的变量槽就可以被复用。原先变量槽内可能是一个引用，被复用后，就会断裂，从而可以让 GC 早点回收，这也是为什么建议将方法内不用的大对象手工置 null 的原因。</p></li><li><p><strong>为什么局部变量必须初始化。</strong></p><p>　　因为局部变量不像类变量那样在类加载的准备阶段赋 ‘0’ 值，没人知道那块内存曾经放的是什么，所以局部变量必须初始化。</p></li></ul><br><h4 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a><strong>1.2 操作数栈</strong></h4><p>　　<code>操作数栈</code>可以存放任意的 Java 数据类型，编译时即可确定大小，作用是传递参数。</p><br><h4 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a><strong>1.3 动态连接</strong></h4><p>　　静态常量池中一部分符号引用在类加载的解析阶段，会被直接解析转换为<strong>直接引用</strong>，即<strong>静态解析</strong>。而还有一部分只能在运行期间转化为直接引用，即<strong>动态连接</strong>。</p><p>　　在字节码文件中，方法的调用体现在调用指令的参数就是静态常量池中的符号引用。转化为直接引用就是指转化为实际的运行时可知的某一个方法的入口地址。</p><p>　　静态解析就是编译时就能确定调用哪一个方法，从而在解析阶段可以直接把符号引用转化为直接引用。（非虚方法+重载）</p><p>　　动态连接就是只有运行时才能确定调用哪一个方法，故而不能在解析阶段直接转化为直接引用。（重写）</p><p>　　而栈帧中的动态连接字段，存放的是一个指向运行时常量池中当前方法的引用，为动态连接功能服务。</p><br><h4 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a><strong>1.4 方法返回地址</strong></h4><p>　　返回地址就是方法正常返回时要执行的下一条字节码指令地址。方法返回的过程如下：</p><p>　　方法返回就是当前栈帧出栈，需要恢复调用者的局部变量表和操作数栈，如果有返回值，需要把返回值压入调用者的操作数栈，然后调整PC的值为返回地址。</p><p>　　如果发生异常，则转去执行异常处理程序，即给PC赋相应的异常处理程序的入口地址，若没有找到相应的异常处理程序，则方法会直接退出，不返回给调用者任何返回值信息。</p><br><hr><h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><ul><li><strong>方法分类</strong></li></ul><p>　　Java 方法可以分为两种：<strong>非虚方法</strong>、<strong>虚方法</strong>。非虚方法包括：静态方法、私有方法、实例构造器、父类方法、final方法。类加载的解析阶段就会把符号引用转化为直接引用。除此之外，其他方法都是虚方法。</p><p>　　其实判断依据很简单，可重写的方法就是虚方法，就得运行时动态绑定，即找到匹配的方法，得到它的直接引用。</p><p>　　不同方法的调用使用不同的字节码指令：</p><table><thead><tr><th>字节码指令</th><th>说明</th></tr></thead><tbody><tr><td>invokestatic</td><td>调用静态方法</td></tr><tr><td>invokespecial</td><td>调用实例构造器方法、私有方法和父类中的方法</td></tr><tr><td>invokevirtual</td><td>调用所有的虚方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokedynamic</td><td>运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</td></tr></tbody></table><br><ul><li><strong>变量的类型</strong></li></ul><p>　　<code>静态类型</code>：创建对象时声明的类型，也叫外观类型，编译期可知，不可变。</p><p>　　<code>实际类型</code>：实际创建的类型，也叫运行时类型，编译期不可知，可变。</p><br><ul><li><strong>方法调用</strong></li></ul><p>　　非虚方法编译期即可确定，解析阶段即可找到方法的入口地址（直接引用），所以非虚方法的调用是直接执行即可。</p><p>　　虚方法的调用，说直白点就是重写方法怎么选，如<code>invokevirtual</code>字节码指令逻辑如下：</p><p>　　方法调用之前，会把调用者（引用）入栈。</p><ol><li><p>根据栈顶引用找到方法的调用者，确定它的实际类型；</p><p>  　　2. 判断有没有与invokevirtual的参数所指向的常量池中的常量（方法名）匹配的方法，即判断有没有重写；</p><pre><code>  　　3. 若找到则返回这个方法的引用，即运行时确定了直接引用；        　　4. 否则，按照继承关系，逐层向上寻找；</code></pre></li></ol><p>　　即多态的本质就是，运行时根据调用者（接收者）的实际类型去选择合适的方法，返回其直接引用。达到不同的对象调用相同的方法，可以执行不同的逻辑的目的。实现在于相应字节码指令的执行逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型与锁优化</title>
      <link href="JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html"/>
      <url>JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><ul><li><p>从 JVM 的内存模型了解 Java 中的线程、线程安全、锁优化；</p></li><li><p>从 volatile 关键字了解原子性、可见性、有序性；</p></li></ul><p>参考：《深入理解 JVM 虚拟机》</p></blockquote><a id="more"></a><h3 id="1-JVM-内存模型"><a href="#1-JVM-内存模型" class="headerlink" title="1. JVM 内存模型"></a>1. JVM 内存模型</h3><p><strong>定义：</strong></p><ul><li><code>内存模型</code>：是操作内存的过程的抽象，可以理解为内存模型定义了内存读写的规则。</li><li><code>JMM</code>：Java Memory Mode，Java 内存模型，用于屏蔽各种硬件、操作系统的内存访问差异。</li></ul><h4 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1 主内存与工作内存"></a>1.1 主内存与工作内存</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200917143254671.png" alt="image-20200917143254671" style="zoom: 67%;" /><p><strong>说明：</strong></p><ul><li>所有变量都存在主内存中；<ul><li>不包括线程私有的，如局部变量、方法参数、对象引用。</li></ul></li><li>每个线程有自己的工作内存，保存了被该线程所使用到的主内存数据的副本；</li><li>线程对数据的操作都在工作内存中完成，不能直接在主内存中读写；</li><li>不同线程之间传递数据需要通过主内存来完成。</li></ul><h4 id="1-2-内存操作原语"><a href="#1-2-内存操作原语" class="headerlink" title="1.2 内存操作原语"></a>1.2 内存操作原语</h4><p>　　<strong>JMM 定义了 8 种内存操作原语：</strong></p><ul><li><p><code>lock（锁定）</code>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p></li><li><p><code>unlock（解锁）</code>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p></li><li><p><code>read（读取）</code>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p></li><li><p><code>load（载入）</code>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p><code>use（使用）</code>：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p></li><li><p><code>assign（赋值）</code>：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p></li><li><p><code>store（存储）</code>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</p></li><li><p><code>write（写入）</code>：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p></li></ul><br><p>　　除了操作原语，还有一些内存操作规则用来保证数据的一致性，它们共同构成了 JVM 内存模型。如：一个变量未被 lock 之前，不允许对其执行 unlock；执行 unlock 之前必须先把变量同步回主内存……了解即可。</p><hr><h3 id="2-原子性、可见性、有序性"><a href="#2-原子性、可见性、有序性" class="headerlink" title="2. 原子性、可见性、有序性"></a>2. 原子性、可见性、有序性</h3><p>　　<strong>Volatile：</strong> 可以保证可见性、有序性，但不保证原子性。即使用 Volatile 声明一个变量，可以保证这个变量的改变能立即被其它线程“听”到，且能够防止指令重排序。</p><h4 id="2-1-可见性"><a href="#2-1-可见性" class="headerlink" title="2.1 可见性"></a>2.1 可见性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>；</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><ul><li><p>假设执行顺序为 A -&gt; B，那么 j 一定等于 i 吗？</p><ul><li>不一定，因为有可能线程A的操作还没有同步回主内存。</li></ul></li><li><p>当使用 Volatile 修饰变量时，JVM 会保证当变量在一个线程内被修改时，能及时同步回主内存，当其他线程访问该变量时，不会访问工作内存，而是每次都去主内存取。</p><ul><li>即声明为 Volatile 的话，工作内存中的拷贝就失效了，无法起到缓存作用。</li></ul></li></ul><h4 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h4><p><strong>证明：</strong>Volatile 不能保证原子性，i++ 不是原子操作。</p><p>注：使用<code>AtomicTest</code>原子类，可以保证 i++ 操作的原子性，底层使用了CAS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20 个线程，每个使 race++ 10000 次</span></span><br><span class="line"><span class="comment">// 结果不为 200000 证明 Volatile 不能保证原子性，i++操作不是原子操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-非原子性协定"><a href="#2-2-1-非原子性协定" class="headerlink" title="2.2.1 非原子性协定"></a>2.2.1 非原子性协定</h5><p>　　可以认为基本数据类型的读写都是原子性的，但 long、double有例外。</p><p>　　JMM允许虚拟机将<strong>没有被volatile修饰</strong>的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性。</p><p>　　即有可能会读到半个变量，根据研究很少会出现这个情况。</p><h5 id="2-2-2-synchronized"><a href="#2-2-2-synchronized" class="headerlink" title="2.2.2 synchronized"></a>2.2.2 synchronized</h5><p>　　synchronized 使用了<strong>管程</strong>的方法实现同步，字节码指令 <code>monitorenter</code>、<code>monitorexit</code> 底层使用0了 lock 、unlock 两条内存操作原语。</p><p>　　JVM 对 synchronized 进行了大量的优化，后面锁优化部分记录。</p><h4 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h4><h5 id="2-3-1-指令重排序"><a href="#2-3-1-指令重排序" class="headerlink" title="2.3.1 指令重排序"></a>2.3.1 指令重排序</h5><p>　　CPU 为了使用流水线提升性能，会预读指令、进行重排序。将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。JVM 也一样，会对字节码指令进行重排序。这就造成指令的执行顺序可能和我们代码的书写顺序不太一样。当然 JVM 不会胡乱排序：</p><ul><li>它会保证普通变量在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果。<ul><li>即保证重排序后本线程看到的还是一样的结果。</li></ul></li><li><strong>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>。<ul><li>对其他依赖该线程某变量的线程，影响很大。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟两个线程，一个初始化配置资源，一个使用配置资源</span></span><br><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>　　如果没有将变量 <code>initialized</code> 声明为 volatile ，由于存在指令重排序，<code>initialized = true</code>这一条赋值语句有可能被提前执行，但此时配置资源还没有初始化完毕，就会导致线程B在使用配置资源的时候出错。</p><p>　　volatile 的原理是设置了一道内存屏障，<strong>保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</strong></p><h5 id="2-3-2-先行发生原则"><a href="#2-3-2-先行发生原则" class="headerlink" title="2.3.2 先行发生原则"></a>2.3.2 先行发生原则</h5><blockquote><p>　　操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p></blockquote><p>　　Java 中无需任何同步手段就能保障的天然的先行发生规则：</p><ul><li><code>程序次序规则</code>（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li><code>管程锁定规则</code>（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li><li><code>volatile变量规则</code>（V olatile V ariable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li><li><code>线程启动规则</code>（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li><code>线程终止规则</code>（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li><li><code>线程中断规则</code>（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</li><li><code>对象终结规则</code>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li><code>传递性</code>（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><hr><h3 id="3-Java-中的线程"><a href="#3-Java-中的线程" class="headerlink" title="3. Java 中的线程"></a>3. Java 中的线程</h3><blockquote><p>Java 中的线程是映射到 OS 上的 1:1 的内核级线程。</p></blockquote><h4 id="3-1-线程的6种状态"><a href="#3-1-线程的6种状态" class="headerlink" title="3.1 线程的6种状态"></a>3.1 线程的6种状态</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200917162743845.png" alt="image-20200917162743845"></p><ul><li><code>新建</code>：创建了但尚未启动的线程。</li><li><code>运行</code>：包括<strong>正在运行</strong>和就绪两种状态，即正在参与cpu时间片分配的线程。</li><li><code>限期等待</code>：不会被分配时间片，无需被其他线程唤醒，一定时间后由系统唤醒。</li><li><code>无限期等待</code>：不会被分配时间片，需要被其它线程显式唤醒。</li><li><code>阻塞</code>：进入阻塞队列，不分配时间片，等待锁被释放。</li><li><code>终止</code>：执行结束。</li></ul><p><strong>注意：</strong>可运行不代表可以立即运行，而是等待分配时间片。</p><hr><h3 id="4-锁升级"><a href="#4-锁升级" class="headerlink" title="4. 锁升级"></a>4. 锁升级</h3><p><strong>原因：</strong>为了优化 synchronized </p><p><strong>过程：</strong>自旋 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt;重量级锁</p><p><strong>总结：</strong></p><ul><li><p>持锁时间很短：自旋，不放弃处理器时间，一直请求锁直到一定次数后再阻塞。</p></li><li><p><strong>只有一个线程进入临界区</strong>：偏向锁，使重入时不需要再申请锁。</p></li><li><p><strong>多个线程交替进入临界区</strong>：轻量级锁，通过 CAS 避免使用互斥量。</p></li><li><p><strong>多个线程同时进入临界区</strong>：重量级锁，即使用OS的互斥量。</p></li></ul><hr><br><ul><li>32 位 VM 对象头 Mark Word 部分，64 位差异不大，因为 64 位的话，指针的位数也变大了。</li><li>为什么指针后面还可以加俩标志位？<ul><li>因为对象是8字节对齐，后面三位都可以当做其他用处使用。</li></ul></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200917171459222.png" alt="image-20200917171459222"></p><h4 id="4-1-偏向锁"><a href="#4-1-偏向锁" class="headerlink" title="4.1 偏向锁"></a>4.1 偏向锁</h4><p><strong>目的：</strong>消除数据在无竞争情况下的同步原语，即重入时不需要再申请锁。</p><p><strong>含义：</strong>偏心于第一个获得锁的线程。</p><p><strong>过程：</strong></p><p>　　当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。</p><p>　　成功后，下次持有偏向锁的线程再次进入同步块的时候，JVM 不会在进行任何同步操作。当有其它线程申请锁的时候，会立即退出偏向模式，升级为轻量级锁。</p><p><strong>注意：</strong></p><p>　　线程ID记录到了原本hashcode的部分，故调用了 object::hashcode() 方法的对象，无法使用偏向锁。或使用了偏向锁后要使用object::hashcode() 方法时，会立即退出偏向锁模式。</p><p>　　而轻量级锁虽然也会改变头信息，但是他们会保存原来头的副本，释放锁的时候进行还原。</p><h4 id="4-2-轻量级锁"><a href="#4-2-轻量级锁" class="headerlink" title="4.2 轻量级锁"></a>4.2 轻量级锁</h4><p><strong>目的：</strong>通过CAS避免使用操作系统提供的互斥量，即重量级锁。</p><p><strong>申请过程：</strong></p><ul><li>某线程即将进入同步块时，判断锁对象标志，如果没有被锁，则首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于备份当前锁对象的Mark Word，称为Displaced Mark Word。</li><li>然后使用 CAS 操作尝试将锁对象的Mark Word中相应字段更新为指向Lock Record的指针，<ul><li>成功：表示当前线程获得了锁；</li><li>失败：表示有其他线程在竞争锁，这时检查锁对象的Mark Word中指针是否指向当前线程的Lock Record，<ul><li>指向，说明获得了锁；</li><li>没有指向，说明被别的线程抢了，这时意味着有<strong>多个线程同时</strong>进入临界区，即轻量级锁应当升级为重量级锁。需要改变锁对象的标志位，并且保存相应的锁对象头信息，便于最后复原，同时后面来的线程都会阻塞。</li></ul></li></ul></li></ul><p><strong>释放过程：</strong></p><ul><li>通过 CAS 尝试把 Displaced Mark Word 赋值给 Mark Word，<ul><li>成功：则释放轻量级锁成功；</li><li>失败：说明锁已近升级为了重量级锁，释放锁的同时，需要唤醒阻塞在该锁上的其他线程。</li></ul></li></ul><h4 id="4-3-其他优化"><a href="#4-3-其他优化" class="headerlink" title="4.3 其他优化"></a>4.3 其他优化</h4><ul><li><strong>锁消除：</strong><ul><li>借助于逃逸分析的支持，当判断堆上的所有数据都不会发生线程逃逸，那就可以把他们当做线程私有的数据来对待，无需使用锁。</li></ul></li><li><strong>锁粗化：</strong><ul><li>当一系列操作都是一个线程在对一个锁对象进行反复加锁、释放锁的过程时，可以把锁扩展到这一系列操作的外部。如StringBuffer的一系列连续append()。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网小结</title>
      <link href="Networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html"/>
      <url>Networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><ul><li><p><strong>OSI模型</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li>着重于计算机网络问题的讨论。</li></ul></li><li><p><strong>TCP/IP模型</strong>：链路层、互联网层、传输层、应用层。</p><ul><li><p>着重于讨论协议。</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200905201340736.png" alt="image-20200905201340736" style="zoom: 80%;" /></li></ul></li><li><p>一般学习按照下面五层展开讨论：</p><ul><li><strong>物理层</strong>：关注比特作为信号如何传输的问题，如电气特性、物理接口等。</li><li><strong>数据链路层</strong>：关注两台相邻的机器之间如何<u>可靠的传递信息块</u>，包括封装成帧、检验纠错、控制速率。<ul><li>MAC帧的信息部分，即 IP 数据报，长度不超过 1500 字节。</li><li>传输速率：电路中 2/3 c、光纤中 9/10 c</li></ul></li><li><strong>网络层</strong>：关注数据包如何在路由器之间转发，为上层提供<u>可靠的数据包交付</u>服务。</li><li><strong>传输层</strong>：在两台计算机的进程之间传递数据。</li><li><strong>应用层</strong>：为了使用下层提供的网络传输服务，为某一类问题定义精确地通信规则（协议）。</li></ul></li></ul><a id="more"></a><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h2><blockquote><p>　　向上层提供尽最大努力的数据报交付服务，即可靠交付应该由上层（传输层）来保证，IP层甚至不对数据部分进行校验，这也使得现在普通路由设备更加简单、便宜，促进了互联网的发展。</p></blockquote><h3 id="3-1-虚电路服务-VS-数据报服务"><a href="#3-1-虚电路服务-VS-数据报服务" class="headerlink" title="3.1 虚电路服务 VS 数据报服务"></a>3.1 虚电路服务 VS 数据报服务</h3><ul><li>虚电路：模拟打电话所使用的面向连接的通信方式，当两台计算机要进行通信时，先建立一条虚拟的连接，<u>预留</u>出双方通信所需要的<u>一切网络资源</u>。</li></ul><table><thead><tr><th align="left"><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td align="left">思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td align="left">连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td align="left">终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td align="left">分组的转发</td><td>属于同一条虚电路的分组<strong>均按照同一路由进行转发</strong></td><td>每个分组<strong>独立选择路由进行转发</strong></td></tr><tr><td align="left">当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td align="left">分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的时间不一定按发送顺序</td></tr><tr><td align="left">端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h3 id="3-2-IP协议"><a href="#3-2-IP协议" class="headerlink" title="3.2 IP协议"></a>3.2 IP协议</h3><p>　　在网络层与IP协议配套使用的还有几个协议：</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00258.jpg" alt="img" style="zoom:50%;" /><ol><li><strong>ARP</strong>，Address resolution Protocol，地址解析协议，用于获取同一个网络内其他主机的MAC地址；</li><li><strong>ICMP</strong>，Internet Control Message Protocol，网际控制报文协议；</li><li><strong>IGMP</strong>，Internet Group Message Protocol，网际组管理协议。</li></ol><h4 id="3-2-1-IP地址"><a href="#3-2-1-IP地址" class="headerlink" title="3.2.1 IP地址"></a>3.2.1 IP地址</h4><blockquote><p>IP 地址的编址方法经历了三个阶段：分类的 IP 地址、子网的划分、构造超网。</p></blockquote><h5 id="1-分类的-IP-地址"><a href="#1-分类的-IP-地址" class="headerlink" title="1. 分类的 IP 地址"></a>1. 分类的 IP 地址</h5><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00131.jpg" alt="img" style="zoom: 50%;" /><p>　　常用的三类IP地址：</p><table><thead><tr><th>网络类别</th><th>网络号</th><th>主机号</th><th>备注</th></tr></thead><tbody><tr><td>A类  0…</td><td>全0是保留地址<br />全1，即127… 是环回地址</td><td>全0表示本主机所连接的网络<br />全1表示该网络上的所有主机</td><td>50%</td></tr><tr><td>B类  128…</td><td>不会出现全0或全1的情况<br />但是128.0.0.0规定不能指派</td><td>同上</td><td>25%</td></tr><tr><td>C类  192…</td><td>同上，192.0.0.0不能指派</td><td>同上</td><td>12.5%</td></tr></tbody></table><hr><h5 id="2-子网的划分"><a href="#2-子网的划分" class="headerlink" title="2. 子网的划分"></a>2. 子网的划分</h5><blockquote><p>　　两级IP不够灵活，还造成了IP地址的浪费，所以使用子网掩码将两级IP划分为三级IP。</p></blockquote><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00137.jpg" alt="img" style="zoom:50%;" /><br><p><strong>使用子网时的分组转发：</strong></p><ol><li>先判断是否为直接交付，即使用IP地址和与路由器直接相连的网络的子网掩码相与；</li><li>看是否有特定路由；</li><li>查路由表的每一行，按顺序与其中的子网掩码相与，看是否等于对应的网络号；</li><li>是否有默认路由；</li><li>ICMP报告分转发出错。</li></ol><p><strong>注意：</strong></p><ul><li>子网掩码没有硬性规定一定要是连续的 1，但建议这样做。</li><li>同样的IP和不同的子网掩码相与，可能得到相同的网络地址。</li></ul><hr><h5 id="3-构造超网"><a href="#3-构造超网" class="headerlink" title="3. 构造超网"></a>3. 构造超网</h5><blockquote><p>为缓解IP地址的消耗，使用<strong>无分类域间路由选择</strong> CIDR，是一种<strong>无分类编址</strong>方法。</p><p>定义为： IP地址 ::= {&lt;网络前缀&gt;，&lt;主机号&gt;}</p></blockquote><h4 id="3-2-2-ARP协议"><a href="#3-2-2-ARP协议" class="headerlink" title="3.2.2 ARP协议"></a>3.2.2 ARP协议</h4><blockquote><p>　　ARP，Address Resolution Protocol，地址解析协议，用于获取本网络上其他主机的MAC地址。</p><p>　　还有RARP协议，逆地址解析，从MAC地址得到IP地址，但后来的DHCP已经包含了这个功能，所以RARP已经不用了。</p></blockquote><p>　　<strong>解析过程：</strong></p><p>　　当主机A要向<strong>本局域网</strong>上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。</p><p>　　也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址：</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00231.jpg" alt="img" style="zoom: 50%;" /><h4 id="3-2-3-IP数据报"><a href="#3-2-3-IP数据报" class="headerlink" title="3.2.3 IP数据报"></a>3.2.3 IP数据报</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00240.jpg" alt="img" style="zoom:50%;" /><p><strong>注意：</strong></p><ul><li><p><strong>生存时间</strong>：TTL（Time To Live），现指IP数据报经过路由器的<strong>跳数限制</strong>，8位，最大值255。</p></li><li><p><strong>协议：</strong>指出此数据报携带的数据使用的是何种协议（运输层传来的），以便于IP层知道将数据交给上层的哪个协议处理。</p><ul><li>由此，可以知道不同协议可以使用相同端口号。</li></ul></li><li><p><strong>首部校验和：</strong>注意IP层只对IP数据报的首部进行差错检验，可靠的信息传输用由运输层保证，由运输层检验数据。</p></li><li><p>IP数据报的长度不能超过数据链路层规定的<strong>最大传送单元</strong> MTU（Maximum Transfer Unit）的值，1500 字节。</p></li></ul><h4 id="3-2-4-ICMP协议"><a href="#3-2-4-ICMP协议" class="headerlink" title="3.2.4 ICMP协议"></a>3.2.4 ICMP协议</h4><blockquote><p>ICMP（Internet Control Message Protocol），网际控制报文协议</p></blockquote><ul><li>分类：<ul><li>ICMP差错报告报文<ul><li>终点不可达</li><li>时间超过：TTL为0</li><li>参数问题</li><li>重定向</li></ul></li><li>ICMP询问报文</li></ul></li><li>应用举例：<ul><li>PING（Packet InterNet Groper），分组网间探测。<ul><li>是应用层直接使用网络层的一个应用，没有经过运输层。</li></ul></li><li>Traceroute，跟踪一个分组从源点到终点的路径，可以基于UDP或ICMP实现。<ul><li>从源主机向目标主机发送一连串的IP数据报，数据是无法交付的UDP用户数据报，TTL依次设置为1,2,3…，以此来获得<strong>ICMP时间超过</strong>差错控制报文，直到收到一条<strong>ICMP终点不可达</strong>报文，从而知道路由轨迹。</li></ul></li></ul></li></ul><h4 id="3-2-5-内部网关协议"><a href="#3-2-5-内部网关协议" class="headerlink" title="3.2.5 内部网关协议"></a>3.2.5 内部网关协议</h4><h5 id="1-RIP"><a href="#1-RIP" class="headerlink" title="1. RIP"></a>1. RIP</h5><blockquote><p>　　Routing Information Protocol，路由信息协议，是一种基于距离向量的路由选择协议，最大的优点是简单，<u>每一个路由器都记录了自己到其他目的网络的距离</u>。</p></blockquote><ul><li><p><strong>约定：</strong>从某一路由器到其直接连接的网络的距离为1,，到非直接相连的网络的距离为经过的路由器数+1。</p></li><li><p><strong>注意：</strong>RIP 协议规定一条路径最多只能包含15个路由器，即最大距离为16，超过16即认为不可达。</p></li><li><p><strong>步骤：</strong></p><p>对<strong>相邻路由器</strong>发送过来的RIP报文：</p><ol><li><p>对地址为 X 的路由器发来的信息 “到目的网络，距离，下一跳”，如“net A，B，C” 意为 我到网络 A 需要经过下一跳路由器 C，距离为 B。</p><p>更改距离为原距离+1，更改下一跳为 X，即“net A，B+1，X”，意为当前路由器要到网络 A，需要经过路由器 X，距离为 B+1，只是记录下来，此时还没有更新到路由表。</p></li><li><p>对记录的信息进行如下判断：</p><ul><li>若原路由表不包含目的网络A的条目，则新增信息到路由表；</li><li>若原路由表包含目的网络N的条目，判断：<ul><li>若下一跳地址是 X，则直接更新路由表为最新信息；</li><li>若下一跳地址不是 X，则比较距离，新距离小于旧距离则更新。</li></ul></li></ul></li><li><p>三分钟没有收到相邻路由器的RIP报文，则标记其举例为16，即不可达。</p></li><li><p>依据：设X是结点A到B的最短路径上的一个结点。若把路径A→B拆成两段路径A→X和X→B，则每一段路径A→X和X→B也都分别是结点A到X和结点X到B的最短路径。</p></li></ol></li><li><p><strong>特点：</strong></p><ul><li>位于应用层，使用 UDP；</li><li>只和相邻的路由器交换信息；<ul><li>定时交换，交换的是本路由器所<u>知道的所有信息</u>，因此网络不能太大；</li></ul></li><li>每个路由器记录的都是能到达的网络的最短举例；</li><li>好消息传播的快，坏消息传播的慢；</li><li>实现简单，开销较小。</li></ul></li></ul><h5 id="2-OSPF"><a href="#2-OSPF" class="headerlink" title="2. OSPF"></a>2. OSPF</h5><blockquote><p>Open shortest Path First，开放最短路径优先。</p></blockquote><ul><li><strong>特点：</strong><ul><li>与当前自治系统内的所有路由器交换信息，成为洪泛法；</li><li>发送的信息是与当前路由器相邻的所有路由器的<strong>链路状态</strong>，包含当前路由器和谁<u>相邻</u>，和到达这些路由器的<u>代价</u>；<ul><li>度量：费用、距离、时延、带宽等；</li></ul></li><li>只有链路状态发生变化时，才会交换信息；</li><li>所有路由器都会维护一个链路状态数据库，是一张全网的拓扑结构图；</li><li>位于网络层，不像RIP使用 UDP，直接使用IP数据报发送数据。</li></ul></li></ul><h4 id="3-2-6-外部网关协议"><a href="#3-2-6-外部网关协议" class="headerlink" title="3.2.6 外部网关协议"></a>3.2.6 外部网关协议</h4><h5 id="1-BGP"><a href="#1-BGP" class="headerlink" title="1. BGP"></a>1. BGP</h5><blockquote><p>BGP，边界网关协议。</p></blockquote><ul><li><strong>特点：</strong><ul><li>每个自治系统选出一个发言人，即边界路由器；</li><li>发言人之间使用 TCP 交流信息；</li><li>交流的信息包括要到达某个网络需要经过的自治系统；</li><li>位于应用层。</li></ul></li></ul><hr><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h2><blockquote><p>　　提供端到端的通信，只有主机的协议栈才由运输层，路由部分只会使用到下三层的功能。任务还要包含对报文的差错检测，因为IP层只对IP数据报的首部进行校验，可靠传输由传输层来保证。</p></blockquote><h3 id="4-0-一些使用UDP、TCP的协议"><a href="#4-0-一些使用UDP、TCP的协议" class="headerlink" title="4.0 一些使用UDP、TCP的协议"></a>4.0 一些使用UDP、TCP的协议</h3><table><thead><tr><th><strong>应用</strong></th><th><strong>应用层协议</strong></th><th><strong>运输层协议</strong></th></tr></thead><tbody><tr><td>名字转换</td><td>DNS（域名系统）</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP（简单文件传送协议）</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP（路由信息协议）</td><td>UDP</td></tr><tr><td>IP地址配置</td><td>DHCP（动态主机配置协议）</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP（简单网络管理协议）</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS（网络文件系统）</td><td>UDP</td></tr><tr><td>IP电话</td><td>专用协议</td><td>UDP</td></tr><tr><td>流式多媒体通信</td><td>专用协议</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP（网际组管理协议）</td><td>UDP</td></tr><tr><td>电子邮件</td><td>SMTP（简单邮件传送协议）</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET（远程终端协议）</td><td>TCP</td></tr><tr><td>万维网</td><td>HTTP（超文本传送协议）</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP（文件传送协议）</td><td>TCP</td></tr></tbody></table><h3 id="4-1-UDP"><a href="#4-1-UDP" class="headerlink" title="4.1 UDP"></a>4.1 UDP</h3><blockquote><p>　　User Datagram Protocol，用户数据报协议。不需要建立连接和确认，如果想要实现可靠的UDP传输，需要在应用层实现。</p></blockquote><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00006.jpg" alt="img" style="zoom: 50%;" /><ul><li><strong>特点：</strong><ul><li>无连接的、尽最大努力交付；</li><li><strong>面向报文</strong>的，即对应用层传下来的报文，不合并也不拆分直接加上UDP头部，就交给IP层；<ul><li>因此应用层一定要注意报文长度，避免其加上UDP头部后超过MTU，IP层就不得不对其进行拆分，影响效率；</li></ul></li><li>没有拥塞控制、实时性高，适合IP电话、视频会议等；</li><li>支持一对一、一对多、多对一和多对多的交互通信；</li><li>首部开销小，只有8字节，其实只是对IP层扩充了一些功能，即复用、分用和差错校验。<ul><li>但在计算校验和的时候会加上12字节的伪首部，伪首部不会传输，只用来计算检验和。</li></ul></li></ul></li></ul><h3 id="4-2-TCP"><a href="#4-2-TCP" class="headerlink" title="4.2 TCP"></a>4.2 TCP</h3><blockquote><p>　　Transmission Control Protocol，传输控制协议。提供可靠的、面向连接的服务，不提供广播或多播服务。</p></blockquote><ul><li><strong>特点：</strong><ul><li>面向连接，体现在维护连接状态表；</li><li>只能一对一；</li><li>提供全双工通信，有发送缓冲和接收缓冲；</li><li><strong>面向字节流</strong>，TCP协议将应用层传下来的数据看作是无结构的字节流；<ul><li>即会合并、拆分，由 TCP 来控制传递给 IP 层的数据包大小，应用层协议需要有识别这些字节流的能力；</li></ul></li></ul></li></ul><br><p>　　下面记录如何实现可靠的传输服务。</p><h4 id="4-2-1-停止等待协议"><a href="#4-2-1-停止等待协议" class="headerlink" title="4.2.1 停止等待协议"></a>4.2.1 停止等待协议</h4><blockquote><p>停止等待就是每发送完一个分组就等待对方的确认，收到确认后再发送下一个分组。</p></blockquote><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00022.jpg" alt="停止等待协议" style="zoom: 50%;" /><p><strong>发送出现差错：</strong></p><ul><li>接收方收到错误的分组或没有收到分组，都不用发送确定分组；</li><li>发送方超过一段时间没有收到确认就认为刚才发送的分组丢失了，就会重新发送刚才的分组；</li></ul><br><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00018.jpg" alt="img" style="zoom:50%;" /><p><strong>确认出现差错：</strong></p><ul><li>确认丢失：发送方误以为分组丢失了，于是超时重传，接收方收到重复的分组后丢弃之，并重新发送确认；</li><li>确认迟到：发送方误以为分组丢失了，于是超时重传，接收方收到重复的分组后丢弃之，并重新发送确认，发送方收到过期的确认什么都不做。</li></ul><br><p>　　基于上述的可靠传输协议，可以称为ARQ（Automatic Repeat reQuest），自动重传请求。因为重传请求不需要依赖于接收方，完全是自动的。</p><p><strong>信道利用率：</strong></p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00013.jpg" alt="img" style="zoom:50%;" /><br><p>公式：<br>$$<br>U=\frac{T_D}{T_D+RTT+T_A}<br>$$</p><p>　　停止等待协议简单但是信道利用率太低，需要使用连续ARQ协议和滑动窗口协议来改善。</p><h4 id="4-2-2-连续-ARQ-协议"><a href="#4-2-2-连续-ARQ-协议" class="headerlink" title="4.2.2 连续 ARQ 协议"></a>4.2.2 连续 ARQ 协议</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00004.jpg" alt="img" style="zoom:50%;" /><p><strong>原理：</strong></p><ul><li><p><strong>发送方：</strong>不需要每次都等待接收方的确认，而是维护一个发送窗口，在窗口内的分组都可以直接发送不需要等待确认；</p></li><li><p>接收方：不需要对每个接收到的分组都进行确认，而是采用<strong>累计确认</strong>的方式，对<strong>按序到达的最后一个分组</strong>进行确认；</p></li><li><p><strong>收到确认后：</strong>根据确认分组号可以把发送窗口向前推进；</p></li><li><p><strong>缺点：</strong>发送方不能知道接收方已接受的所有分组的情况，存在<strong>回退N问题</strong>。如接收方接收到了分组1、2、5、6、7，只能发送确认分组2已被正确收到的消息，发送方不知道接收方正确收到了分组5、6、7，只能重新发送。</p></li></ul><br><h4 id="4-2-3-滑动窗口协议"><a href="#4-2-3-滑动窗口协议" class="headerlink" title="4.2.3 滑动窗口协议"></a>4.2.3 滑动窗口协议</h4><ul><li><p>滑动窗口的<strong>序号以字节为单位</strong>，占32位，循环使用。</p><ul><li>一般情况下（慢速），不会出现重复序号，若发送速率极快，则需要借助时间戳来防止序号绕回。</li></ul></li><li><p>TCP 规定累计确认时间不得超过 0.5s；</p></li><li><p><strong>超时重传时间RTO</strong>的选择：</p><ul><li>使用<strong>报文段往返时间RTT</strong>的加权平均，公式：</li></ul><p>$$<br>新的RTT_S=\left ( 1- α\right )<em>(旧的RTT_S)+α</em>新的RTT样本<br>$$</p><p>​            其中s表示smoothed，平滑的，α建议取值1/8。</p><ul><li><p>超时重传时间，应该略大于RTT，于是建议加上RTT<sub>D</sub>表示RTT的<strong>偏差的加权平均</strong>：<br>$$<br>RTO=RTT_s + 4 * RTT_D<br>$$</p><p>$$<br>新的RTT_D=(1-β)<em>(旧的RTT_D)+β</em>\left | RTT_S-新的RTT样本 \right |<br>$$</p><p>​    第一次测量时，RTT<sub>D</sub>取RTT的一半，β小于1，建议取值1/4；</p></li><li><p>一种情况：若发生了超时重传，同时发送方收到了对旧报文的确认，则发送方可能会将这个确认当做是超时重传的报文的确认，这时候RTO就会越来越小，导致不停地重传。</p><ul><li>因此若发生重传则不能使用上述算法，而是每次发生重传都将 RTO<sub>new </sub>= 2 * RTO<sub>old</sub>；</li></ul></li></ul></li></ul><h3 id="4-3-TCP-首部格式"><a href="#4-3-TCP-首部格式" class="headerlink" title="4.3 TCP 首部格式"></a>4.3 TCP 首部格式</h3><blockquote><p>TCP 的功能就体现在首部字段。</p></blockquote><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00003.jpg" alt="img" style="zoom: 50%;" /><ol><li><strong>源端口和目的端口</strong>；</li><li><strong>序号</strong>：4 Byte，循环使用，<u>单位是字节</u>，指向本报文要发送的第一个字节序号；</li><li><strong>确认号：</strong>4 Byte，指向期望接受的报文的第一个字节序号；<ul><li>若确认号＝<em>N</em> ，则表明：到序号<em>N</em> –1为止的所有数据都已正确收到；</li></ul></li><li><strong>数据偏移</strong>：4 bit，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，单位是每4 Byte；</li><li><strong>保留</strong>：6 bit；</li><li><strong>紧急</strong> URG（URGent）：当URG＝1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送，发送方TCP会把紧急数据插入到本报文段数据的<strong>最前面</strong>，使用紧急指针记录紧急数据的字节数；</li><li><strong>确认</strong> ACK（ACKnowledgment）：仅当ACK＝1时确认号字段才有效。当ACK＝0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1；</li><li><strong>推送</strong> PSH（PuSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH＝1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付；</li><li><strong>复位</strong> RST（ReSeT）：当RST＝1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位；</li><li><strong>同步</strong> SYN（SYNchronization）：在连接建立时用来同步序号。当SYN＝1而ACK＝0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN＝1和ACK＝1。因此，SYN置为1就表示这是一个连接请求或连接接受报文；</li><li><strong>终止</strong> FIN（FINish）：用来释放一个连接。当FIN＝1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接；</li><li><strong>窗口</strong>：2 Byte，指的是发送本报文段的一方的<strong>接收窗口</strong> ，<strong>告诉对方</strong> ：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）；</li><li><strong>检验和</strong>：2 Byte，计算检验和时，和UDP一样也要加12 Byte的伪首部；</li><li><strong>紧急指针</strong>：2 Byte，仅在URG＝1时才有意义，指出本报文段中的紧急数据的字节数，<strong>即使窗口为零时也可发送紧急数据</strong>；</li><li><strong>选项</strong>：长度可变，最长可达40字节，用于扩展功能，如窗口扩大、SACK、时间戳等；</li><li><strong>填充</strong>：对齐填充。</li></ol><h3 id="4-4-流量控制、拥塞控制"><a href="#4-4-流量控制、拥塞控制" class="headerlink" title="4.4 流量控制、拥塞控制"></a>4.4 流量控制、拥塞控制</h3><h4 id="4-1-1-流量控制"><a href="#4-1-1-流量控制" class="headerlink" title="4.1.1 流量控制"></a>4.1.1 流量控制</h4><blockquote><p>流量控制就是不要让发送方发送太快而淹没接收方，使用TCP 报头的“窗口”字段实现。</p></blockquote><ul><li><strong>窗口：</strong>指示了从本报文的确认号开始计算，还能接收多少<strong>字节</strong>的数据，用rwnd表示。</li><li>存在一个<strong>问题</strong>：当接收方的窗口为0时，发送方会等待接收方发送一个窗口非0的消息，若此消息丢失，则会一直等待下去，为了解决该问题：<ul><li><strong>持续计时器</strong>，当一方收到0窗口消息时，就启动持续计时器，到时后，发送一个0窗口探测报文，以探测另一方的接收窗口值，若得到的消息仍是0窗口，就重置持续计时器。</li></ul></li></ul></br><h4 id="4-4-2-拥塞控制"><a href="#4-4-2-拥塞控制" class="headerlink" title="4.4.2 拥塞控制"></a>4.4.2 拥塞控制</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00099.jpg" alt="img" style="zoom: 50%;" /></br><p>　　TCP 使用<strong>慢开始</strong> （slow-start）、<strong>拥塞避免</strong> （congestion avoidance）、<strong>快重传</strong> （fast retransmit）和<strong>快恢复</strong>（fast recovery）进行拥塞控制。</p><p> 　　起初，处于<code>慢开始阶段</code>，拥塞窗口 cwnd=1，窗口的增长速率比较快，当到达慢开始门限时，进入<code>拥塞避免阶段</code>，降低窗口的增大速率，改为加法增大，当发生拥塞时，重新回到慢开始阶段。</p><p>　　那么<strong>如何判断是否发生了拥塞</strong>？</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00098.jpg" alt="img" style="zoom:50%;" /><p>　　发送方认为发生了重传即产生了阻塞，但这是不准确的，使用<code>快重传</code>方法让发送方尽早知道没有发生阻塞。发送方一连收到三个重复确认，即可以知晓可能并不是阻塞了，遂不执行慢开始，而是执行<code>快恢复阶段</code>。</p><p>　　引入了阻塞窗口 cwnd 后，应该知道 <code>发送窗口 = Min（rwnd，cwnd）</code>。</p><h3 id="4-5-三次握手、四次挥手"><a href="#4-5-三次握手、四次挥手" class="headerlink" title="4.5 三次握手、四次挥手"></a>4.5 三次握手、四次挥手</h3><h4 id="4-5-1-三报文握手"><a href="#4-5-1-三报文握手" class="headerlink" title="4.5.1 三报文握手"></a>4.5.1 三报文握手</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00094.jpg" alt="img" style="zoom:50%;" /><p><strong>步骤：</strong></p><p>　　第一步：A 发送 <code>SYN = 1</code>序号为<code>x</code>的<strong>连接请求报文</strong>，TCP规定，连接请求报文不能携带数据，但要<strong>消耗掉一个序号</strong> ；</p><p>　　第二步：B 发送<code>SYN = 1,ACK = 1</code>的<strong>连接请求确认报文</strong>；</p><p>　　第三步：A 对连接请求确认报文再次进行确认，当B收到确认的确认后，连接建立完成。</p><p><strong>问题：</strong></p><ul><li>为什么要有第三步对确认的确认？</li></ul><p>　　防止已失效的连接请求报文段突然又传送到了B。</p><blockquote><p> 　　假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p></blockquote><ul><li>若第三次确认丢失会怎样？</li></ul><p>　　第三次确认可能丢失，也可能如上面第一个问题描述的情况，B收到了已经失效的连接请求报文，此时A其实并不想建立连接。</p><p>　　回忆 ARQ 的含义，自动重传请求，第三次确认丢失，B 会认为是第二步的连接请求报文丢失而超时重传，这时 A 就可以重新发送第三次确认。如果B重传一定次数后仍未收到第三步的确认，则会自动关闭链接。</p><h4 id="4-5-2-四报文挥手"><a href="#4-5-2-四报文挥手" class="headerlink" title="4.5.2 四报文挥手"></a>4.5.2 四报文挥手</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00093.jpg" alt="img" style="zoom:50%;" /><p><strong>步骤：</strong></p><p>　　第一步：一方发出<code>FIN = 1</code>的<strong>链接释放请求报文</strong>，A 不再发送数据；</p><p>　　第二步：发送正常确认，确认<strong>我收到了你的链接释放请求报文</strong>，此时B也许还会有数据发送；</p><p>　　第三步：若 B 也没有数据发送时，则发送<code>FIN = 1,ACK = 1</code>的<strong>连接释放请求确认报文</strong>；</p><p>　　第四步：A 再发送<strong>确认的确认</strong>，若 B 收到后即可释放连接，但此时 A 还要等待<strong>2MSL</strong>；</p><p><strong>问题：</strong></p><ul><li><p>为什么是 2MSL？</p><p>MSL（Maximum Segment Lifetime），最长报文段寿命。因为要保证A发送的ACK能被B正确收到，若收不到B就会重传FIN。</p><p>  　　去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)就是2MSL。</p></li><li><p>为什么需要 2MSL？</p><ol><li>保证第四步 A 发送的<code>确认的确认</code>能够到达 B ，因为若确认的确认丢失，B 会认为<code>确认</code>丢失，而重传<code>确认</code>，这时 A 就可以重传<code>确认的确认</code>，同时会重新设置 2MSL 计时器；</li><li>保证本链接持续时间内所产生的所有报文段都从网络中消失，以此防止旧链接中的报文和新链接中的报文混淆。</li></ol></li></ul><hr><h2 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5. 应用层"></a>5. 应用层</h2><h3 id="5-1-DNS"><a href="#5-1-DNS" class="headerlink" title="5.1 DNS"></a>5.1 DNS</h3><blockquote><p>Domain Name System，域名系统。</p></blockquote><ul><li>两种查询方式：迭代查询、递归查询</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20201107112407705.png" alt="DNS 查询方式"></p><h3 id="5-2-DHCP"><a href="#5-2-DHCP" class="headerlink" title="5.2 DHCP"></a>5.2 DHCP</h3><blockquote><p>　　Dynamic Host Configuration Protocal，动态主机配置协议。允许一台新加入网络的计算机自动获取相应的网络配置信息。配置项包括：IP、子网掩码、默认路由的IP、域名服务器的IP。默认路由IP，对我们使用PC机来说可以理解为就是网关。</p></blockquote><p><strong>过程：</strong></p><p>　　DHCP使用客户服务器方式（使用UDP协议）。需要IP地址的主机在启动时就向DHCP服务器广播发送<strong>发现报文</strong> （DHCPDISCOVER）（将目的IP地址置为全1，即255.255.255.255），这时该主机就成为DHCP客户。发送广播报文是因为现在还不知道DHCP服务器在什么地方，因此要发现（DISCOVER）DHCP服务器的IP地址。这台主机目前还没有自己的IP地址，因此它将IP数据报的源IP地址设为全0。这样，在本地网络上的所有主机都能够收到这个广播报文，但只有DHCP服务器才对此广播报文进行回答。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP地址池（address pool）中取一个地址分配给该计算机。DHCP服务器的回答报文叫做<strong>提供报文</strong> （DHCPOFFER），表示“提供”了IP地址等配置信息。</p><h3 id="5-3-HTTP"><a href="#5-3-HTTP" class="headerlink" title="5.3 HTTP"></a>5.3 HTTP</h3><blockquote><p>基于 TCP 协议。</p></blockquote><p>1xx表示通知信息，如请求收到了或正在进行处理。</p><p>2xx表示成功，如接受或知道了。</p><p>3xx表示重定向，如要完成请求还必须采取进一步的行动。</p><p>4xx表示客户的差错，如请求中有错误的语法或不能完成。</p><p>5xx表示服务器的差错，如服务器失效无法完成请求。</p><h4 id="5-3-1-HTTP-版本主要区别"><a href="#5-3-1-HTTP-版本主要区别" class="headerlink" title="5.3.1 HTTP 版本主要区别"></a>5.3.1 HTTP 版本主要区别</h4><p><a href="https://segmentfault.com/a/1190000016656529">参考自这里</a></p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Image00195.jpg" alt="img" style="zoom:50%;" /><ul><li><p><strong>HTTP 1.0</strong>（1996）</p><ul><li>请求一个万维网文档所需的时间是<strong>该文档的传输时间</strong>（与文档大小成正比）<strong>加上两倍往返时间RTT</strong>（一个RTT用于连接TCP连接，另一个RTT用于请求和接收万维网文档。TCP建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文）。</li><li>缺点：HTTP 1.0 每次请求都要加上两倍的 RTT 开销，因为每个TCP连接上只能发送一次请求。</li></ul></li><li><p><strong>HTTP 1.1</strong>（1999）</p><ul><li>增加了一些头和响应码，如用于记录域名的 HOST 头；</li><li>长连接，允许在一条 TCP 连接上，传送多次 HTTP 请求，分类；<ul><li>非流水线方式：客户端收到前一个响应后才可以发送下一个请求；</li><li>流水线方式：有一个请求队列，不需要等待上一个响应，提高了性能，但仍存在队列头阻塞的问题。</li></ul></li></ul></li><li><p><strong>HTTP 2.0</strong>（2015）</p><ul><li><p><strong>二进制传输</strong>（核心）：在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。</p></li><li><p><strong>多路复用：</strong>有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p></li><li><p><strong>Header压缩：</strong>一方面体现在使用了压缩算法，另一方面现在两端维护了一个索引表，记录曾出现过的Header键名，对端收到后可以通过键找到相应的值。</p></li></ul></li></ul><p><strong>文本文件 VS 二进制文件？</strong></p><p>　　读文件分为两个转化过程：<strong>磁盘 –&gt; 文件缓冲区 –&gt; 应用程序内存空间</strong>。从第一个过程来看，两种文件没有本质区别，都是读二进制的 0 和 1。</p><p>　　一个文件包含两部分信息：<strong>控制信息+内容信息</strong>。控制信息即文件的头部，告诉软件怎么打开该文件。可以理解为：文本文件是一种特殊的二进制文件，区别在于不同应用程序对其的解释方式。</p><p>　　那么二进制为什么效率高，举例，如文本文件使用ASCII编码表示65535需要5 Byte，二进制只需要使用 2Byte。</p><h4 id="5-3-2-HTTPS"><a href="#5-3-2-HTTPS" class="headerlink" title="5.3.2 HTTPS"></a>5.3.2 HTTPS</h4><blockquote><ul><li><p>端口 443。</p></li><li><p>使用<strong>对称加密和非对称加密结合</strong>的方式。</p><ul><li>因为对称加密效率高，但对称加密的密钥协商是个问题，故使用非对称加密来加密对称加密的密钥。</li></ul></li></ul></blockquote><p><strong>工作原理：</strong></p><p>　　HTTP 协议是明文传输，不安全主要体现在容易被<strong>截取破解</strong>、<strong>篡改伪造</strong>。下面就看HTTPS是怎么解决这两个问题的。</p><ul><li><p>考虑如果只使用对称加密的方式，第一步肯定是客户端和服务器以<u>明文方式协商对称密钥</u>，但这时候密钥也有可能被中间者获取。</p><p><strong>如何防止中间者获取密钥？</strong></p></li><li><p>这时候就需要非对称加密，浏览器随机生成对称密钥，并使用服务器提供的公钥进行加密后再传输，服务器收到后使用私钥解密即可获得对称密钥，而中间者因为没有私钥而难以破解信息。但公钥可能会被中间者伪造。</p><p><strong>客户端要如何安全的知道公钥？</strong></p></li><li><p>因为我们不可能保存所有网站的公钥，所以需要引入一个受信任的第三方机构，<strong>CA 机构</strong>。网站向CA机构申请安全证书，证书内容包括网站公钥、域名、有效时间等信息，CA机构使用自己的私钥对证书进行加密后颁发给网站。每当浏览器请求HTTPS网站时，服务器会首先返回这个安全证书，客户端使用CA机构的公钥解密证书，无法解密成功则说明这个加密证书有可能被篡改了。</p><ul><li><p>受信任的CA机构的公钥不会很多，一般会预置在系统中。</p></li><li><p>证书不会被篡改，因为首先即使中间者获得了证书信息，篡改了其中的条目，但没有CA机构的私钥就无法再次加密；其次，即使中间者是用自己向CA机构申请的真实证书来替换原服务器的证书发送给客户端，客户端也会根据证书中的其他信息来判断证书是否安全，如根据域名判断。</p></li></ul></li></ul><h4 id="5-3-3-url-回车"><a href="#5-3-3-url-回车" class="headerlink" title="5.3.3 url+回车"></a>5.3.3 url+回车</h4><p>　　传输层是面向通信部分的最高层，是面向用户功能的最底层。</p><ul><li>从面向用户功能来看：<ul><li>URL – DNS解析 – 生成HTTP报文 – 建立TCP链接 – 发送请求 – 服务器处理请求 – 返回数据 – 浏览器解析渲染 – 释放TCP链接</li></ul></li><li>从面向通信来看：<ul><li>应用层：DNS解析、生成HTTP报文</li><li>传输层：建立TCP链接</li><li>网络层：RIP或OSPF、BGP、IP协议、ARP获取MAC地址</li><li>数据链路层：发送数据</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Networks </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志：binlog 和 redolog</title>
      <link href="Database/MySQL%E6%97%A5%E5%BF%97.html"/>
      <url>Database/MySQL%E6%97%A5%E5%BF%97.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　MySQL中有多种日志：错误日志（error log）、二进制日志（binlog）、查询日志（general log）、慢查询日志（slow query log）等，还有InnoDB自有的重做日志（redo log）。</p><p>　　本篇主要从崩溃恢复来了解 MySQL 是如何使用 <strong>binlog</strong> 和 <strong>redo log</strong>的。</p></blockquote><ol><li><p><strong>错误日志</strong>：记录MySQL的<strong>启动、运行、关闭过程</strong>中的一些重要信息，默认存放在<code>data/主机名.err</code>。</p></li><li><p><strong>查询日志</strong>：记录所有对MySQL数据库的<strong>查询请求</strong>，默认存放在<code>mysql.general_log</code>表中，默认关闭。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%general_log%&#x27;</span>; <span class="comment">-- 显示OFF</span></span><br></pre></td></tr></table></figure></li><li><p><strong>二进制日志</strong>：记录所有对MySQL数据库执行的<strong>更改操作</strong>，默认不开启，存放在 Data 目录下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;log_bin&#x27;</span>; <span class="comment">-- 显示OFF</span></span><br></pre></td></tr></table></figure></li><li><p><strong>慢查询日志</strong>：记录执行时间超过某一阈值的<strong>所有语句</strong>，默认开启，存放在<code>mysql.slow_log</code>表中。</p></li><li><p><strong>重做日志</strong>：InnoDB特有，记录了InnoDB的事务日志。默认有两个文件循环写，存放在<code>data/ib_logfile0</code>、<code>data/ib_logfile1</code>。</p></li></ol><br><a id="more"></a><hr><h3 id="1-binlog-vs-redo-log"><a href="#1-binlog-vs-redo-log" class="headerlink" title="1. binlog vs redo log"></a>1. binlog vs redo log</h3><ol><li>binlog 由 server 层提供，所有引擎都可以使用；而 redo log 是 Innodb 所特有的。</li><li>binlog 是逻辑日志，记录逻辑操作；redo log 是物理日志，记录的是数据页上发生的变化。<ul><li>binlog 有两种模式，statement 格式记录sql语句，row 格式记录数据行更新前和更新后的内容。</li></ul></li><li>binlog 采用追加写，拥有<strong>归档</strong>的功能；redo log 有两个指针 check point 和 write point 采用循环写。</li></ol><ul><li>应用场景：<ul><li>binlog：主从复制、归档备份。</li><li>redo log：Innodb 崩溃恢复。</li></ul></li></ul><br><hr><h3 id="2-崩溃恢复"><a href="#2-崩溃恢复" class="headerlink" title="2. 崩溃恢复"></a>2. 崩溃恢复</h3><blockquote><p>　　崩溃恢复依赖于日志系统，目的是恢复丢失的数据，原则是事务的原子性，即提交的事务才恢复，没提交的不恢复。</p></blockquote><h4 id="2-1-redo-log-如何恢复数据"><a href="#2-1-redo-log-如何恢复数据" class="headerlink" title="2.1 redo log 如何恢复数据"></a>2.1 redo log 如何恢复数据</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200927185223715.png" alt="redo log 循环写"></p><p>　　redo log 记录物理数据页的变化，崩溃恢复时，先将数据库当前的状态加载到内存中，然后从 check point 开始重放数据页的变化，即可恢复。</p><br><h4 id="2-2-WAL-和-两阶段提交"><a href="#2-2-WAL-和-两阶段提交" class="headerlink" title="2.2 WAL 和 两阶段提交"></a>2.2 WAL 和 两阶段提交</h4><p>　　<strong>WAL</strong>（Write-Ahead Logging），即先写日志，再写磁盘。原因是如果每次更新都直接写磁盘，那代价未免有点太高了。所以先在内存中更新，再记录日志，定期或闲时进行刷脏页。</p><p>　　在 binlog 和 redo log 结合使用的时候，会采用<strong>两阶段提交</strong>，来保证两个日志的一致性。默认情况下 binlog 是关闭的，即 Innodb 只使用 redo log时不会采用两阶段提交。</p><p>　　如图所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200927172407603.png" alt="两阶段提交"></p><p>　　redo log 的记录被分成两个阶段，第一个 prepare 阶段，第二个 commit 阶段，redo log 的 commit 过程是整个事务 commit 过程中的一个子过程，不要混淆二者。</p><ul><li><p><strong>为什么要两阶段提交？</strong></p><p>　　为了<strong>保证 binlog 和 redo log 的一致性</strong>，下面采用反证法，验证如果不采用两阶段提交会怎样：</p><ul><li><p>先 redo log 后 binlog：如果 binlog 没来得及写，恢复的时候根据 redo log 可以恢复成功，但是 binlog 少了一条记录，如果使用 binlog 恢复数据，如主从复制，就会出现不一致。</p></li><li><p>先 binlog 后 redo log：如果 redo log 没来得及写，恢复的时候这个事务就相当于没有提交，不恢复。而 binlog 中就多了一条记录，产生的问题同上一样。</p></li></ul><p>　　<strong>那两阶段怎么就保证了一致性呢？</strong>如果 Innodb 恢复的时候发现 redo log 中的 commit 标志，那就可以肯定 redo log 和 binlog 都已经写好了。</p><p>　　如果 redo log 的 commit 阶段写失败了呢，即在<strong>上图中的 B 点发生崩溃</strong>。这时候就需要去判断 binlog 是不是存在且完整的，如果 binlog 存在且完整，说明事务已经提交，应该恢复，否则不予以恢复。</p><p>　　那这样看来<u>不是只要 redo log 的 prepare 阶段和 binlog 就可以进行恢复了吗</u>，又绕回了为什么需要两阶段提交的问题。这时候就要考虑性能问题，如果不采用两阶段提交，没有 commit 标识，就不能肯定 binlog 是否完整，那每次都需要去检查 binlog 的完整性，效率太低。</p><p>　　<strong>redo log 和 binlog 是怎么关联的？</strong>他们有一个共同的字段 XID，当恢复时，redo log 碰到只有 prepare 而没有 commit 的时候，就会拿着 XID 去寻找 binlog，判断其是否完整。</p></li><li><p><strong>能否只用 binlog 或只用 redo log？</strong></p><p>　　<strong>结论：</strong>Innodb 的崩溃恢复可以只用 redo log 不用 binlog，因为我们知道 binlog 默认就是关闭的，但是会丢失一些功能。</p><ul><li>只用 binlog：不可，因为对于 WAL 来说，只使用 binlog 无法知道确切的数据页状态，因为 binlog 并没有 check point 指示未落盘的位置。</li><li>只用 redo log：从崩溃恢复角度来说可以，而且这时候也不用两阶段提交。但是主从复制、备份归档，都需要使用 binlog，因为 redo log 是循环写，无法做到归档的功能。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务与并发控制和锁</title>
      <link href="Database/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81.html"/>
      <url>Database/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>了解事务的ACID特性、隔离级别、并发控制、锁……</p></blockquote><br><hr><a id="more"></a><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><br><h4 id="1-1-ACID-特性"><a href="#1-1-ACID-特性" class="headerlink" title="1.1 ACID 特性"></a>1.1 ACID 特性</h4><ul><li><strong>原子性（atomicity）：</strong>整个事务中的操作要么都做，要么都不做。</li><li><strong>一致性（consistency）：</strong>事务不能改变数据库的一致性，如事务中的操作打破了定义的约束条件，这时候就得回滚。</li><li><strong>隔离性（isolation）：</strong>事务之间相互隔离，事务未提交之前，其更改对其他事务都不可见。</li><li><strong>持久性（durability）：</strong>事物一旦提交，其结果就是永久性的，即使崩溃也要能够恢复。</li></ul><br><h4 id="1-2-隔离级别"><a href="#1-2-隔离级别" class="headerlink" title="1.2 隔离级别"></a>1.2 隔离级别</h4><ul><li>事务并发时的<strong>数据不一致性</strong>问题：<ul><li><strong>脏读</strong>：读到了其他事务已修改但尚未提交的数据。</li><li><strong>不可重复读</strong>：一个事务中多次读取相同记录，发现内容不一致，因为另一个事务进行了修改操作并已提交。</li><li><strong>幻读</strong>：一个事务中多次读取的数据条数不一致，另一个事务进行了增删改操作。</li></ul></li></ul><br><ul><li>为了解决上述问题，提出的隔离级别：<ul><li><strong>读未提交</strong>（Read Uncommitted）：一个事务可以看到其他事务已修改但尚未提交的数据。</li><li><strong>读已提交</strong>（Read Committed，<strong>RC</strong>）：一个事务只能看到其他事务已经提交的数据。</li><li><strong>可重复读</strong>（Repeatable Read，<strong>RR</strong>）：一个事务在执行过程中看到的数据，总是和它启动时看到的一样。</li><li><strong>可串行化</strong>（Serializable）：读写都要加锁，所有操作均可以转化为一个串行化序列，避免并行访问。</li></ul></li></ul><p>　　注意：隔离级别越高，并发度越低，MySQL默认为可重复读。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">读已提交</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">可串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><br><hr><h3 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h3><p>　　事务的隔离级别是<strong>为了解决数据的不一致性问题</strong>，是通过加锁的手段实现的，但如果只是单纯的加锁，如加读写锁使其可串行化避免并行访问，业务方面那当然不会有问题。只是加锁的同时我们还要考虑其并发性，我们知道读读是不冲突的，而读写、写写都会冲突，如果有一个办法能够保证一致性读的同时还能够进行写操作（<strong>即一致性非锁定读</strong>），那是极好的。</p><p>　　这时候就有了MySQL的<strong>多版本并发控制</strong>（Multiple Version Concurrent Control，<strong>MVCC</strong>）。</p><br><h4 id="2-1-多版本并发控制（MVCC）"><a href="#2-1-多版本并发控制（MVCC）" class="headerlink" title="2.1 多版本并发控制（MVCC）"></a>2.1 多版本并发控制（MVCC）</h4><p>　　MVCC 的目的就是实现一致性非锁定读，这就需要为每个事务维护一个<code>一致性快照</code>(consistent snapshot)，这个快照当然不是物理上真实存在的，而是通过给每行记录加上一个<code>版本号</code>再配合<code>undo log</code>实现的。</p><p>　　<strong>undo log</strong>：当记录更新时，都会在undo log中记录一条回滚操作，即更新的逆操作，通过这个逆操作我们可以使记录回滚到之前的一个状态。当系统内没有比某条undo log更早的快照时，这条undo log就可以删除。</p><p>　　<strong>MVCC 是针对 RC、RR两个隔离级别而言的</strong>，区别就在于RR下一致性快照是在事务开启时创建的，RC下事务中的每一条语句都会开启一个一致性快照，达到读已提交的效果。</p><p>　　MySQL 通过 MVCC 解决 RR 下的不可重复读，但是为什么 RC 也要使用 MVCC，因为 MVCC 不只解决了重复读问题，还提供了一致性非锁定读。</p><br><ul><li><strong>下面针对MySQL的默认隔离级别RR对MVCC进行讨论：</strong></li></ul><p>　　InnoDB会按照严格的递增顺序为每个事务分配一个<strong>唯一的事务ID</strong>，记为trx_id；而前面提到的给表中每一行记录都附加了一个<strong>版本号</strong>，记为row_id，就是<strong>用来记录某事务ID的，指示该行数据的当前版本是被哪一个事务更新过的</strong>。</p><p>　　历史版本数据并不会真实的保存，而是需要时通过undo log进行还原，undo log除了记录更新操作对应的逆操作之外，还记录了 trx_id 以指示这个更新是哪个事务做的。</p><p>　　在一个事务开启的瞬间，InnoDB为该事务创建了一个<strong>数组</strong>，用来记录此刻系统内正在活动的事务ID。这个数组中的最大值（即当前事务ID）和最小值将表中的记录按照其 row_id 分为了三个部分：</p><ol><li><p><strong>小于最小值的部分</strong>，都是已提交的事务更新过的数据，则当前事务可以看到。</p></li><li><p><strong>中间部分</strong>：</p><ol><li><p>若记录的 row_id 在当前事务的数组中，说明当前事务开启的瞬间，row_id指向的事务还没提交，当前事务看不到。</p></li><li><p>若记录的 row_id 不在当前事务的数组中，说明当前事务开启的瞬间，row_id指向的事务已经提交，当前事务可以看到。</p></li></ol><ul><li>注意：此处就是RR和RC的区别，对于RC只要提交了都能看到，而对于RR，只要当前事务开启的瞬间，没提交的事务即便后来已经提交，当前事务也看不见。</li></ul></li><li><p><strong>大于最大值的部分</strong>，都是未来事务提交过的数据，当前事务看不到。</p></li></ol><br><p>　　利用这个机制，查询时根据版本号判断某记录是不是当前事务能够看到的，若能看到，则返回该记录，若看不到，则使用undo log 回滚到第一个碰到的、当前事务能看到的记录，再将其返回。</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200616154920429.png" alt="RR下某事务的查询过程"></p><br><ul><li><strong>注意：</strong></li></ul><ol><li>对于默认的查询操作，那要判断版本号，而对于更新操作，采用<code>“当前读”</code>操作，即只获取最新版本。因为若更新时也判断能不能看得到，就会丢失未来事务做的更改。</li><li>使用默认的查询称为<strong>一致性非锁定读</strong>，即没有加读锁。而使用<code>select ... for update</code>、<code>select ... lock in share mode</code>则会使用<strong>一致性锁定读</strong>，即正常的加读、写锁（是行锁），保证了读取的是最新版本同时也不能让后面的事务进行更新操作。一致性锁定读说是锁定，但也不会影响后面的读，因为后面的读会进行undo找到可用版本。</li></ol><br><h4 id="2-2-如何解决幻读"><a href="#2-2-如何解决幻读" class="headerlink" title="2.2 如何解决幻读"></a>2.2 如何解决幻读</h4><ul><li><strong>注意：</strong>RR 解决不了幻读，Innodb 通过间隙锁来<strong>改善</strong>幻读。说改善是因为对于<strong>当前读</strong>来说，RR是无法避免幻读的，但 Innodb 使用间隙锁防止了数据的新增操作，结合行锁，防止了删除操作。</li></ul><h5 id="2-2-1-间隙锁"><a href="#2-2-1-间隙锁" class="headerlink" title="2.2.1 间隙锁"></a>2.2.1 间隙锁</h5><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200616160530580.png" alt="来自MySQL实战45讲"></p><p>　　RR 隔离级别在<strong>当前读</strong>的情况下无法解决幻读问题，串行化代价又太高，而究其原因，<strong>幻读是因为其他事务在当前事务第一次查询时返回的结果集范围内部区域进行了增删改操作。</strong>只通过行锁不能解决这个问题，MySQL使用<strong>间隙锁</strong>（Gap Lock）配合<strong>行锁</strong>来<strong>改善</strong>这个问题。</p><p>　　<strong>间隙锁：</strong>即两条数据之间的空隙，给这个空隙加上锁，以防止其他事务在当前事务<strong>第一次当前读产生的结果集范围内</strong>增删数据。</p><ul><li><strong>注意：</strong><ul><li>RR非当前读不会出现幻读问题，因为一开始就建立了一致性快照。</li><li>间隙锁之间、间隙锁和行锁之间都不会冲突，<strong>间隙锁只和往这个间隙之中插入的操作发生冲突</strong>。</li><li>间隙锁 + 行锁称为 <strong>“next-key lock”</strong>。</li></ul></li></ul><br><h5 id="2-2-2-加锁机制"><a href="#2-2-2-加锁机制" class="headerlink" title="2.2.2 加锁机制"></a>2.2.2 加锁机制</h5><ol><li>查询过程中访问到的记录都会被加锁。<ul><li>注意：<ul><li>即使没找到记录也会加间隙锁，提交时释放。</li><li>若查询的是辅助索引，不回表就不会在主键索引上加锁。</li></ul></li></ul></li><li>加锁的单位是next-key lock，是一个左开右闭区间。</li><li>当进行等值查询时，有两点优化：<ol><li>给唯一索引加锁时，next-key lock 降级为行锁，即只会锁一条记录。</li><li>给普通索引加锁时，遇到第一个不满足等值条件的记录时，next-key lock降级为间隙锁，即最后一个区间为间隙锁。</li></ol></li><li>一个BUG：唯一索引上的范围查询会访问到第一个不满足条件的值为止，并且不会降级为间隙锁。</li></ol><ul><li><p><code>start transaction</code> VS <code>begin</code></p><p>前者执行后就会开启事务，后者执行到第一条语句前才会开启事务。</p></li></ul><br><hr><h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3. 锁"></a>3. 锁</h3><p>　　锁的目的：解决并发访问下的数据一致性问题。</p><ul><li><strong>全局锁</strong>：对整个数据库实例加锁，典型的应用场景是数据库备份。<ul><li>使用命令：Flush tables with read lock。</li></ul></li><li><strong>表锁</strong>分为两种：<ul><li><strong>表锁</strong>：lock tables … read/write<ul><li>是由 MySQL Server 提供的。</li></ul></li><li><strong>元数据锁</strong>（meta data lock，<strong>MDL</strong>）：也分读、写锁，不需要显式使用，当<strong>访问一个表时</strong>就会自动加上，作用是阻塞对表结构的变更。MDL写锁会阻塞后面的读操作。</li><li>Innodb 中有<strong>意向锁</strong>（Intention Lock）， 意向共享锁 IS，意向排它锁 IX，当申请相应的<strong>行级锁</strong> S 或 X 时，必须先持有相应的意向锁。<ul><li>IS、IX 不会和行级锁冲突，只会和表级锁冲突。</li><li>意向锁的意义：要加表锁的时候需要判断两点，①当前表上有没有表锁；②当前表上有没有行级锁；在判断第二点的时候，如果一行行去查看非常浪费时间，所以引入意向锁，只要表上有意向锁就说明表中有相应的行级锁，从而阻塞加表锁的操作。</li></ul></li><li><strong>Innodb 什么时候会使用表锁？</strong><ul><li>非索引字段作为查询条件而引起的全表操作；</li><li>索引失效而引起的全表操作；</li><li>更新表结构、多表复杂的联合查询的时候。</li></ul></li></ul></li><li><strong>行锁</strong>：分读写锁还有上面2.2中提到的间隙锁。</li><li>注意：<ul><li>Innodb 会自动为外键索引列创建索引，为了防止表锁；</li><li>Innodb 的表锁由 MySQLServer 提供；</li></ul></li></ul><br><ul><li>加锁的方式：</li></ul><p>　　<strong>两段锁协议</strong>：将事务加锁和解锁分为锁的扩张和收缩两阶段，一旦开始收缩就不能再申请锁。若并发执行的事务遵守两段锁协议，则这些事务的调度都将是可串行化的，但仍有可能发生死锁。</p><p>　　事务开始后就处于加锁阶段，一直到执行ROLLBACK或COMMIT之前都是加锁阶段，ROLLBACK和COMMIT使事务进入解锁阶段。给我们的启示是：将最有可能冲突的锁最后申请，减少加锁的时间，提高并发度。</p><br><ul><li><strong>一个简单的死锁</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 使用S锁，锁住一条记录；</span></span><br><span class="line"><span class="comment">B 尝试删除该条记录，则 B 尝试加的 X锁会阻塞在 A 的 S锁上；</span></span><br><span class="line"><span class="comment">A 尝试删除该记录，会阻塞在B的X锁上；</span></span><br><span class="line"><span class="comment">造成死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">A: <span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line">B: <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">A: <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="Database/MySQL%E7%B4%A2%E5%BC%95.html"/>
      <url>Database/MySQL%E7%B4%A2%E5%BC%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>主要讨论 InnoDB引擎的B+树索引。</p></blockquote><h4 id="0-1-一些基本概念"><a href="#0-1-一些基本概念" class="headerlink" title="0.1 一些基本概念"></a>0.1 一些基本概念</h4><p>　　我们将索引的关键字称为<strong>搜索码</strong>。</p><ul><li><p>两种基本的索引类型</p><ul><li><strong>顺序索引</strong>：文件的记录按照搜索码顺序存放。</li><li><strong>散列索引</strong>：也叫哈希索引，通过一个哈希函数，将搜索码映射到不同的散列桶，文件的记录按照这个散列桶存放。</li></ul></li><li><p>按照其他标准分类：</p><ul><li><strong>聚集索引</strong>：一个文件可以包含多个索引，分别基于不同的搜索码，若文件按照其某个搜索码指定的顺序排序存放，那么这个搜索码对应的索引，称为<code>聚集索引</code>（clustered index），也称为<code>主索引</code>（primary index）。</li><li><strong>非聚集索引</strong>：若文件没有按照某个搜索码的指定顺序存放，那这个搜索码对应的索引，称为该文件的<code>非聚集索引</code>（nonclustered index），也称为<code>辅助索引</code>（secondary index）。</li><li><strong>稠密索引</strong>（denxe index）：索引项包含搜索码值和指向具有该搜索码值的第一条记录的指针，其他具有相同搜索码值的记录顺序存储在第一条记录之后。这种情况称为稠密聚集索引，但如果是非聚集索引，即记录没有顺序存放，那么稠密索引就必须记录每一个具有相同搜索码值的记录的指针。</li><li><strong>稀疏索引</strong>（sparse index）：只为搜索码的某些值建立索引项，只有顺序存放才可以使用稀疏索引，即只有聚集索引才可以使用稀疏索引。查找时，找到最大的，小于等于查找关键字的搜索码值指向的记录，然后顺序查找。</li></ul></li></ul><p>　　</p><p>　　<strong>小结：</strong>聚集索引有序，非聚集索引无序；聚集可以稠密可以稀疏，非聚集必须稠密。</p><p>　　由此，对于B+树索引，MyISAM的索引不论是主键索引还是非主键索引都是非聚集索引（叶节点保存指向数据的指针）；InnoDB的主键索引包含所有的数据，是聚集索引，非主键索引保存主键索引的搜索码，是非聚集索引。</p><p>　　后面没有特别声明的都是在讲InnoDB的索引。</p><a id="more"></a><br><hr><h3 id="1-为什么使用B-树"><a href="#1-为什么使用B-树" class="headerlink" title="1. 为什么使用B+树"></a>1. 为什么使用B+树</h3><p>　　我么知道搜索效率最高的应该是二叉树，在普通二叉树上修改，有了二叉查找树（BST）确保二叉树有序，又给BST加上平衡条件形成了AVL树，确保了稳定性。若是所有数据都能保存在内存中，那AVL树可能就是最佳之选了。但我们不得不考虑的一个问题就是磁盘IO问题。数据量很大的时候，树越高树节点分布的越广，IO就越频繁，最坏情况下IO次数等于树高，因此我们需要让树更加“矮胖”。</p><p>　　索引的作用不但是要实现对数据的快速查询，对于存在磁盘中的数据而言，索引还要对磁盘块进行编址寻址，即快速地找到数据所在的磁盘块。<strong>想要减少IO次数，就要让每一次IO调入的磁盘块上的可用信息越多</strong>，即每个磁盘块上包含的索引信息越多，这次IO的性价比就越高。</p><p>　　这时候就有了<strong>平衡多路查找树</strong>：B-树和B+树。注意 B-树 读作 “B树”，因为英文B-Tree。</p><p>　　上面提到的磁盘块对应到内存就是内存页，一般大小为4KB，不能太大，否则会产生许多内碎片。InnoDB索引页默认为16KB，就会申请连续的四个磁盘块来使用。由于程序的局部性原理，InnoDB每次读取不会只读一个内存页或一个索引页大小的磁盘块，而是会读若干个区，即包含多个磁盘块。</p><p>　　参考资料：<a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190965&idx=1&sn=53f78fa037386f85531832cd5322d2a0&chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&scene=21#wechat_redirect">B-树</a>　<a href="https://blog.csdn.net/qq_26222859/article/details/80631121?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1">B+树</a>　<a href="https://blog.csdn.net/u013235478/article/details/50625677?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">MySQL索引原理</a></p><h4 id="1-1-B-树"><a href="#1-1-B-树" class="headerlink" title="1.1 B-树"></a>1.1 B-树</h4><blockquote><p>一个<strong>m阶的B树</strong>具有如下几个特征：</p><p>1.根结点至少有两个子女。</p><p>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</p><p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p><p>4.所有的叶子结点都位于同一层。</p><p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200615133219040.png" alt="B-树"></p><br><h4 id="1-2-B-树"><a href="#1-2-B-树" class="headerlink" title="1.2 B+树"></a>1.2 B+树</h4><blockquote><p>一个<strong>m阶的B+树</strong>具有如下几个特征：</p><p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p><p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200615134318592.png" alt="B+树"></p><ul><li>注意：<ul><li>在B-树中中间节点也包含数据，而在B+树中，只有叶子节点包含数据，所以B-树的查询不够稳定。</li><li>B+树叶子节点用指针相连接形成一个链表（应该是一个双向循环链表，图中没有给出），非常适合范围查询，而B-树就需要中序遍历才可以。顺带一提为什么InnoDB不使用哈希索引，因为哈希索引只适合等值查询，范围查询就得全表扫描。</li><li>一个三层的B+树大约可以索引到1600万记录：设一条记录1KB，一个索引页16KB，根节点与中间节点的数据（Bigint）加指针（InnoDB中为6B，这里按8B计算）大约16B，所以每个中间索引页可以索引1 000个下级索引页（16KB/16B），三层B+树可以索引1000*1000*（16K/1K）≈1600万。</li></ul></li></ul><br><hr><h3 id="2-InnoDB的索引"><a href="#2-InnoDB的索引" class="headerlink" title="2. InnoDB的索引"></a>2. InnoDB的索引</h3><br><h4 id="2-1-索引查询过程"><a href="#2-1-索引查询过程" class="headerlink" title="2.1 索引查询过程"></a>2.1 索引查询过程</h4><p>　　一张表可以有多个索引，每一个索引对应一个B+树，<strong>主键索引是聚集索引</strong>，非叶子节点存放搜索码和指针，叶子节点存放所有数据；<strong>非主键索引是非聚集索引</strong>，叶子节点存放的是自己的搜索码和主键索引的搜索码。若没有主键索引，InnoDB会自动添加一个6字节的rowId作为主键索引。</p><p>　　查询辅助索引时，通常是找到相应叶子节点保存的主键值，再拿这个主键值去主键索引上寻找结果，这个过程称之为<strong>回表</strong>，总共查询了两次索引。这是一个可以优化的地方，若我们使用辅助索引只查主键值，则因为辅助索引保存了主键值可以直接返回，而不用再回表，这个称之为<strong>覆盖索引</strong>，后面还会记录。</p><p>　　查找数据时，无法直接找到需要的行，而是找到相应的页加载进内存，再在内存中采用二分法寻找数据。</p><h5 id="2-1-1-为什么建议使用自增主键"><a href="#2-1-1-为什么建议使用自增主键" class="headerlink" title="2.1.1 为什么建议使用自增主键"></a>2.1.1 为什么建议使用自增主键</h5><p>　　需要从<strong>时间</strong>和<strong>空间</strong>这两个方面去考虑：</p><ol><li>时间：主要是考虑<strong>索引维护的开销</strong>，因为索引是有序的，所以如果插入的数据有序，则插入操作基本上不会影响数据页中原来的数据，只是顺序往后放，除非发生<strong>页的分裂和合并</strong>。若插入的数据无序，则每次插入都要调整B+树使其保持有序，浪费性能。</li><li>空间：自增索引通常是一个int或bigint，也就是最多8B，我们知道辅助索引的叶子节点要保存主键值，若主键采用UUID这种字符串，那辅助索引浪费的空间就比较大。</li></ol><br><h4 id="2-2索引优化"><a href="#2-2索引优化" class="headerlink" title="2.2索引优化"></a>2.2索引优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 参考自MySQL实战45讲</span><br><span class="line">-- 用户表</span><br><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;,&#96;name&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><h5 id="2-2-1-覆盖索引"><a href="#2-2-1-覆盖索引" class="headerlink" title="2.2.1 覆盖索引"></a>2.2.1 覆盖索引</h5><p>　　前面提到了若是通过辅助索引查询主键值的话，可以直接返回，是因为辅助索引的叶子节点存放了主键值，避免了<strong>回表</strong>。那么我们是不是可以让辅助索引的叶子节点，除了保存主键值外，再保存一些额外的信息，这就是<strong>覆盖索引</strong>。</p><p>　　如业务中有大量的操作要根据身份证号查找人名，我们就可以在身份证号和人名上建立联合索引。当根据身份证号查询人名的时候，会发现叶子节点保存了人名，则可以直接返回。当然覆盖索引需要考虑空间因素，数据的冗余是否值得。</p><h5 id="2-2-2-最左前缀匹配原则"><a href="#2-2-2-最左前缀匹配原则" class="headerlink" title="2.2.2 最左前缀匹配原则"></a>2.2.2 最左前缀匹配原则</h5><p>　　当我们执行查询条件 <code>where name like ‘张%’</code> 时，InnoDB不会判断索引中的全部内容，而是只匹配最左的一个字符，达到性能的提升，这就是最左前缀匹配原则。</p><p>　　对于这个特性，我们需要的是考虑<strong>如何安排联合索引中字段的顺序</strong>，以达到最好的效果。例如联合索引顺序（name，age）就可以快速查找到某姓名用户，而反过来（age，name）就不行了。这时候想走name索引，只能再建立一个索引（name），无疑是浪费了性能。</p><h5 id="2-2-3-索引下推"><a href="#2-2-3-索引下推" class="headerlink" title="2.2.3 索引下推"></a>2.2.3 索引下推</h5><p>　　MySQL 5.6 引入了索引下推优化，当查询 <code>where name = ‘张三’  and age = 10</code> 时，使用联合索引（name，age）。5.6之前查到第一个张三，会拿着主键值去回表，在主键索引中查找出数据再判断age是否符合要求；而在5.6之后，会直接判断联合索引中的age是否符合条件，直接进行过滤，不需要回表。</p><br><h4 id="2-3-普通索引-VS-唯一索引"><a href="#2-3-普通索引-VS-唯一索引" class="headerlink" title="2.3 普通索引 VS 唯一索引"></a>2.3 普通索引 VS 唯一索引</h4><p>　　主键索引方然是唯一索引，所以这里讨论的普通索引和唯一索引都是<strong>针对辅助索引</strong>而言的，需要从查询和更新两个角度考虑。</p><ul><li><p>更新：</p><ul><li>当数据页在缓存中时：找到位置后普通索引直接更新，唯一索引需要判断是否冲突再更新。</li><li>当数据页不在缓存中时：普通索引更新可以使用<code>change buffer</code>，而唯一索引因为要判断是否唯一而需要调入其他数据页，不能使用change buffer。</li></ul></li><li><p>查询：</p><p>　　等值查询时，唯一索引查到后可以直接返回，而普通索引需要查询到下一条记录才能知道不满足条件。</p></li></ul><p>　　综上所述，写多读少时可以使用普通索引，读多写少时可以使用唯一索引。因为读多写少时可能会触发change buffer的频繁merge，有一些维护代价，不如直接插入来的直接。</p><br><h4 id="2-4-如何给字符串字段加索引"><a href="#2-4-如何给字符串字段加索引" class="headerlink" title="2.4 如何给字符串字段加索引"></a>2.4 如何给字符串字段加索引</h4><p>　　直接加当然可以，但是要考虑到空间的浪费。我们可以想到截取字符串的前几个字符作为<strong>前缀索引</strong>，以节省空间，但不要忘了索引还需要良好的区分度，否则会导致频繁的回表，在辅助索引和主键索引中“反复横跳”。</p><p>　　有两个方法可以考虑，保证区分度和节省空间：</p><ol><li>倒序存储+前缀索引：像身份证号这样的字符串，直接截取额前几位那同一个省市区的人前几位都一样，区分度太小，倒序存储后取前几位那就有了一定的区分度。</li><li>新增一个散列字段：InnoDB不支持hash索引，但是我们可以通过新增一个散列字段，给这个散列字段加上索引来模拟hash索引。</li></ol><br><h3 id="3-索引失效"><a href="#3-索引失效" class="headerlink" title="3. 索引失效"></a>3. 索引失效</h3><h4 id="3-1-优化器选错索引"><a href="#3-1-优化器选错索引" class="headerlink" title="3.1 优化器选错索引"></a>3.1 优化器选错索引</h4><p>　　优化器会根据<strong>扫描行数、是否回表、是否使用临时表、是否排序</strong>等等因素综合判断选取什么样的执行计划。在一些大范围查询、join查询的情况下，优化器可能会觉得全表扫描比走辅助索引来得快。</p><p>　　判断<strong>扫描行数</strong>显然不可能直接扫描出每一行来计数，InnoDB每隔一段时间会对索引的<strong>基数</strong>进行<strong>采样统计</strong>。基数指<strong>一个索引上不同值得个数</strong>，反映了索引中不重复记录数量的估计值，指示了索引的区分度。具体做法是：随机选择N个数据页，统计上面不同值的个数，得到平均值再乘以索引所使用的数据页的总数，就得到了该索引的基数。</p><p>　　对于<strong>非主键索引</strong>，Innodb 会使用基数来估计扫描行数，有可能造成不准确的预估扫描行数，选错索引。</p><p>　　Innodb 的<code>count(*)</code>会找一个小的唯一索引，进行遍历，没有其他唯一索引，就是主键索引。由于有MVCC 的原因，需要逐行判断当前事务能否可见，所以非常的耗时。</p><p>　　注：count的参数不是null，计数才会+1。</p><p>　　<code>show table status</code>中的<code>table_rows</code>不能作为表中数据行数的依据，因为它也是采样统计。只不过是在唯一索引上采样统计，因为是唯一的，所以基数能够一定程度上反应行数。</p><br><h4 id="3-2-使用函数导致索引失效"><a href="#3-2-使用函数导致索引失效" class="headerlink" title="3.2 使用函数导致索引失效"></a>3.2 使用函数导致索引失效</h4><ul><li><p><strong>显示调用函数：</strong></p></li><li><p>对某索引字段进行函数操作，有可能破坏索引的顺序性，所以优化器会放弃走该索引。</p></li><li><p><strong>隐式的类型转换：</strong></p><ul><li>字符串和数字运算时，MySQL会将字符串转换为数字。当索引的字段是字符串，而查询条件是数字（没加引号）时，就会隐式的将索引字段的字符串转化为数字，就会导致索引失效。</li><li>多表查询时，若关联条件在不同表的字符集不一样，则也会隐式的调用转换函数，导致索引失效。</li></ul></li><li><p><strong>其他索引失效：</strong></p><ul><li><p>使用 or、!=、&lt;&gt; 会导致索引失效；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> index1 = xxx <span class="keyword">or</span> index2 = xxx;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> index1 != xxx;</span><br></pre></td></tr></table></figure></li><li><p>索引顺序问题；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> index1 = xxx <span class="keyword">and</span> indxe3 = xxx;</span><br></pre></td></tr></table></figure></li><li><p>范围条件的右侧索引列会失效；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- index2 使用了范围条件，index3就会失效，下面这条语句就不会走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> index1 = xxx <span class="keyword">and</span> index2 &lt; xxx <span class="keyword">and</span> index3 = xxx;</span><br></pre></td></tr></table></figure></li></ul></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的内存管理</title>
      <link href="Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
      <url>Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　了解内存管理的意义、策略及页面置换算法 …</p></blockquote><ul><li><p><strong>为什么需要内存管理？</strong></p><p>　　没有内存管理，面向物理地址编程非常不安全，并且难以实现多个程序同时运行。如后面运行的程序B很有可能覆盖掉前面运行的程序A占有的某一块内存，从而造成A的崩溃。甚至某些不怀好意的程序可能会侵犯操作系统的地盘，引发操作系统的崩溃。</p><p>　　在这种情形下，人们还是想到了同时运行多个程序的办法：<strong>静态重定位</strong>。即在将程序装入内存之前，给程序中的每一个地址都加上该程序在内存中的首地址的偏移量，整体向后推移一段距离，只要内存够大，足以装下多个程序，他们就不会发生冲突。但显然就目前来看内存永远不可能够用，这时就要使用到<strong>虚拟内存</strong>管理的技术。</p><p>　　程序中不是所有的地址都可以按照静态重定位的方法处理，如使用到的一些关键寄存器的地址。这时就要求程序要提供额外的信息来说明这个地址要不要重定位，无疑提高了编程难度，加大了开发人员的负担。</p></li></ul><br><ul><li><strong>待解决的问题？</strong></li></ul><p>　　综上所述，可以看到想要同时运行多个程序，急需解决的两个问题是：<strong>内存保护</strong>和<strong>地址重定位</strong>。</p><p>　　下面为了引出<strong>地址空间</strong>的概念，简要说明<u>不使用虚拟内存与分页存储管理时</u>，是如何解决这两个问题的：</p><p>　　地址空间，可以类比变量的命名空间，每个进程都有自己独立的地址空间就好像独占了整块内存区域。但要保证不同地址空间的相同地址映射到物理内存时不会发生冲突，就要借助<strong>基址寄存器</strong>和<strong>界限寄存器</strong>，使用<strong>动态重定位</strong>的方法。</p><p>　　区别于静态重定位，动态重定位不需要在程序装载时改变程序中编写的内存地址，而是在执行每一条指令时利用两个关键寄存器中的值<strong>动态的算出</strong>实际地址。基址寄存器用于存放程序装载到内存的起始地址，界限寄存器存放程序的长度。避免了静态重定位的麻烦，但是显而易见的缺点是每次执行相关指令都要进行计算，所以为了加快速度，一般这个计算实际地址的过程由专门的硬件来负责。</p><p>　　这个硬件被称为<strong>内存管理单元</strong>（Memory Management Unit，MMU），MMU位于CPU和地址总线之间，会在CPU访存之前进行虚拟地址到物理地址的映射。即<strong>CPU看到的都是程序中实际编写的虚拟地址</strong>，而程序在内存中的真实地址是什么，由MMU借助两个寄存器中的值来动态计算并将地址发送到地址总线上。</p><p>　　界限寄存器指定了某程序所能访问的地址范围，访存时会与其进行比较，超出它的范围则拒绝访问，从而保证了其他程序的安全。</p><p>　　<strong>注：</strong>在<u>使用虚拟内存的分页存储管理中</u>，不需要使用这俩寄存器，而是使用<strong>页表</strong>来记录映射转换信息。</p><br><ul><li><strong>内存管理器 VS 内存管理单元？</strong></li></ul><p>　　内存管理器：记录哪些内存正在使用，哪些内存是空闲的，及时的分配和回收内存的管理程序。</p><p>　　内存管理单元：位于CPU和地址总线之间的硬件，用于处理CPU的访存请求，负责虚拟地址到物理地址的映射、内存保护、CPU高速缓存的控制等。</p><p>　</p><hr><a id="more"></a><h3 id="1-虚拟内存"><a href="#1-虚拟内存" class="headerlink" title="1. 虚拟内存"></a>1. 虚拟内存</h3><p>　　前面我们提到只要内存够大，只需使用静态重定位给每个程序分配足够的空间就行，那我们现在面临的问题都不再是问题。但显然内存不可能够用，当程序比内存大的时候就装不进去无法运行，这时候就提出了<strong>虚拟内存</strong>的概念。</p><p>　　虚拟内存是利用了程序在时间和空间上的<strong>局部性</strong>原理，将程序划分成若干碎片，按需不断地将碎片在内存和<strong>交换区</strong>间换入换出，让程序误认为它独享了连续的、和可寻址空间一样大的内存区域。</p><p>　　局部性：在一段时间内经常运行某些相同的代码片段；在空间上经常运行某些相同碎片上的代码片段。程序的局部性使得程序只装入部分就可以运行。</p><p>　　交换区：在磁盘上划分出的一片空闲区域，供正在活动的进程将其暂时不用的碎片换出。</p><p>　　区别于<strong>交换技术</strong>，交换技术每次内存中只保留一个程序，运行一段时间将正在运行的程序换出到磁盘，再将下一个程序换入内存，IO的这段时间CPU将空转。而有了虚拟内存，多个正在运行程序的部分碎片都同时存在于内存当中，当某个程序等待其他碎片换入时，切换到另一个程序运行，提高了CPU吞吐率。</p><hr><h3 id="2-内存管理策略"><a href="#2-内存管理策略" class="headerlink" title="2. 内存管理策略"></a>2. 内存管理策略</h3><blockquote><p>将重点说明分页、分段存储管理。</p></blockquote><h4 id="2-1-固定分区与可变分区"><a href="#2-1-固定分区与可变分区" class="headerlink" title="2.1 固定分区与可变分区"></a>2.1 固定分区与可变分区</h4><ul><li><p>固定分区：将内存分成若干固定大小的分区，大小可以不相同，当一个程序装入时选择一个合理大小的分区给它。缺点是容易产生内碎片，内存利用率不高。</p></li><li><p>可变分区：按照装入程序的实际大小给它分配内存空间，消灭了内碎片，但程序回收后留下的空白可能随着时间变得小而多，即产生外碎片，这时就需要耗时的内存整理操作。</p><p>　</p></li></ul><h4 id="2-2-分页存储管理"><a href="#2-2-分页存储管理" class="headerlink" title="2.2 分页存储管理"></a>2.2 分页存储管理</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/1rBke8VxhdTx.png" alt="分页存储管理"></p><p>　　<strong>分页</strong>：进程是操作系统分配资源的基本单位，分页就是将每个进程的逻辑地址空间分成若干<strong>大小相等</strong>的片，称为<code>页面</code>，同时物理内存也将被分成与页面大小相等的<code>页框</code>。分页存储管理的任务就是为一个个页面分配页框或回收页框，这个逻辑地址到物理地址的映射由MMU借助<code>页表</code>完成。</p><p>　　<strong>页表</strong>：记录页框的分配情况，借助页表MMU才能完成地址的映射；每个进程都有自己的页表，页表存放在内存中，一般为了加速还会在MMU中设立一个缓冲区，称为<strong>转换检测缓冲区</strong>（Translation Lookaside Buffer，TLB），用于缓存经常访问的页表项。</p><p>　</p><h5 id="2-2-1-映射工作的过程"><a href="#2-2-1-映射工作的过程" class="headerlink" title="2.2.1 映射工作的过程"></a>2.2.1 映射工作的过程</h5><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/RVFaoywmtLfs.png"></p><p>　　如上图一个64KB（2<sup>16</sup>）的进程被分成16（2<sup>4</sup>）个4KB（2<sup>12</sup>）的页面记录在页表中，页号作为索引。当CPU访存时，MMU将地址分为<strong>页地址</strong>和<strong>页内偏移地址</strong>两部分，前面4位页地址指示页号，后面12位页内偏移地址刚好指示一页内的可编程地址。</p><p>　　通过索引查询页表，判断该页在不在内存中：</p><p>　　若在，因为页框大小与页面大小一样，取出该页的页框号后面再添上页内偏移量即是真实的物理地址；</p><p>　　若不在，则会发生<code>缺页中断</code>，操作系统将负责把缺少的页面换入内存中，再重新执行刚才CPU发出的指令。若有空闲的页框，则直接放入所需页面即可；若无空闲的页框则需要使用页面调度算法选出一个页面换出以腾出一个页框。若换出的页面修改过，则需要<strong>刷脏页</strong>，将修改过的页面重新写回磁盘。</p><p>　</p><h5 id="2-2-2-页表中的信息"><a href="#2-2-2-页表中的信息" class="headerlink" title="2.2.2 页表中的信息"></a>2.2.2 页表中的信息</h5><p>　　从上面可以看出页表中需要<strong>页号</strong>、<strong>页框号</strong>、<strong>是否在主存中</strong>的标志位、<strong>是否修改过</strong>的标志位…</p><p>　　有了这几个信息，我们已经解决了前面提出的地址重定位问题，除此之外还有内存保护的问题，因此就需要一个标志位指示该页<strong>是否可读写</strong>。当然这只是访问类型上的保护，还有进程间的保护其实已经实现，因为<u>每个进程有自己独立的页表</u>。在这之上还有<code>页面共享</code>的问题，后面会记录。</p><p>　　还要置一个<strong>访问位</strong>，指示该页正在被使用，以防止某页面在被使用中时被换出。</p><p>　　最后必须的还需要一个<strong>是否允许高速缓存</strong>的标志，保证某些信息的时效性。</p><p>　</p><h5 id="2-2-3-多次访存问题"><a href="#2-2-3-多次访存问题" class="headerlink" title="2.2.3 多次访存问题"></a>2.2.3 多次访存问题</h5><p>　　分页在查询页表时多了一次访存操作，而前面overview中提到的重定位只需在程序装入前或者指令执行前加上一个偏移量即可。为了解决这个问题，我们在MMU中引入一块缓冲区来缓存经常访问的页表项，即<strong>转换检测缓冲区</strong>（Translation Lookaside Buffer，TLB），这一操作的合理性也源于程序的局部性原理。</p><p>　　TLB中缓存了常访问的、计算好的页面、页框号等信息。当CPU访存时MMU首先在TLB中查找，若命中则可以直接找到对应的页框，减少了一次访存；若没有命中则再去也表中查找，选择性的淘汰、更新TLB中的页表项信息。</p><p>　　进程切换时，TLB中的信息像CPU高速缓存中的信息一样都需要更新，这也是进程切换的一大开销。</p><p>　</p><h5 id="2-2-4-页面共享问题"><a href="#2-2-4-页面共享问题" class="headerlink" title="2.2.4 页面共享问题"></a>2.2.4 页面共享问题</h5><p>　　两个进程共享一部分页面可以避免内存中有一个页面的两份副本，提高内存的使用率。</p><p>　　如打开两个Word文档，这两个Word程序放置程序文本的页面应该是共享的（这些程序代码还是只读的），不同的只是各自的数据部分。两个不同的进程也有可能共享相同页面，如放置通用的图形用户界面组件的页面。</p><p>　　问题是：如何方便的划分出是否可以共享的页面？给每个页面设置一个共享标志位当然可以实现，但是页表的维护就变得复杂了。有一种方法在原有的分页管理基础上稍加改动就可以实现，即<strong>区分指令空间和数据空间</strong>。</p><p>　　将进程原来的地址空间一分为二，一份<strong>I空间</strong>存放程序文本，一份<strong>D空间</strong>存放数据，都从零开始编址，两个地址空间像两个进程一样进行独立的分页、映射，拥有各自独立的页表，还让该进程的可用地址空间加倍。上面提到的两个Word程序就可以方便的共享I空间。（后面的段页式内存管理的思想和这个很相似）</p><p>　　将共享的粒度放大一些，如动态链接库，在Windows中就是DLL文件，第一次被使用时以页面的形式被装载进内存，后面一个进程想要使用它时先判断它是否已经被装载，避免重复装载，达成共享。DDL的共享在页面层面上是如何实现的？其实DDL只是<code>内存映射文件</code>（memory mapped file）思想的一种应用实例。</p><p>　　内存映射文件的具体做法是：<strong>将一个磁盘文件映射到某个进程的地址空间内</strong>，文件不必全部及时装入内存，而是使用时装入所需的页面，就像使用虚拟内存一样。如果两个进程同时映射到一个文件，就达成了共享。除此之外利用这种内存映射的思想还可以进行进程间的通信。</p><p>　</p><h5 id="2-2-5-共享内存达成进程通信"><a href="#2-2-5-共享内存达成进程通信" class="headerlink" title="2.2.5 共享内存达成进程通信"></a>2.2.5 共享内存达成进程通信</h5><p>　　内存映射文件将磁盘文件映射到某个进程的地址空间，可以达到共享也可以达到进程间通信，如进程A对映射文件进行修改后，进程B可取到进程A修改后的信息，但显然这样经过了磁盘IO，不是我们想要的进程间直接通信。</p><p>　　我们可以利用这种内存映射的思想，将内存中的一块共享区域映射到两个进程中，实现进程间通信。好处就是不用经过内核缓冲区，数据不用经过额外的复制，直接读即可。但是也有坏处就是无法保证进程B会等待进程A写完才读，这时候就要用到信号量进行同步；还有就是这种通信方法是不安全的，如多个进程同时写就会发生冲突，难以协调。</p><p>　</p><h4 id="2-3-分段、段页式存储管理"><a href="#2-3-分段、段页式存储管理" class="headerlink" title="2.3 分段、段页式存储管理"></a>2.3 分段、段页式存储管理</h4><h5 id="2-3-1-分段存储管理"><a href="#2-3-1-分段存储管理" class="headerlink" title="2.3.1 分段存储管理"></a>2.3.1 分段存储管理</h5><blockquote><p>　　在分段存储管理方式中，作业的地址空间被划分为若干个段，<strong>每个段定义了一组逻辑信息</strong>。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。</p></blockquote><p>　　将程序和数据划分为逻辑上独立的地址空间，有助于共享和保护。但是缺点和非固定分区一样，会产生外碎片，需要耗时的内存整理。</p><h5 id="2-3-2-段页式存储管理"><a href="#2-3-2-段页式存储管理" class="headerlink" title="2.3.2 段页式存储管理"></a>2.3.2 段页式存储管理</h5><blockquote><p>　　段页式系统的基本原理，是基本分段存储管理方式和基本分页存储管理方式原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</p></blockquote><p>　　其实就是将页面按照其作用组织起来，非常类似于分页中将地址空间划分为 I空间 和 D空间，方便共享与保护，提升了可编址空间，但系统复杂性提高。</p><p>　</p><hr><h3 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3. 页面置换算法"></a>3. 页面置换算法</h3><p>　　页面置换的<code>最优算法</code>是想办法预测进程未来会使用的页，然后再进程执行之前将这些页调入内存中。</p><p>　　最优算法难以实现，于是按照不同的倾向有了下面三条线路：<code>FIFO</code>、<code>LRU</code>、<code>工作集算法</code>，在每一类算法上提出改进优化的方案又演变出不同的算法，最后综合了每一类的特性提出了最合理的算法。</p><p>　　<code>FIFO算法</code>像一个队列，每次都淘汰最老的页面，容易实现且比较公平，但有可能淘汰掉重要页面；于是在此之上有了<code>第二次机会算法</code>，改进了FIFO但链表操作比较耗时；<code>时钟算法</code>又对其进行改进但还不是最优的。</p><p>　　<code>LRU算法</code>比较符合最优算法的思想，但是难以实现，于是有了<code>NRU</code>、<code>NFU</code>算法，但还不是很有效，最后提出<code>老化算法</code>，已经是一个非常近似于LRU的高效算法。</p><p>　　<code>工作集算法</code>实现起来开销太大，于是综合了时钟算法提出了有效的<code>工作集时钟算法</code>。</p><p>　　综上所述，基于LRU的老化算法和基于工作集的时钟算法是比较好的算法。下面就分别记录一下这几种算法：</p><p>　</p><h4 id="3-1-FIFO"><a href="#3-1-FIFO" class="headerlink" title="3.1 FIFO"></a>3.1 FIFO</h4><ul><li><strong>FIFO算法</strong>：维护一个队列，新来的页面依次链入队尾，需要淘汰页面时就出队列。优点是方便、公平；缺点是容易淘汰重要页面。</li></ul><p>　</p><ul><li><p><strong>第二次机会算法</strong>：在FIFO算法上进行改进，使用了一个指示最近有没有被访问的标志位，避免了将经常使用的页面置换出去。</p><p>　　设标志位R=1指示最近被访问过，R=0指示最近没有被访问过。当一个页面被访问时，R置为1。当要淘汰页面时，判断队首页面的R值，若R＝0则直接淘汰，若R=1，则将R置0并将R出队列且链入队尾，当做是一个新来的页面，这就是所谓的第二次机会，然后再判断新的队首页面，重复该过程。显然缺点是链表操作降低了效率。</p></li></ul><p>　</p><ul><li><strong>时钟算法</strong>：和第二次机会算法相同，只是使用一个循环队列和一个指示当前最老页面的指针，这样避免了R=1时移动链表。</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/LhxS4PCkLcHr.png" alt="mark"></p><p>　</p><h4 id="3-2-LRU"><a href="#3-2-LRU" class="headerlink" title="3.2 LRU"></a>3.2 LRU</h4><p>　　由程序的局部性反推，我们可以知道很久没用的页面大概率在未来很长一段时间内也不会被使用，所以有了<strong>最近最少使用算法</strong>（Least Recently Used，LRU），非常接近最优的算法。</p><ul><li><strong>LRU算法</strong>：为了实现LRU算法，我们需要为内存中的所有页面维护一个有序的链表，每次访存都需要更新整个链表，代价十分之高。</li></ul><p>　</p><p>　　下面看两个LRU的裁剪版，NRU和NFU。设两个标志位R、M分别指示页面是否最近被使用、页面是否被修改过，周期性的将R置为0。</p><ul><li><p><strong>最近未使用算法</strong>（Not Recently Used，NRU）：根据这两个标志位将内存中的页面<strong>按照回收代价</strong>从低到高分为了四类：</p><p>　　1. 没有被访问，没有被修改；<br>  　　2. 没有被访问，已被修改；<br>  　　3. 已被访问，没有被修改；<br>  　　4. 已被访问，已被修改；</p><p>每次回收都在代价最小的一类中<u>随机挑选</u>一个淘汰。</p></li></ul><p>　　</p><ul><li><strong>最不常使用算法</strong>（Not Frequently Used，NFU）：为每个页面都关联一个计数器，每次时钟中断，都给所有的计数器加上页面的标志位R，计数器值越小说明最不常用。NFU的一个缺点就是<u>保留了太多历史因素</u>，如滞留在内存中的不常用页面，其计数器值可能比新载入内存的最近常用的页面的值还要高，从而不能及时被淘汰。</li></ul><p>　　</p><ul><li><strong>老化算法</strong>：非常巧妙的解决了NFU的问题，可以说是最接近LRU的算法。NFU的问题是往计数器上+R，造成历史因素影响较大，老化算法就及时的排除了这个历史因素，它在每次时钟中断时先将原始值右移一位，再将R值加在最左端形成新值。</li></ul><p>　　</p><h4 id="3-3-工作集"><a href="#3-3-工作集" class="headerlink" title="3.3 工作集"></a>3.3 工作集</h4><h5 id="3-3-1-定义与原理"><a href="#3-3-1-定义与原理" class="headerlink" title="3.3.1 定义与原理"></a>3.3.1 定义与原理</h5><p>　　<strong>工作集</strong>：一个进程当前正在使用的页面的集合称为该进程的工作集。</p><p>　　<strong>请求调页</strong>：一个进程刚启动时，内存中没有属于它的页面，于是在刚开始运行的一段时间内会发生频繁的缺页中断，每次中断都请求一个页面，一段时间后缺页中断的发生率会下降，这个过程就叫做请求调页。同时适用于某个进程已经运行过一段时间，被调度出去又被调度回来的情形。</p><p>　　<strong>预先调页</strong>：我们无法确切预测一个进程未来要使用哪些页，但是由于程序的局部性原理，我们知道一个进程在过去一段时间内使用的页在未来一段时间内也有很大概率被使用到。根据这个特点，我们可以断言<u>某个被调度回来的进程有很大概率要使用它被调度出去之前一段时间内所使用的页面</u>，即工作集。在该进程继续运行之前，预先调入推测的工作集页面，可以大大降低缺页中断的发生率，称为预先调页。</p><p>　　</p><h5 id="3-3-2-工作集页面置换算法"><a href="#3-3-2-工作集页面置换算法" class="headerlink" title="3.3.2 工作集页面置换算法"></a>3.3.2 工作集页面置换算法</h5><p>　　<strong>任务</strong>：我们现在的任务就是找到一个有效的办法推测出进程的工作集。有两种方案：</p><ol><li><p><strong>取进程最近 k 次访问过的页面集合</strong>，这个方案实现起来比较复杂且效率不高。</p><p>　　设想我们需要一个大于等于 k 的表依次记录最近使用的页面号，表满的时候就弹出最早的元素，当缺页中断时需要先读出最近k个页面号，再去重，即为工作集。找到工作集之后还没完，还要遍历页表找到一个不在工作集内的页面换出，去重、判断页面是否在工作集中都比较耗时。</p></li><li><p><strong>取最近 t 秒进程实际运行时间中访问过的页面集合</strong>，使用这个方案需要在页表项中额外记录一个信息指示上次使用该页面的近似时间。除了上次使用时间再设两个字段：R位指示是否最近被访问、M位指示是否被修改，定期自动将R位置0。流程如下：</p><p>　　<img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/xYgOI95eeDM3.png" alt="工作集算法"></p></li></ol><p>　　</p><p>　　缺页中断时，处理每个页表项，检查R位，<strong>若R=1</strong>，则修改上次使用时间为当前实际时间，即说明改页面正在被使用。（注意这一步，说明是在每次缺页中断时才更改时间）</p><p>　　<strong>若R=0</strong>，说明该页面最近没有被访问，则计算它的已生存时间，即当前时间减去上次使用时间，然后与规定的t 值作比较：</p><p>　　若<strong>生存时间 &gt; t</strong> 则说明已经挺久没有被使用了，不在工作集当中，可以被替换。这时还没有完，还要更新其他R=1的页表项的上次使用时间为当前实际时间，否则下一次缺页中断来临时会发现这些页面都会很老，即像NFU算法一样保留了历史因素。</p><p>　　若<strong>生存时间＜t</strong> 则说明它还在工作集内，应当保留，但我们要记住这种情况下页面的上次使用时间，找出一个上次使用时间最小的，即在工作集时间 t 内最久未用的一页。因为有可能发生这样的情况，当我们查找完页表后发现所有内存中的页面的在工作集当中，这时候我们就要淘汰一个最老的页面。与之相对应，还有一个最坏的情况就是所有页面都被访问过，即R=1，这时候就要随机选择一个被淘汰。</p><p>　　<strong>缺点：</strong>每次缺页中断都要扫描整个页表，因此效率是比较低的。</p><p>　　</p><h5 id="3-3-3-工作集时钟页面置换算法"><a href="#3-3-3-工作集时钟页面置换算法" class="headerlink" title="3.3.3 工作集时钟页面置换算法"></a>3.3.3 工作集时钟页面置换算法</h5><p>　　工作集时钟算法，融合了时钟算法与工作集算法。每次缺页中断时，先检查当前指针指向的页面，若R=1则将R置为0，更新上次使用时间，移动指针，继续判断。若R=0，则判断生存时间，大于 t 则可以被替换，小于 t 则在工作集内。若走了一圈又回到起点说明都在工作集内，由于不像工作集算法找到了最小的上次使用时间信息，所以这时候只得随机选一个页面被淘汰。</p><p>　　注意：前面不管是工作集还是工作集时钟算法，我们都是只考虑了指示最近是否被使用的 R 标志位，实际上我们还要考虑其他的因素，如是否被修改，像NRU算法一样找到替换的代价最小的页面进行替换，因为要替换一个脏页面，需要写回磁盘，就会引起进程的切换，浪费性能。</p><p>　　</p><p>　　<strong>总结：</strong>最有效的算法是老化算法和工作集时钟算法。老化算法淘汰了最不常用的页，从结果上来看符合最优算法；而工作集时钟算法预测了进程的工作集，不论是从过程还是从结果上看都非常接近最优算法。</p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Innodb 基础知识</title>
      <link href="Database/Innodb%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>Database/Innodb%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　了解MySQL的逻辑结构、SQL语句的执行过程等，重点了解Innodb在应用方面的一些原理和特性。其他还有一些索引、事务、日志等杂项的主要目的是先列个大纲，后面另起篇幅记录。</p><p>参考资料：《MySQL实战45讲》、《MySQL技术内幕》……</p></blockquote><a id="more"></a><h3 id="1-MySQL的逻辑结构"><a href="#1-MySQL的逻辑结构" class="headerlink" title="1. MySQL的逻辑结构"></a>1. MySQL的逻辑结构</h3><br><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200613134333333.png" alt="来自MySQL实战45讲" style="zoom:67%;" /><p>　　</p><p>　　如图是MySQL服务器的逻辑结构，主要分为两层，Server层和引擎层，两层分离，引擎以插件的形式向上提供服务。还有一点要注意的是引擎基于表而不是数据库。</p><p>　　下面列出每一部分的功能作用和要注意的小点：</p><ul><li><p><strong>连接器</strong>：负责与客户端建立连接、获取权限、维持和管理连接。</p><ol><li><p>用户名密码验证成功后，连接器会在权限表中查找该用户的权限作为此次连接时的权限，即便权限被更改，只要这次连接不断，权限就不改变。</p></li><li><p>使用<code>show processlist</code>命令可以查看目前所有的连接；</p></li><li><p>长连接长时间（默认8小时）空闲，连接器就会自动断开该链接；</p></li><li><p>长连接的缺点：每个连接中都保存了一些运行过程中使用的信息，久而久之占用内存越来越大。可以定期断开长连接，mysql5.7之后可以通过<code>mysql_reset_connection</code> 重置连接（不需要断开重连，只是恢复到刚刚连接的状态）。</p></li></ol></li><li><p><strong>查询缓存</strong>：以键值对的形式缓存近期执行的SQL语句和结果集。一个SQL到来时，会先在缓存中查找，若命中则可以将缓存的结果集直接返回。</p><ol><li>发生增删改操作，一张表的缓存就得失效，所以缓存比较适合很长时间才会更新静态表；</li><li>MySQL8.0将查询缓存这个模块直接去除掉了，大概是因为现在都会在业务层实现这个查询缓存，让数据库来实现查询缓存浪费了数据库服务器的性能。</li></ol></li><li><p><strong>分析器</strong>：包括<code>词法分析</code>和<code>语法分析</code>两部分。词法分析负责分析这条语句中的关键词都是什么，如表名、列名都存不存在，是否合法；语法分析主要负责判断sql语句是否符合语法。</p></li><li><p><strong>优化器</strong>：先<strong>判断权限</strong>，根据运行时的一些信息，选择MySQL认为的最优的执行计划，如使用那个索引，多表连接的顺序等。</p></li><li><p><strong>执行器</strong>：同样先判断该链接有没有相关权限，若有，则按照执行计划调用相关引擎的接口去执行查询。</p><ol><li>为什么优化器和执行器都要判断权限？我想是因为执行计划可以缓存，当使用到缓存的执行计划时，就没有经过前面的优化器判断权限，所以在执行之前判断权限是有必要的；</li><li>查询缓存命中，在结果返回之前也会判断权限。</li></ol></li></ul><br><hr><h3 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2. InnoDB"></a>2. InnoDB</h3><br><h4 id="2-0-InnoDB-vs-MyISAM"><a href="#2-0-InnoDB-vs-MyISAM" class="headerlink" title="2.0 InnoDB vs MyISAM"></a>2.0 InnoDB vs MyISAM</h4><ol><li>InnoDB 支持事务和外键，MyISAM不支持。</li><li>InnoDB 使用聚簇索引，主键索引的叶节点保存数据，辅助索引的叶节点保存主键信息，查询可能需要回表；MyISAM使用非聚簇索引，主键索引和辅助索引没有区别，叶节点保存的都是指向数据的指针，不用回表。</li><li>MyISAM 维护了表中的记录条数，所以 select count(*) 返回很快；InnoDB 没有保存记录条数，由于 MVCC，不同事务看到的记录数可能不一样。</li><li>InnoDB 支持的锁粒度到行锁，MyISAM 只支持到表锁，所以 MyISAM 的并发度没有 InnoDB 高。</li><li>日志方面 InnoDB 有自己的 redo log，而 bin log 是 server 层提供的，不属于引擎层。</li><li>MyISAM 支持全文索引，InnoDB在MySQL5.7后也支持全文索引。</li></ol><br><h4 id="2-1-InnoDB-逻辑存储结构"><a href="#2-1-InnoDB-逻辑存储结构" class="headerlink" title="2.1 InnoDB 逻辑存储结构"></a>2.1 InnoDB 逻辑存储结构</h4><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200613144446256.png" alt="InnoDB的逻辑存储结构" style="zoom: 80%;" /><p>　　</p><p>　　如上图所示，InnoDB的逻辑存储结构包括：<strong>表空间、段、区、页、行</strong>。类似操作系统内存管理中的段页式存储管理，InnoDB引擎将数据存放在表空间中，表空间中根据功能不同又有不同分段，如数据段、索引段、回滚段等，每一段中又进行分区，分区的目的是合理组织数据页，数据页中放的是真实的一行行数据。</p><ul><li><strong>表空间</strong></li></ul><p>　　需要注意的是MySQL5.6之前<code>innodb_file_per_table</code>参数默认为off，即使用innodb引擎创建的表，其数据、索引、日志信息、事务信息等都会存储在<code>ibdata1</code>这个共享表空间中。表结构还是存储在后缀为<code>.frm</code>的文件中。</p><p>　　将该参数设置为on，则会将数据和索引、插入缓冲位图（Insert Buffer Bitmap）分离出来存储在后缀为<code>.ibd</code>的文件中，表的其他信息还存在共享表空间中。</p><p>　　建议启用该参数，即将数据和索引分离出来存储。否则则可能会发生这样的现象：删了表中很大一部分数据，发现表空间大小没有多大变化，其实是因为删除后MySQL并不会去回收共享表空间中的碎片，只是标明了一下哪些页被删除，方便以后复用，因为磁盘整理是很耗时的。而如果将数据和索引分离出来，删除表时也会删除<code>.ibd</code>文件，回收空间。</p><ul><li><strong>段</strong></li></ul><p>　　将数据按照不同的类型，划分为数据段、索引段、回滚段等，段的目的是方便扩展，为区、页提供一个相对连续的空间，为程序的局部性原理服务，其中段的增长、页的分裂等由引擎本身维护。</p><ul><li><strong>区</strong></li></ul><p>　　段中的区可能不连续，但是一个区中的数据页一定是连续的，每个区都是固定 1 MB，InnoDB数据页默认16K，即一个区中有64个连续的数据页，<strong>每次IO都会申请4-5个区换入内存</strong>（局部性）。</p><ul><li><strong>页</strong></li></ul><p>　　默认16K，可以通过<code>innodb_page_size</code>设置其大小为4、8、16K，对一个库中的所有表都生效，并且不能再更该。</p><br><h4 id="2-2-InnoDB-内存管理"><a href="#2-2-InnoDB-内存管理" class="headerlink" title="2.2 InnoDB 内存管理"></a>2.2 InnoDB 内存管理</h4><p>　　这里说的内存管理主要是指InnoDB对<strong>缓冲区的管理</strong>。</p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200613191533027.png" alt="来自MySQL技术内幕" style="zoom:80%;" /><h5 id="2-2-1-数据页和索引页的缓存管理"><a href="#2-2-1-数据页和索引页的缓存管理" class="headerlink" title="2.2.1 数据页和索引页的缓存管理"></a>2.2.1 数据页和索引页的缓存管理</h5><p>　　InnoDB 缓冲区数据页的换入换出采用 LRU 算法，维护一个 LRU 列表，这个列表的最前端放最频繁使用的数据页，末端是最近最少使用的页，即要淘汰换出的目标页。</p><p>　　需要注意的是，每次换入新数据页的时候并不是直接插入列表的前端，而是放在<code>midpoint</code>位置，这个位置默认在LRU列表的5/8处，使用<code>innodb_old_blocks_pct</code>参数设置old区域的百分比（默认37，即3/8）。midpoint前面称为new区域，后面称为old区域。</p><p>　　为什么这样设计呢？设想这样一个场景，有一个<strong>冷门的查询</strong>要扫描大量数据，这时就要换入许多新的数据页，而这些数据页并不是热门数据，如果直接将它们链入LRU列表的头部，以前的热门数据页很有可能被换出，会使缓存的命中率降低。</p><p>　　使用<code>innodb_old_blocks_time</code>参数设置新数据页，需要多少毫秒会被加入到LRU列表的前端。</p><p>　　那当MySQL刚启动时，LRU列表是空的怎么办呢？其实内部还维护了一个FREE列表，新数据页过来先放入FREE列表，经过blocksTime后转入LRU列表。还有当LRU列表中的数据页脏了时后，会转入FLUSH列表，准备进行刷脏页。</p><p>　　</p><h5 id="2-2-2-redo-log的缓存管理"><a href="#2-2-2-redo-log的缓存管理" class="headerlink" title="2.2.2 redo log的缓存管理"></a>2.2.2 redo log的缓存管理</h5><p>　　redo log buffer不需要很大，因为后台线程会保证每秒将该缓冲区内容写入redo logo文件，同时当一个事务commit时、redo log buffer剩余空间少于1/2时，都会写入redo log文件。</p><ul><li>这里提到了redo log就稍微小记一下redo logo的特点：</li></ul><p>　　如果每次执行DML数据页变脏都要写回磁盘的话，那就有点奢侈了，而且刷盘的时候发生崩溃那内存中的数据就丢失了。所以 Innodb 采用<strong>Write-Ahead Log（WAL）策略</strong>，先写redo log再落盘。</p><p>　　提高了性能同时也保证了一定的安全性，崩溃后可以根据redo log中的<code>Checkpoint</code>指示的位置进行恢复。Checkpoint指示了是否已经刷盘的位置。</p><p>　　这里 redo log 还采用了<strong>两阶段提交</strong>确保和binlog的一致性。</p><p>　　</p><h5 id="2-2-3-其他缓存"><a href="#2-2-3-其他缓存" class="headerlink" title="2.2.3 其他缓存"></a>2.2.3 其他缓存</h5><p>　　像上图有的一些没提到的，如插入缓冲、锁信息、自适应hash索引、数据字典信息，后面多少会提到。</p><br><h4 id="2-3-InnoDB-一些特性"><a href="#2-3-InnoDB-一些特性" class="headerlink" title="2.3 InnoDB 一些特性"></a>2.3 InnoDB 一些特性</h4><br><h5 id="2-3-1-插入缓冲（Insert-Buffer"><a href="#2-3-1-插入缓冲（Insert-Buffer" class="headerlink" title="2.3.1 插入缓冲（Insert Buffer)"></a>2.3.1 插入缓冲（Insert Buffer)</h5><p>　　因为我们<strong>多数情况下</strong>都会使用自增主键，又由InnoDB索引的特点，我们知道维护主键索引时，插入一般都是在数据页中顺序存放的，不需要额外的随机访问。</p><p>　　这一特点不适用于uuid主键索引，同样也不适用于一般的辅助索引，言外之意就是有些辅助索引可以使用。当<strong>辅助索引不唯一时</strong>就可以使用插入缓冲，如一个日期类型的辅助索引。如果是唯一索引就得判断唯一约束，所以不能用。</p><p>　　维护这样的辅助索引，插入操作时，若命中缓存那直接插入没什么说的，若没有命中缓存，则先将这个插入放到Insert Buffer中。每隔一段时间将Insert Buffer和辅助索引数据页进行<strong>合并（merge）</strong>，以<strong>提升辅助索引的插入性能</strong>。</p><p>　　<strong>不唯一</strong>是因为：若是唯一索引，则进行判断时就得调入其他数据页。</p><ul><li><p><strong>何时merge？</strong></p><ol><li>后台主线程会根据最近的merge情况动态判断要不要再次进行merge。</li><li>当辅助索引数据页被调入缓存时，此时肯定是由于select造成的，所以调入相关数据页后进行merge，再返回select的数据。</li><li>当一次在辅助索引数据页上的插入检测到 Insert Buffer Bitmap 指示该辅助索引的数据页上可用空间不足1/32时，会触发强制merge。</li></ol></li><li><p><strong>Insert Buffer 的升级版：<code>Change Buffer</code></strong></p></li></ul><p>　　Insert Buffer只针对insert操作，Change Buffer则针对DML操作，适用的对象同样都是非唯一的辅助索引。同样，在访问相关数据页时和后台定期进行merge。</p><br><h5 id="2-3-2-两次写-Double-Write"><a href="#2-3-2-两次写-Double-Write" class="headerlink" title="2.3.2 两次写(Double Write)"></a>2.3.2 两次写(Double Write)</h5><p>　　目的是为了提高数据页的可靠性，因为redo log可能并不完全可靠，redo log记录的是物理页的变化，如果崩溃时造成了数据页的损坏，那即便是有redo log也是无力回天。</p><p>　　例如刷脏页的时候系统崩溃，磁盘上的数据页就会被污染，这时在被污染数据页上重放redolog中的操作，就是错上加错。</p><p>　　两次写，就是在磁盘上保存上 redo log 中 check point 所指向的时机的物理磁盘页状态，崩溃恢复的时候使用这个里面的数据页。</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/image-20200613221954326.png" alt="来自MySQL技术内幕"></p><br><h5 id="2-3-3-自适应哈希索引-Adaptive-Hash-Index"><a href="#2-3-3-自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="2.3.3 自适应哈希索引(Adaptive Hash Index)"></a>2.3.3 自适应哈希索引(Adaptive Hash Index)</h5><p>　　InnoDB会监控对数据页的查询，根据查询频率来为热门数据页动态建立哈希索引，提升索引的效率。注意只会对缓存中的数据页进行哈希。这个我们开发人员无法干预。</p><br><h5 id="2-3-4-异步-IO-Asynchronous-IO，AIO"><a href="#2-3-4-异步-IO-Asynchronous-IO，AIO" class="headerlink" title="2.3.4 异步 IO(Asynchronous IO，AIO)"></a>2.3.4 异步 IO(Asynchronous IO，AIO)</h5><p>　　同步IO每次请求IO操作都要阻塞，等待上一次同步IO请求完成。若想要连续请求多个数据页，那同步IO逐次请求效率就太低了，于是就有了AIO。可以在发出一个IO请求后不必等待响应，立即发送下一个请求，优势是可以对IO进行merge操作，例如将对连续数据页的AIO请求合并为一个大的IO请求一次性提交。</p><br><hr><h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><ul><li>MySQL中有B+树索引、全文索引、哈希索引，但不同引擎支持的索引有所不同：<ul><li>Memory引擎不支持事务，锁粒度最小为表锁，支持B+树索引、hash索引、不支持全文索引。</li><li>MyISAM 和InnoDB都支持B+树索引、全文索引，不支持hash索引。<ul><li>对于B+树索引而言，MyISAM的叶节点保存的是指针，而InnoDB的叶节点保存数据。</li><li>可以通过附加一个字段存放一个散列值来实现伪哈希索引。</li></ul></li></ul></li><li>需要知道：<ul><li>索引是怎么放的</li><li>索引的查询过程</li><li>各种不同查询条件下的查询过程是怎样的</li><li>聚簇索引、非聚簇索引……</li></ul></li><li>索引的使用要考虑：<ul><li>主键索引的长度</li><li>覆盖索引</li><li>最左前缀匹配</li><li>索引下推</li><li>索引失效的情况</li></ul></li></ul><br><hr><h3 id="4-事务、并发控制、锁"><a href="#4-事务、并发控制、锁" class="headerlink" title="4. 事务、并发控制、锁"></a>4. 事务、并发控制、锁</h3><ul><li>事务的ACDI特性</li><li>几种问题与隔离级别</li><li>MySQL的MVCC，如何解决幻读问题的</li><li>各种锁及加锁机制、锁的原理、两段锁协议</li></ul><br><hr><h3 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h3><ul><li>了解binlog、redo logo、WAL机制</li><li>了解日志的作用</li><li>了解错误日志、查询日志</li></ul><br><hr>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux与Nginx 入门</title>
      <link href="JavaEE/Back%20End/Linux%E4%B8%8ENginx.html"/>
      <url>JavaEE/Back%20End/Linux%E4%B8%8ENginx.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>Linux常用命令；部署项目到Tomcat；Nginx部署静态资源，负载均衡。</p></blockquote><a id="more"></a><h3 id="1-Linux-常用命令"><a href="#1-Linux-常用命令" class="headerlink" title="1. Linux 常用命令"></a>1. Linux 常用命令</h3><p><a href="https://www.runoob.com/linux/linux-command-manual.html">菜鸟教程Linux命令大全</a></p><h4 id="1-0-Linux目录结构"><a href="#1-0-Linux目录结构" class="headerlink" title="1.0 Linux目录结构"></a>1.0 Linux目录结构</h4><blockquote><p><a href="https://www.runoob.com/linux/linux-system-contents.html">摘自菜鸟教程</a></p><ul><li><p><strong>/boot：</strong>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件；</p></li><li><p><strong>/etc：</strong>存放所有的系统管理所需要的配置文件和子目录；</p></li><li><p><strong>/lib</strong>：存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库；</p></li><li><p><strong>/bin：</strong>存放着最常用的程序和指令；</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令；</p></li><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备；</p></li><li><p><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下；</p></li><li><p><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了；</p></li><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除；</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件；</p></li><li><p><strong>/tmp</strong>：存放一些临时文件；</p></li><li><p><strong>/root</strong>：系统管理员的用户主目录；</p></li><li><p><strong>/home</strong>：用户的主目录，以用户的账号命名；</p></li><li><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录；</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令；</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序；</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录；</p></li><li><p><strong>/var</strong>：存放经常被修改的数据，比如程序运行的日志文件（/var/log 目录下）；</p></li><li><p><strong>/proc</strong>、**/sys**：是虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息；</p></li><li><p><strong>/opt</strong>：额外安装软件所放的目录；</p></li><li><p><strong>/srv</strong>：存放一些服务启动之后需要提取的数据。</p></li></ul></blockquote><h4 id="1-1-文件相关操作"><a href="#1-1-文件相关操作" class="headerlink" title="1.1 文件相关操作"></a>1.1 文件相关操作</h4><ul><li>切换目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./  <span class="comment">#当前目录</span></span><br><span class="line">../ <span class="comment">#当前父目录</span></span><br><span class="line"><span class="built_in">cd</span> path <span class="comment">#进入path</span></span><br><span class="line"><span class="built_in">cd</span> ..   <span class="comment">#返回上一层</span></span><br><span class="line"><span class="built_in">cd</span> /    <span class="comment">#切换到根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~    <span class="comment">#切换到当前用户的主目录</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示当前所在路径</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><ul><li>列出文件目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls    <span class="comment">#列出该目录下文件</span></span><br><span class="line">ls -a <span class="comment">#列出该目录下所有文件，包括隐藏文件（文件名以 &#x27;.&#x27; 开头）</span></span><br><span class="line">ls -l <span class="comment">#列出该目录下文件的详细信息 缩写为ll</span></span><br><span class="line">du –h <span class="comment">#友好显示当前目录的大小</span></span><br></pre></td></tr></table></figure><ul><li>创建、移除文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dirName <span class="comment">#创建文件夹</span></span><br><span class="line">mkdir -p dirName1/dirName2 <span class="comment">#创建文件夹且自动创建父目录</span></span><br><span class="line">rmdir  dirName <span class="comment">#删除空的文件夹</span></span><br><span class="line">rm -r dirName  <span class="comment">#删除非空文件夹 -r意思是递归删除</span></span><br></pre></td></tr></table></figure><ul><li>打开文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat fileName  <span class="comment">#显示文件内容</span></span><br><span class="line">more fileName <span class="comment">#显示长文件内容</span></span><br><span class="line">less fileName <span class="comment">#同上</span></span><br><span class="line">tail fileName <span class="comment">#默认显示最后几行</span></span><br><span class="line">tail -10 fileName <span class="comment">#显示最后10行</span></span><br><span class="line">tail -f fileName  <span class="comment">#动态查看文件（文件更新会自动变化）</span></span><br></pre></td></tr></table></figure><ul><li>文件操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">touch fileName <span class="comment">#创建一个空文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---删除操作---</span></span><br><span class="line">rm fileName    <span class="comment">#删除文件</span></span><br><span class="line">rm -f fileName <span class="comment">#直接删除文件不询问</span></span><br><span class="line">rm -rf *       <span class="comment">#清理缓存（滑稽） </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---复制剪切---</span></span><br><span class="line">cp a.txt aaa/b.txt <span class="comment">#复制a.txt到aaa路径下命名为b.txt</span></span><br><span class="line">mv a.txt aaa/b.txt <span class="comment">#剪切a.txt到aaa路径下命名为b.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---打包解压---</span></span><br><span class="line">  <span class="comment"># linux 中打包文件以.tar为后缀，压缩文件以.gz结尾</span></span><br><span class="line">  <span class="comment">#参数：</span></span><br><span class="line">    <span class="comment">#-c 创建一个新的tar文件 </span></span><br><span class="line">    <span class="comment">#-x 解开tar文件</span></span><br><span class="line">    <span class="comment">#-v 显示过程信息</span></span><br><span class="line">    <span class="comment">#-f 指定文件名</span></span><br><span class="line">    <span class="comment">#-z 调用gzip进行压缩</span></span><br><span class="line"></span><br><span class="line">tar –cvf a.tar afile <span class="comment">#打包afile文件为a.tar</span></span><br><span class="line">tar –zcvf a.tar.gz afile <span class="comment">#压缩afile文件为a.tar.gz</span></span><br><span class="line"></span><br><span class="line">tar –xvf a.tar              <span class="comment">#解包a.tar</span></span><br><span class="line">tar –zxvf a.tar.gz  -C /path <span class="comment">#解压缩a.tar.gz到指定位置</span></span><br></pre></td></tr></table></figure><ul><li>搜索查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.c&quot;</span>     <span class="comment">#查找当前目录下name以.c结尾的文件</span></span><br><span class="line">grep xxx a.txt --color <span class="comment">#在a.txt文件中查找xxx并高亮显示</span></span><br></pre></td></tr></table></figure><ul><li>重定向输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat a.log &gt; b.txt  <span class="comment">#将输出覆盖到b.txt</span></span><br><span class="line">cat a.log &gt;&gt; b.txt <span class="comment">#将输出追加到b.txt</span></span><br></pre></td></tr></table></figure><ul><li>管道</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个命令的输出作为下一个命令的输入</span></span><br><span class="line">cat index.html | more</span><br></pre></td></tr></table></figure><h4 id="1-2-用户和文件权限相关"><a href="#1-2-用户和文件权限相关" class="headerlink" title="1.2 用户和文件权限相关"></a>1.2 用户和文件权限相关</h4><ul><li>用户创建、删除、切换</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">who <span class="comment">#显示当前登录的用户信息</span></span><br><span class="line">useradd foo               <span class="comment">#添加foo用户</span></span><br><span class="line">groupadd <span class="built_in">test</span>  <span class="comment">#创建一个名为test的组</span></span><br><span class="line">groupdel <span class="built_in">test</span>  <span class="comment">#删除test组，必须先删除其中的用户</span></span><br><span class="line">useradd foo –g <span class="built_in">test</span>       <span class="comment">#创建用户并指定组</span></span><br><span class="line">useradd foo -d /home/foo  <span class="comment">#指定用户home目录</span></span><br><span class="line">passwd foo                <span class="comment">#为用户foo设置密码</span></span><br><span class="line"></span><br><span class="line">su foo          <span class="comment">#切换到foo用户</span></span><br><span class="line">su - root       <span class="comment">#切换用户，连同环境一起切换</span></span><br><span class="line">userdel foo     <span class="comment">#删除foo用户</span></span><br><span class="line">userdel –r <span class="built_in">test</span> <span class="comment">#删除foo用户及其用户目录</span></span><br><span class="line">sudo xxx     <span class="comment">#以管理员权限执行命令</span></span><br></pre></td></tr></table></figure><ul><li>文件权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - --- --- --- 10字符分为四组</span></span><br><span class="line"><span class="comment"># d rwd rwd rwd </span></span><br><span class="line">  <span class="comment">#第一组表示文件类型：</span></span><br><span class="line">    <span class="comment">#- 表示普通文件</span></span><br><span class="line">    <span class="comment">#d 表示文件夹</span></span><br><span class="line">    <span class="comment">#l 表示链接</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">  <span class="comment">#其他三组分别表示当前用户权限，当前用户所属组的权限，其他用户的权限</span></span><br><span class="line">    <span class="comment">#r 可读　  4</span></span><br><span class="line">    <span class="comment">#w 可写　  2</span></span><br><span class="line">    <span class="comment">#d 可执行  1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 改变文件权限：</span></span><br><span class="line">chmod u=rwx,g=rx,o=rx a.txt</span><br><span class="line">chmod 755 a.txt </span><br></pre></td></tr></table></figure><h4 id="1-3-其他命令"><a href="#1-3-其他命令" class="headerlink" title="1.3 其他命令"></a>1.3 其他命令</h4><ul><li>网络相关</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig  <span class="comment">#显示网络设备</span></span><br><span class="line">netstat -an | grep 3306 <span class="comment">#查询3306端口占用情况</span></span><br></pre></td></tr></table></figure><ul><li>系统相关</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df   <span class="comment">#显示磁盘信息</span></span><br><span class="line">free <span class="comment">#显示内存状态</span></span><br><span class="line">top  <span class="comment">#显示，管理执行中的程序</span></span><br><span class="line">ps –ef  <span class="comment">#查看所有进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 3306  <span class="comment">#强制杀死3306进程</span></span><br><span class="line">hostname <span class="comment">#查看当前主机名，在/etc/sysconfig/network中修改</span></span><br><span class="line">uname -a <span class="comment">#显示本机详细信息 </span></span><br></pre></td></tr></table></figure><hr><h3 id="2-Linux-软件安装"><a href="#2-Linux-软件安装" class="headerlink" title="2. Linux 软件安装"></a>2. Linux 软件安装</h3><h4 id="2-1-文件传输"><a href="#2-1-文件传输" class="headerlink" title="2.1 文件传输"></a>2.1 文件传输</h4><ul><li>使用SecureFX从左到右从未失手：</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/P8E3wEaeAqcq.png" alt="mark"></p><h4 id="2-2-软件安装"><a href="#2-2-软件安装" class="headerlink" title="2.2 软件安装"></a>2.2 软件安装</h4><blockquote><p>针对不同的情况有 rpm、yum、解压缩、手动编译等方式……</p><p>rpm 不会自动安装依赖；</p><p>yum会自动安装所需依赖；</p><p>有些软件已经是一个二进制包了，我们解压缩即可；</p><p>有些软件只会提供源码，所以需要我们手动编译打包。</p></blockquote><h5 id="1-安装-JDK"><a href="#1-安装-JDK" class="headerlink" title="1. 安装 JDK"></a>1. 安装 JDK</h5><blockquote><p>这个属于直接解压缩方式</p></blockquote><ul><li>先把自带的OpenJdk干掉</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java     <span class="comment"># 查询所有和java有关的软件</span></span><br><span class="line">rpm -e --nodeps xxx xxx <span class="comment">#xxx 把要卸载的名字都粘过来</span></span><br></pre></td></tr></table></figure><ul><li>解压缩后记住路径，在/etc/profile目录下添加环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/src/java/jdk1.8.0_251</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib.tools.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure><ul><li>执行命令使配置生效，验证是否成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/6QUjTl71UuoF.png" alt="mark"></p><h5 id="2-安装-MySQL"><a href="#2-安装-MySQL" class="headerlink" title="2. 安装 MySQL"></a>2. 安装 MySQL</h5><blockquote><p>这次使用rpm方式，下载相应的rpm包，需要安装server端和client端</p></blockquote><ul><li>检查卸载自带的mysql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql <span class="comment"># mariadb</span></span><br><span class="line">rpm -e --nodeps xxx</span><br><span class="line"><span class="comment"># CentOS 7 要删除mariadb，不然有可能会有问题，坑。 </span></span><br></pre></td></tr></table></figure><ul><li>安装并启动服务、修改root用户密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">mysqladmin -u root password <span class="string">&#x27;new-password&#x27;</span></span><br><span class="line">mysql -uroot -p <span class="built_in">pwd</span> <span class="comment">#成功</span></span><br></pre></td></tr></table></figure><ul><li>远程连接问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 授权可以远程链接</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;  WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h5 id="3-安装-Tomcat"><a href="#3-安装-Tomcat" class="headerlink" title="3. 安装 Tomcat"></a>3. 安装 Tomcat</h5><ul><li><p>开启./startup.sh，访问8080端口看能不能出来Tomcat</p></li><li><p>访问不了的话要关闭防火墙</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CentOS 7 下关闭防火墙并关闭自启</span></span><br><span class="line">systemctl stop firewalld.service </span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h5 id="4-安装-redis"><a href="#4-安装-redis" class="headerlink" title="4. 安装 redis"></a>4. 安装 redis</h5><blockquote><p>编译安装方式</p></blockquote><ul><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++ <span class="comment">#安装gcc</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.0.4.tar.gz <span class="comment">#获取redis</span></span><br><span class="line">tar -zxvf redis-3.0.4.tar.gz <span class="comment">#解压</span></span><br><span class="line"><span class="built_in">cd</span> redis-3.0.4 <span class="comment">#进入目录</span></span><br><span class="line">make <span class="comment">#编译</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/src/redis install<span class="comment">#安装到指定目录</span></span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动server</span></span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="comment"># 切换一个窗口启动client</span></span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure><h5 id="5-安装nginx"><a href="#5-安装nginx" class="headerlink" title="5. 安装nginx"></a>5. 安装nginx</h5><blockquote><p>源码编译安装，但是要先Makefile</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一些依赖环境</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">yum install -y openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩Nginx包后cd进去执行下面的命令创建Makefile</span></span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/<span class="built_in">log</span>/nginx/error.log \</span><br><span class="line">--http-log-path=/var/<span class="built_in">log</span>/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make <span class="comment">#编译</span></span><br><span class="line">make install<span class="comment">#安装到指定目录</span></span><br><span class="line">mkdir /var/temp/nginx/client <span class="comment">#创建工作目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动，访问80端口验证</span></span><br><span class="line">./nginx</span><br><span class="line">./nginx -s stop <span class="comment">#强制关闭</span></span><br><span class="line">./nginx -s quit <span class="comment">#正常退出</span></span><br><span class="line">./nginx -s reload <span class="comment">#重新加载配置文件</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-部署项目到Tomcat"><a href="#3-部署项目到Tomcat" class="headerlink" title="3. 部署项目到Tomcat"></a>3. 部署项目到Tomcat</h3><ol><li>直接将项目放到<code>/webapps</code>下,  项目名称就是访问的虚拟路径,  通常会将项目打成一个<code>war</code>包放置在<code>/webapps</code>下.</li><li>在<code>/conf/server.xml</code>的<code>&lt;Host&gt;</code>标签中配置<strong>资源路径</strong>和<strong>虚拟路径</strong>:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:/HelloTomcat&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>/conf/Catalina/localhost</code>下创建以<strong>虚拟路径命名</strong>的xml文件,  文件内容为<strong>资源路径</strong>:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:/hello tomcat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br><hr><h3 id="4-Nginx"><a href="#4-Nginx" class="headerlink" title="4. Nginx"></a>4. Nginx</h3><h4 id="4-1-部署静态资源"><a href="#4-1-部署静态资源" class="headerlink" title="4.1 部署静态资源"></a>4.1 部署静态资源</h4><ul><li>核心配置文件 <code>conf/nginx.conf</code></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/YtsLd228K1Me.png" alt="mark"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;<span class="comment">#监听的端口</span></span><br><span class="line">    server_name  localhost; <span class="comment">#监听的域名</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;<span class="comment">#资源路径，相对路径为nginx/</span></span><br><span class="line">        index  index.html index.htm;<span class="comment">#响应的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html&#123;</span><br><span class="line">    root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-负载均衡"><a href="#4-2-负载均衡" class="headerlink" title="4.2 负载均衡"></a>4.2 负载均衡</h4><blockquote><p>正向代理隐藏了真正的客户端，反向代理隐藏了真正的服务端。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">upstream uniqueName&#123; <span class="comment"># 名称随意</span></span><br><span class="line">server ip1:port weight=2;</span><br><span class="line">    server ip2:port;</span><br><span class="line">    server ip3:port;</span><br><span class="line"><span class="comment"># weight 默认为1，即上面三个server被访问到的概率为2:1:1</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;<span class="comment">#监听的端口</span></span><br><span class="line">    server_name  localhost; <span class="comment">#监听的域名</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#root   html;#这个不要了换成下面的一行</span></span><br><span class="line">        proxy_pass: http://uniqueName;</span><br><span class="line">        index  index.html index.htm;<span class="comment">#默认响应的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html&#123;</span><br><span class="line">    root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>几个负载均衡策略：<ul><li>轮询：默认方式，可以带权重；</li><li>ip_hash：使用 hash 算法使相同 IP 多次访问可以分配到相同服务器上；</li><li>fair：第三方，根据后台服务器响应时间动态地调整，响应时间短的优先分配；</li><li>url_hash：第三方，对访问的url进行hash以分配服务器，适合缓存服务器；</li><li>sticky session：第三方，根据cookie将同一用户的多次访问分配到同一服务器，和ip_hash相比更加均匀。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门</title>
      <link href="JavaEE/Back%20End/Docker.html"/>
      <url>JavaEE/Back%20End/Docker.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　Docker 是一个运行在Linux上的轻量级、可移植的<strong>容器</strong>，它允许我们根据镜像创建一个容器来运行我们的应用程序。</p></blockquote><p>　　为什么要使用容器？容器最大的作用就是便于隔离、扩展与移植。隔离文件资源、硬件资源、网络资源等等。Docker允许我们可以方便的实时扩展或删除应用程序与服务，可以使用<code>Dockerfile</code>编辑镜像实现快速的修改移植。</p><p>　　我们应该都有过这样的体验，自己编译调试写好的代码，把工程文件拿到其他地方去运行有时候总会出现莫名其妙的问题。多数情况下可能都是软件版本的差异造成的不兼容，这种情况还比较好处理，而有时候可能就是系统环境导致的不兼容。试想一下开发过程中还要涉及到很多其他环节和人员，很容易出现彼此环境不一致的情况，而使用Docker就能很好地解决这个问题，开发测试等各环节的环境保持一致，大大减少了交流成本。</p><p>　　我们可能还会想到使用虚拟机，那么VM与容器的区别在哪里？如图：<br><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/gef9KxVWdRfg.png" alt="虚拟机 vs 容器"></p><p>　　我们知道操作系统包括内核与系统调用，内核负责管理硬件资源，而系统调用相当于是对外提供的接口。<strong>左图中</strong>：VM 在虚拟化的时候，也会对硬件资源进行虚拟化，每一个Guest OS都在Host OS上虚拟出了各自的内核与硬件资源。而Guest OS 在运行当中还是要依赖于虚拟机软件与Host OS，这么来看的话是不是虚拟就像是多下了一道功夫一样，为什么不直接申请使用Host OS的资源呢。容器就是这样做的；<strong>右图中</strong>：可以看到只有一个Host OS，容器相当于是一个进程，它可以直接申请使用Host OS的资源。简言之就是VM是在宿主机操作系统上又虚拟了一层操作系统，而Docker则是直接利用宿主机操作系统的资源。</p><a id="more"></a><h3 id="1-Hello-Docker"><a href="#1-Hello-Docker" class="headerlink" title="1. Hello Docker"></a>1. Hello Docker</h3><blockquote><p>环境 CentOS 7.x</p></blockquote><ul><li>更新 yum 包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update </span><br></pre></td></tr></table></figure><ul><li>安装依赖的包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ul><li>设置 yum源为aliyun</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager  --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><ul><li>验证安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><ul><li>设置Docker镜像下载地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">添加如下内容：</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动和停止Docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl stop docker</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">自启动：sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><h4 id="2-1-镜像"><a href="#2-1-镜像" class="headerlink" title="2.1 镜像"></a>2.1 镜像</h4><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">docker images</td><td align="left">查看镜像</td></tr><tr><td align="left">docker search centos</td><td align="left">搜索镜像</td></tr><tr><td align="left">docker pull id</td><td align="left">拉取镜像</td></tr><tr><td align="left">docker rmi id<br>docker rmi `docker images -q`</td><td align="left">删除一个镜像<br>删除所有镜像<br />无法删除有实例正在运行的镜像</td></tr></tbody></table><h4 id="2-2-容器"><a href="#2-2-容器" class="headerlink" title="2.2 容器"></a>2.2 容器</h4><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">docker ps<br/>docker ps -a</td><td align="left">查看正在运行<br/>查看所有容器</td></tr><tr><td align="left">docker run<br/>参数：<br/>　　-i<br/>　　-t<br />　　–name<br />　　-v 宿主机目录:容器目录<br />　　-d<br />　　-p 宿主机端口:容器端口</td><td align="left">创建容器<br/><br/>　　创建时运行容器<br />　　容器启动后进入命令行<br />　　容器命名<br />　　建立目录映射关系<br />　　创建一个守护式容器在后台运行<br />　　建立端口映射</td></tr><tr><td align="left">docker start id<br/>docker stop id</td><td align="left">启动与停止容器</td></tr><tr><td align="left">docker inspect id</td><td align="left">查看容器信息</td></tr><tr><td align="left">docker rm id</td><td align="left">删除容器<br />无法删除正在运行的容器</td></tr><tr><td align="left">docker cp source dest</td><td align="left">文件拷贝</td></tr></tbody></table><p><strong>举例：</strong></p><ul><li>交互创建：exit后自动停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=mycentos centos:7 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>守护创建：exit后不会停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mycentos2 centos:7</span><br><span class="line">docker <span class="built_in">exec</span> -it mycentos2 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>目录与端口映射：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /user/<span class="built_in">local</span>/vtest:/user/<span class="built_in">local</span>/vtest --name=mycentos3 centos:7</span><br><span class="line">docker run -di --name=my_redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><ul><li>文件拷贝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp test.conf mycentos:/usr/<span class="built_in">local</span></span><br><span class="line">docker cp mycentos/usr/<span class="built_in">local</span>/test.conf test.conf</span><br></pre></td></tr></table></figure><h4 id="2-3-备份与恢复"><a href="#2-3-备份与恢复" class="headerlink" title="2.3 备份与恢复"></a>2.3 备份与恢复</h4><ul><li>容器 –&gt; 镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit mycentos mycentos_2</span><br></pre></td></tr></table></figure><ul><li>镜像备份</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o mycentos_3.tar mycentos_2</span><br></pre></td></tr></table></figure><ul><li>镜像恢复</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mycentos_3.tar</span><br></pre></td></tr></table></figure><h4 id="2-4-常用环境部署"><a href="#2-4-常用环境部署" class="headerlink" title="2.4 常用环境部署"></a>2.4 常用环境部署</h4><ol><li><p>MySQL部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拉取镜像 docker pull centos/mysql-57-centos7</span><br><span class="line">创建容器 docker run -di --name=my_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></li><li><p>tomcat部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br><span class="line">docker run -di --name=my_tomcat -p 9090:8080 -v /user/<span class="built_in">local</span>/webapps:/user/<span class="built_in">local</span>/tomcat/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure></li><li><p>nginx部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br><span class="line">docker run -di --name=my_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure></li><li><p>redis部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line">docker run -di --name=my_redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3. Dockerfile"></a>3. Dockerfile</h3><blockquote><p> 是一系列命令和参数构成的脚本。</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量</td></tr><tr><td>RUN command</td><td>dockerfile核心部分</td></tr><tr><td>ADD source dest</td><td>将宿主机文件复制到容器内,会自动解压</td></tr><tr><td>COPY source dest</td><td>和ADD类似,但不会自动解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><ul><li><strong>部署JDK8为例</strong></li></ul><ol><li><p>创建一个文件夹并把 jdk8 压缩包拷贝进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/dockerjdk8</span><br></pre></td></tr></table></figure></li><li><p>创建一个名为Dockerfile的文件</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><ol start="3"><li>开始输入命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM centos7 指定基础镜像</span><br><span class="line">MAINTAINER khy 指定镜像的创建者</span><br><span class="line">WORKDIR /usr 设置工作目录</span><br><span class="line">RUN mkdir /usr/<span class="built_in">local</span>/java</span><br><span class="line">ADD jar包 /usr/<span class="built_in">local</span>/java/</span><br><span class="line"></span><br><span class="line">配环境变量：</span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/java/jdkbalabala</span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/bin.dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar: <span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">开始构建：</span><br><span class="line">docker build -t=<span class="string">&#x27;jdk1.8&#x27;</span> . </span><br><span class="line">-t 指定镜像名称，`.` 代表指定Dockerfile在当前文件夹</span><br><span class="line">使用docker images命令验证是否成功</span><br></pre></td></tr></table></figure><h3 id="4-私有仓库"><a href="#4-私有仓库" class="headerlink" title="4. 私有仓库"></a>4. 私有仓库</h3><blockquote><p>仓库本身也是一个镜像</p></blockquote><ul><li>使用步骤</li></ul><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></li><li><p>启动仓库容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myregistry -p 5000:5000</span><br></pre></td></tr></table></figure></li><li><p>访问端口下的 /v2/_catalog 能看到一个json串则成功</p></li><li><p>修改配置文件daemon.json让docker信任私有仓库地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi etc/docker/daemon.json </span><br><span class="line">添加一段配置：</span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;ip:端口号(5000)&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>重启服务 </p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="6"><li>将镜像上传到私有仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag jdk1.8 ip:端口号&#x2F;jdk1.8</span><br><span class="line">docker push ip:端口号&#x2F;jdk1.8</span><br><span class="line">访问端口下&#x2F;v2&#x2F;_catalog 验证</span><br></pre></td></tr></table></figure><ol start="7"><li><p>从仓库下载<br>首先在daemon.json中添加信任，然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ip:端口号/jdk1.8</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 入门</title>
      <link href="Database/Redis%E5%85%A5%E9%97%A8.html"/>
      <url>Database/Redis%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　Redis（Remote Dictionary Server 远程字典服务） 是一个由C语言编写、开源、支持网络、可持久化、key-value形式的NoSQL数据库。</p></blockquote><p>　　NoSQL（Not Only SQL）意为不仅仅是SQL，泛指非关系型数据库。传统的关系型数据库在互联网行业日新月异的发展下，显示出了一些难以克服的问题，例如海量数据的高效率存储、高并发的读写、高可扩展性等问题，NoSQL就是为了弥补这些问题而诞生的。<br>　　NoSQL按照其存储数据的格式可以分为：键值对存储、列存储、文档型存储、图形存储。具体可看下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/EbbtlN0pOJ6f.png" alt="Redis 数据结构"><br>　　为什么说NoSql是对关系型数据库的弥补，因为他们是相互补充而不是对立的关系。我们从他们各自的优缺点就可以看出来：Sql（关系型数据库）提供对事务的支持，NoSql对事务不友好；Sql 可以实现多表之间的复杂查询，但也意味着表间关系复杂导致不容易扩展，NoSql 中的数据耦合性低非常容易扩展；Sql 读写效率不如NoSql，因为Sql数据存在硬盘中，而NoSql存在主存中，磁盘的IO对读写效率影响非常大。<br>　　Redis就是属于第一种key-value型，他支持的数据类型包含：String，Hash，List，Set，SortedSet。应用场景：缓存热门内容、排行榜、在线好友列表、任务队列、网站访问统计、数据过期处理、分布式集群架构中session的分离。</p><a id="more"></a><h3 id="1-Hello-Redis"><a href="#1-Hello-Redis" class="headerlink" title="1. Hello Redis"></a>1. Hello Redis</h3><blockquote><p>更多命令参考<a href="https://www.runoob.com/redis/redis-commands.html">https://www.runoob.com/redis/redis-commands.html</a><br>下面只列出常用的</p><p>端口：6379</p></blockquote><h4 id="1-0-Key-类型"><a href="#1-0-Key-类型" class="headerlink" title="1.0 Key 类型"></a>1.0 Key 类型</h4><ul><li>列出所有符合条件的key ：keys 表达式<ul><li>例如 keys *  列出所有key</li></ul></li><li>删除：del key</li><li>是否存在：exists key</li><li>获取某key的value的类型：type key</li></ul><h4 id="1-1-String-类型"><a href="#1-1-String-类型" class="headerlink" title="1.1 String 类型"></a>1.1 String 类型</h4><ul><li>存储： set key value</li><li>获取： get key</li><li>删除： del key</li></ul><h4 id="1-2-Hash-类型"><a href="#1-2-Hash-类型" class="headerlink" title="1.2 Hash 类型"></a>1.2 Hash 类型</h4><blockquote><p>是一个map格式</p></blockquote><ul><li>存储：hset key field value</li><li>获取：hget key field、hgetall key</li><li>删除：hdel key field1 field2 …</li></ul><h4 id="1-3-List-类型"><a href="#1-3-List-类型" class="headerlink" title="1.3 List 类型"></a>1.3 List 类型</h4><blockquote><p>有序可重复</p></blockquote><ul><li>存储<ul><li>存到首位：lpush key value</li><li>存到末位：rpush key value</li></ul></li><li>获取：lrange key start end<ul><li>获取所有：lrange key 0 -1</li></ul></li><li>弹出<ul><li>弹出首位：lpop key</li><li>弹出末位：rpop key</li></ul></li></ul><h4 id="1-4-Set-类型"><a href="#1-4-Set-类型" class="headerlink" title="1.4 Set 类型"></a>1.4 Set 类型</h4><blockquote><p>无序，不可重复</p></blockquote><ul><li>存储：sadd key value</li><li>获取：smembers key</li><li>删除：srem key value</li></ul><h4 id="1-5-SortedSet-类型"><a href="#1-5-SortedSet-类型" class="headerlink" title="1.5 SortedSet 类型"></a>1.5 SortedSet 类型</h4><blockquote><p>有序，不可重复，每一项都会关联一个double型的分数，通过分数从小到大排序</p></blockquote><ul><li>存储：zadd key score value</li><li>获取：srange key start end (withscores)<ul><li>可选项withscores 会打印出每一项的分数</li></ul></li><li>删除：zrem key value</li></ul><h4 id="1-6-中文问题"><a href="#1-6-中文问题" class="headerlink" title="1.6 中文问题"></a>1.6 中文问题</h4><ul><li>获取时加上参数<code>--raw</code>解决</li></ul><h3 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h3><blockquote><p>将主存中的数据按照配置持久化到硬盘中，redis 持久化提供了RDB和AOF两种机制。</p></blockquote><ol><li><p>RDB机制（default）：在一定的时间内监测key的变化，按照制定好的规则进行持久化操作，粒度较大。</p><ul><li>在<code>redis.windows.conf</code>文件中进行配置：</li><li><strong>注意</strong>：重启服务时要指定配置文件名称；</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">save 900 1</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">save 300 10</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ol start="2"><li>AOF机制：用日志记录每一条操作命令，粒度小。<ul><li>在<code>redis.windows.conf</code>文件中进行配置：</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly no 改为 yes 开启</span><br><span class="line"># appendfsync always ： 每一次操作都进行持久化</span><br><span class="line">appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line"># appendfsync no ： 不进行持久化</span><br></pre></td></tr></table></figure><h3 id="3-Jedis-使用"><a href="#3-Jedis-使用" class="headerlink" title="3. Jedis 使用"></a>3. Jedis 使用</h3><blockquote><p>API 名称和命令大同小异，靠着ide的提示就能写的出来，不再记录。</p><p>jedis-2.7.0.jar</p><p>commons-pool2-2.3.jar</p></blockquote><ul><li>不使用连接池：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 获取连接</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="number">2.</span> 执行操作</span><br><span class="line">jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="number">3.</span> 释放连接</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><ul><li>Jedis连接池配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">&quot;host&quot;</span>),Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.jedisPoll.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础语法</title>
      <link href="Database/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
      <url>Database/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><ul><li><p>SQL的分类</p><ul><li>数据控制语言（Data Control Language，DCL）：控制用户的权限；</li><li>数据定义语言（Data Definition Language，DDL）：定义数据库、表、列、索引等数据库对象；</li><li>数据操纵语言（Data Manipulation Language，DML）：增删改(查)操作；</li><li>数据查询语言（Data Query Language，DQL）：查询操作；<ul><li>DQL ∈ DML</li></ul></li></ul><a id="more"></a></li><li><p>连接数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1. 链接本地</span><br><span class="line">-- mysql -u 用户名 -p密码</span><br><span class="line">   mysql -u root -proot;</span><br><span class="line"># 2. 链接远端</span><br><span class="line">-- 注意密码后面没有空格，还有-P和-D的大小写</span><br><span class="line">-- mysql -u 用户名 -p密码 -h 服务器IP地址 -P 服务器端MySQL端口号 -D 数据库名</span><br><span class="line">   mysql -u root -proot -h 127.0.0.1 -P 3306 -D demo;</span><br></pre></td></tr></table></figure></li><li><p><strong>字符集</strong>：<code>utf8</code> VS <code>utf8mb4</code></p><p><strong>utf8mb4！</strong>（mb4 = most bytes 4），utf8 最长只支持3个字节的编码，对于有些编码占4字节的汉字不支持，MySQL 5.5.3 后加入了utf8mb4 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 命令行输其他命令的时候一定要打分号，不然回车默认是换行；</span><br><span class="line"># 查看当前MySQL版本,我的mysql版本是5.5.62</span><br><span class="line">select version();</span><br><span class="line"># 查看当前字符集，发现是utf8</span><br><span class="line">-- </span><br><span class="line">show variables like &#39;%character%&#39;;</span><br><span class="line"># 全局修改字符集，只对未来的库生效</span><br><span class="line">-- 1.修改配置文件 my.ini 中的 utf8 为 utf8mb4 </span><br><span class="line">-- 2.重启服务！</span><br><span class="line"># 修改已有库、表的编码</span><br><span class="line">ALTER DATABASE db_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line">ALTER TABLE tb_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;  </span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>排序字符集</strong>：<code>CLLATE</code></p><p>这个属性会影响到排序规则，ci（case insensitive），cs（case sensitive）；</p><p>常见的有 utf8mb4_general_ci 和 utf8mb4_unicode_ci，区别在于unicode 兼容的语言更多一些，但是效率低，一般开发就是用general即可；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前的排序字符集</span><br><span class="line">show variables like &#39;collation\_%&#39;;</span><br><span class="line">-- 一般不需要改</span><br></pre></td></tr></table></figure></li><li><p>关于存储路径</p><p><a href="https://www.cnblogs.com/therock/articles/2250660.html">点这里</a></p></li></ul><br><hr><h3 id="1-DCL"><a href="#1-DCL" class="headerlink" title="1. DCL"></a>1. DCL</h3><blockquote><p>用户权限存在mysql库，user、db表中；</p></blockquote><h4 id="1-1-用户操作"><a href="#1-1-用户操作" class="headerlink" title="1.1 用户操作"></a>1.1 用户操作</h4><ul><li>添加用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user henrykang identified by &#39;henrykang&#39;;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user zhangsan@&#39;%&#39;;</span><br></pre></td></tr></table></figure><ul><li>修改用户密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set password &#x3D; password(&#39;xin_mi_ma&#39;) where user &#x3D; &#39;zhangsan&#39; and host &#x3D; &#39;%&#39;;</span><br><span class="line">-- 设置完要刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h4 id="1-2-授权操作"><a href="#1-2-授权操作" class="headerlink" title="1.2 授权操作"></a>1.2 授权操作</h4><ul><li>授权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- grant 权限名 on tb_name to user_name@&#39;host&#39; [with grant option];</span><br><span class="line">-- 给henrykang赋予现有的所有表的所有权限，未来表没有;</span><br><span class="line">grant all privileges on *.* to henrykang@&#39;%&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ul><li>撤销权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- revoke 权限 on tb_name from user_name@&#39;host&#39;;</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><p>　　host：localhost 只允许在本地登录、% 可以远程登录、具体ip 只能从该ip登录；</p><p>　　with grant option：可以授权给别人；</p><p>　　权限：allprivileges、select、delete、update、create、drop……</p><br><hr><h3 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2. DDL"></a>2. DDL</h3><h4 id="2-1-库操作"><a href="#2-1-库操作" class="headerlink" title="2.1 库操作"></a>2.1 库操作</h4><ol><li>查询库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所有库</span><br><span class="line">show databases;</span><br><span class="line">-- 查看某个库的具体信息</span><br><span class="line">show create database foo;</span><br><span class="line">-- 使用库</span><br><span class="line">use foo；</span><br><span class="line">-- 查看当前使用的库</span><br><span class="line">select database(); </span><br></pre></td></tr></table></figure><ol start="2"><li>创建库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建库</span><br><span class="line">create database foo;</span><br><span class="line">create database if not exists foo;</span><br><span class="line">-- 指定字符集</span><br><span class="line">create database foo character set &#39;utf8mb4&#39; collate &#39;utf8mb4_general_ci&#39;;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 删除库</span><br><span class="line">drop database foo;</span><br><span class="line">create database if exists foo;</span><br><span class="line">-- 修改库</span><br><span class="line">alter database foo character set utf8mb4 collate utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h4 id="2-2-表操作"><a href="#2-2-表操作" class="headerlink" title="2.2 表操作"></a>2.2 表操作</h4><ol><li>查询表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看某个库中的所有表</span><br><span class="line">show tables;</span><br><span class="line">-- 查看表结构</span><br><span class="line">desc foo;</span><br><span class="line">-- 查看创建表的SQL语句</span><br><span class="line">show create table foo;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 直接创建</span><br><span class="line">create table foo(</span><br><span class="line">id int not null,</span><br><span class="line">    name varchar(10),</span><br><span class="line">)</span><br><span class="line">-- 根据已有表创建一个相同表结构的表</span><br><span class="line">create table newfoo like oldfoo;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表</span><br><span class="line">drop table foo;</span><br><span class="line">drop table if exists foo;</span><br><span class="line">-- 增加列</span><br><span class="line">alter table foo add sex char(1);</span><br><span class="line">-- 删除列</span><br><span class="line">alter table foo drop sex;</span><br><span class="line">-- 修改列名</span><br><span class="line">alter table foo change sex gender int;</span><br><span class="line">-- 修改列属性</span><br><span class="line">alter table foo modify gender int;</span><br><span class="line">-- 修改表名称</span><br><span class="line">rename table foo to student;</span><br><span class="line">alter table foo rename to student;</span><br></pre></td></tr></table></figure><h4 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h4><ul><li>数值</li></ul><table><thead><tr><th align="left">类型</th><th align="left">大小/byte</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1</td><td align="left">极小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2</td><td align="left">小整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3</td><td align="left">中整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4</td><td align="left">普通整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8</td><td align="left">大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL(M,D)</td><td align="left">max(M,D)+2</td><td align="left">小数值</td></tr></tbody></table><ul><li>日期和时间</li></ul><table><thead><tr><th align="left">类型</th><th align="left">大小/byte</th><th align="left">范围</th><th align="left">格式</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">-838:59:59’/‘838:59:59</td><td align="left">HH:MM:SS</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00 <br />9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00<br />2038-01-19</td><td align="left">YYYYMMDD HHMMSS</td></tr></tbody></table><ul><li>字符串</li></ul><table><thead><tr><th align="left">类型</th><th align="left">大小/Byte</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65535</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65535</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16777215</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16777215</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294967295</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294967295</td><td align="left">极大文本数据</td></tr></tbody></table><ul><li>varchar(255) 和 varchar(256) 的区别：隐藏了一个前缀指示字符个数，255 只须一个字节指示，而256就需要两个字节指示长度。而且 Innodb 索引列最大长度 767 字节，255 * 3 = 765 。</li></ul><h4 id="2-4-约束"><a href="#2-4-约束" class="headerlink" title="2.4 约束"></a>2.4 约束</h4><ul><li><p>约束：主键、外键、唯一、非空、默认、检查（mysql无）</p></li><li><p>添加约束的方式</p><ul><li>建表时字段后添加：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">stu_id INT PRIMARY KEY auto_increment,</span><br><span class="line">stu_name VARCHAR ( 10 ) UNIQUE,</span><br><span class="line">stu_gender CHAR ( 1 ) NOT NULL DEFAULT &#39;0&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>建表时追加：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE card (</span><br><span class="line">card_id INT,</span><br><span class="line">stu_id INT,</span><br><span class="line">PRIMARY KEY ( card_id, stu_id ),</span><br><span class="line">CONSTRAINT fk_stu_id FOREIGN KEY ( stu_id ) REFERENCES student(stu_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>建表后修改：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE card ADD [CONSTRAINT] [约束名称] xxx KEY (字段名) REFERENCES student(字段名);</span><br><span class="line">ALTER TABLE card DROP xxx KEY 约束名;</span><br></pre></td></tr></table></figure></li><li><p>添加外键时的<strong>级联操作</strong></p><ul><li>默认删除主表中的数据前需先删除从表中的数据，否则主表数据不会被删除；</li><li><strong>ON DELETE CASCADE</strong> 删除主表中的数据时，从表中的数据随之删除；</li><li><strong>ON UPDATE CASCADE</strong> 更新主表中的数据时，从表中的数据随之更新；</li><li><strong>ON DELETE SET NULL</strong> 删除主表中的数据时，从表中的相应数据置为空；<ul><li>子表的外键列不能约束为not null</li></ul></li><li><strong>NO ACTION</strong> 默认，不让删；</li><li><strong>RESTRICT</strong> 同no action 不让删；</li></ul></li></ul><br><hr><h3 id="3-DML"><a href="#3-DML" class="headerlink" title="3. DML"></a>3. DML</h3><h4 id="3-1-新增"><a href="#3-1-新增" class="headerlink" title="3.1 新增"></a>3.1 新增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 新增一条</span><br><span class="line">insert into student (参数列表) values (003,&#39;zhangsan&#39;,1);</span><br><span class="line">-- 新增多条</span><br><span class="line">insert into student values(004,&#39;lisi&#39;,1),(005,&#39;王五&#39;,1);</span><br><span class="line">-- 根据现有数据新增</span><br><span class="line">insert into student(参数列表) 子查询;</span><br></pre></td></tr></table></figure><h4 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 删除指定</span><br><span class="line">delete from student where id &#x3D; 007;</span><br><span class="line">-- 删除所有数据</span><br><span class="line">delete from student;</span><br><span class="line">-- 删除所有数据（是DDL）</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure><ul><li><p><code>delete</code> VS <code>truncate</code></p><p>delete 逐行删除、每行都记录日志所以可以回滚、效率低、自增字段不重置；truncate 一次性释放所有记录、只记录一次日志所以无法回滚、自增字段重置、效率高，被外键引用的表不能使用truncate；</p></li></ul><h4 id="3-3-修改"><a href="#3-3-修改" class="headerlink" title="3.3 修改"></a>3.3 修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 修改指定</span><br><span class="line">update student set name &#x3D; &#39;田七&#39;,gender &#x3D; 0 where id &#x3D; 003;</span><br><span class="line">-- 修改所有</span><br><span class="line">update student set name &#x3D; &#39;田七&#39;;</span><br></pre></td></tr></table></figure><br><hr><h3 id="4-DQL"><a href="#4-DQL" class="headerlink" title="4. DQL"></a>4. DQL</h3><h4 id="4-1-简单查询"><a href="#4-1-简单查询" class="headerlink" title="4.1 简单查询"></a>4.1 简单查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col_name from tb_name where 条件;</span><br></pre></td></tr></table></figure><ul><li>常规操作：</li></ul><table><thead><tr><th>操作</th><th>关键字</th></tr></thead><tbody><tr><td>去重</td><td>distinct</td></tr><tr><td>别名</td><td>as，可以省略</td></tr><tr><td>结果参与简单运算</td><td>select age+1 as next_age from student</td></tr><tr><td>算数运算符</td><td>is null 判断是否为null，&lt;&gt; 相当于 !=，in(集合)，like ‘%多个_单个’</td></tr><tr><td>逻辑运算符</td><td>and、or、not</td></tr><tr><td>排序</td><td>order by col_name [asc/desc]，col_name2 [asc/desc]…</td></tr><tr><td>分组</td><td>group by col_name having 条件</td></tr><tr><td>聚合函数</td><td>max()、min()、avg()、count()、sum()、ifnull()</td></tr><tr><td>limit</td><td>limit(offset，length) 从0开始</td></tr></tbody></table><p>　　聚合函数若想统计null则使用<code>ifnull(列名，默认值)</code>函数：表示将null替换为默认值，例如select count ( ifnull ( gender,0 ) ) from studnet;</p><p>　　<strong>where 和 having 的区别</strong>：where 在聚合前进行过滤，where子句中不能使用聚合函数；having 先聚合再过滤，having 子句可以使用聚合函数。如果条件允许，应当先使用where过滤再聚合以提高效率，再判断需不需要进行having过滤。</p><h4 id="4-2-复合查询"><a href="#4-2-复合查询" class="headerlink" title="4.2 复合查询"></a>4.2 复合查询</h4><ul><li>内连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 下面等价</span><br><span class="line">select * from tb_1,tb_2 where tb_1.id &#x3D; tb_2.id;</span><br><span class="line">select * from tb_1 inner join tb_2 on tb_1.id &#x3D; tb_2.id;</span><br><span class="line">-- inner 可以省略</span><br><span class="line">select * from tb_1 join tb_2 on tb_1.id &#x3D; tb_2.id;</span><br></pre></td></tr></table></figure><ul><li>左外链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 用左表记录匹配右表，右表符合则显示，不符合则显示NULL</span><br><span class="line">select * from tb_1 left outer join tb_2 on tb_1.id &#x3D; tb_2.id;</span><br></pre></td></tr></table></figure><ul><li>右外连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 相反，左边不符合的显示NULL</span><br><span class="line">select * from tb_1 right outer join tb_2 on tb_1.id &#x3D; tb_2.id;</span><br></pre></td></tr></table></figure><ul><li>子查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 一个查询的结果做为另一个查询的条件</span><br><span class="line">select * from tb_1 where tb_1.id &#x3D; (</span><br><span class="line">    Select id from tb_1 where tb_1.name &#x3D; &#39;xxx&#39;</span><br><span class="line">);</span><br><span class="line"># 子查询的结果情况</span><br><span class="line">-- 单列一个结果：使用where</span><br><span class="line">-- 单行单列：相当于一个数组，使用 in</span><br><span class="line">-- 多行多列：跟在from后面，需要取别名</span><br></pre></td></tr></table></figure><br><hr><h3 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h3><table><thead><tr><th>说明</th><th>SQL</th></tr></thead><tbody><tr><td>开启事务</td><td>start transaction</td></tr><tr><td>提交事务</td><td>commit</td></tr><tr><td>回滚事务</td><td>rollback</td></tr><tr><td>设置回滚点</td><td>savepoint 标识</td></tr><tr><td>回到回滚点</td><td>rollback to 标识</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务是否自动提交（默认开启）</span><br><span class="line">select @@autocommit;</span><br><span class="line">-- 设置不自动提交</span><br><span class="line">set @@autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure><p>注意：一条语句就是一个事务，关闭自动提交后，除了DDL外执行的单条语句后面都要commit；</p><h4 id="5-1-ACID"><a href="#5-1-ACID" class="headerlink" title="5.1 ACID"></a>5.1 ACID</h4><ul><li>原子性（Atomicity）：事务是一个整体不可再分；</li><li>一致性（Consistency）：事务执行前后数据库的状态应保持一致，即数据应该守恒；</li><li>隔离性（Isolation）：并发操作时各事务之间不应相互影响；</li><li>持久性（Durability）：事务执行成功，对数据库的修改是持久的。</li></ul><h4 id="5-2-隔离级别"><a href="#5-2-隔离级别" class="headerlink" title="5.2 隔离级别"></a>5.2 隔离级别</h4><ul><li>并发访问带来的数据<strong>不一致性</strong>问题<ul><li>脏读：一个事务读取到了另一个事务中尚未提交的数据；</li><li>不可重复读：一个事务中多次读取的数据内容不一致（另一个事务进行了修改操作）；</li><li>幻读：一个事务中多次读取的数据条数不一致（另一个事务进行了插入删除操作）；</li></ul></li><li><strong>隔离级别</strong></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read uncommitted）</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交（read committed）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复度（repeatable read），mysql默认</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化（serializable）</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置隔离级别</span><br><span class="line">-- 设置完需要重新连接</span><br><span class="line">set global&#x2F;session transaction isolation level  read uncommitted;</span><br></pre></td></tr></table></figure><hr><h3 id="6-DQL-小结"><a href="#6-DQL-小结" class="headerlink" title="6. DQL 小结"></a>6. DQL 小结</h3><ul><li><p><code>where</code>：<strong>先过滤，再聚合</strong>，子句中不能出现聚合列。</p></li><li><p><code>having</code>：<strong>先聚合，再过滤</strong>，子句中可以使用聚合列。</p><ul><li>一般和 group by 搭配使用。</li><li>不用group by、聚合的话，having作用和where差不多。</li></ul></li><li><p><code>group by</code>：<strong>先于聚合函数执行</strong>，一般搭配聚合函数使用形成新的关系。</p><ul><li>如果单纯使用group by，只会返回每个分组内的第一行数据。</li><li>group by 自带排序，默认按照关键字升序，可加 desc。</li><li>group by 可以带多个关键字，group by X,Y 表示将所有具有相同X字段值和Y字段值的记录放到一个分组里。</li></ul></li><li><p><code>order by</code>：对将要返回的结果集排序。</p></li><li><p><code>limit(下标0开始，条数)</code>：返回之前截取结果集。</p></li><li><p>并集：</p><ul><li><code>union</code>：求并集且自动去重，两个表的列的数据类型必须兼容。</li><li><code>union all</code>：不去重。</li></ul></li><li><p>连接：</p><ul><li><code>inner join</code>：内连接，返回多表匹配的行。<ul><li>默认 join 就是内连接。</li></ul></li><li><code>left join</code>：左外连接，左表全部数据，右表不匹配的显示null。</li><li><code>right join</code>：右外链接，左边null，右边全部数据。</li><li><code>outer join</code>：MySQL 不支持全外连接，可以使用 <code>左外连接 union 右外链接</code> 来实现。</li><li><code>cross join</code>：交叉连接，即笛卡尔积。等价于没有where条件的多表查询。</li></ul></li><li><p><strong>关于能不能使用 join？</strong></p><ul><li>格式：驱动表 t1 join 被驱动表 t2 on 条件。<ul><li>t1 、t2 行数分别为 M、N。　</li></ul></li><li>当被驱动表在条件列上有索引的时候，可以使用 join。步骤如下：<ul><li>遍历 t1 取出条件字段、在 t2 的索引上比较条件字段、满足则组成结果集的一部分，直到遍历完 t1。</li><li>复杂度：M + M * 2*log<sub>2</sub>N<ul><li>解释：乘以2是因为算上了回表。由此可以判断 M 影响较大，所以<strong>尽量使用小表join大表</strong>。</li></ul></li></ul></li><li>当被驱动表在条件列上没有索引的时候，尽量不要使用 join。步骤如下：<ul><li>使用 join_buffer 预读 t1 表的一部分数据，取 t2 数据和join_buffer中的数据进行比较，满足条件则组成结果集的一部分，若 t1 表比较大，join_buffer 放不下，则分批次放。</li><li>复杂度： M * N</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库设计与范式</title>
      <link href="Database/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%8C%83%E5%BC%8F.html"/>
      <url>Database/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%8C%83%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　数据库表的设计简单可以分为这几个步骤：需求分析，提取需求中的实体、属性以及关系；逻辑结构设计，将需求分析的结果提取成独立的<strong>关系模式</strong>，形成E-R图；最后将E-R图转换为数据库关系模型。其中关系模式的<strong>规范化程度</strong>，直接影响到我们数据库的稳定性，合理的关系模式可以避免数据的冗余，避免发生插入、删除、修改等异常。</p><a id="more"></a><h3 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h3><ul><li><p><strong>码</strong></p><ul><li>超码：在一个元组中，能够唯一确定该元组的属性组；</li><li>候选码：候选码是<strong>”最小“</strong>的超码；<ul><li>包含在候选码中的属性，称为<strong>主属性</strong>，不包含在任何候选码中的属性称为<strong>非主属性</strong>；</li></ul></li><li>主码：若候选码多于一个，在其中选取一个作为主码；</li></ul></li></ul><ul><li><p><strong>依赖</strong></p><ul><li><p>X→Y 称为 Y 依赖于 X，X 称为<strong>决定因素</strong>，所以也可以说 X 决定 Y；</p></li><li><p>若 X→Y，且 X 的任何一个真子集 X ‘ 都有 X ‘-/-&gt; Y，称 <strong>Y 完全依赖于 X</strong>；</p><ul><li>否则称为 <strong>Y 部分依赖于 X</strong>；</li></ul></li><li><p>若X→Y，Y→Z，而X-/-&gt;Y则称 Z <strong>传递依赖</strong>于 X；</p></li></ul></li></ul><ul><li><p><strong>范式</strong>（Nomal Form）</p><ul><li>描述关系模式的规范化程度的式子，称为<strong>范式</strong>，级别越高则规范化程度越高，低级的范式可以通过关系分解形成若干高级的范式；</li><li>1NF：关系模式中的属性必须具有原子性；</li><li>2NF：在1NF前提下，非主属性必须完全依赖于任何一个候选码；</li><li>3NF：在2NF前提下，非主属性不能传递依赖于码；</li><li>BCNF：在1NF前提下，每一个决定因素都包含码；可以推出满足2、3NF：</li><li>还有4NF、5NF都比较复杂，一般数据库表满足3NF就比较合理了。</li></ul></li></ul><h3 id="2-范式"><a href="#2-范式" class="headerlink" title="2. 范式"></a>2. 范式</h3><ul><li><p>设有如下独立的关系模式：</p><ul><li>学生：student（<u>stu_id</u>，stu_name ……）</li><li>校园卡：card（<u>card_id</u>，card_pwd ……）</li><li>课程：course（<u>c_id</u>，c_name，c_desc ……）</li><li>成绩单：sc（<u>stu_id，c_id</u>，grade ……）</li><li>部门：dept（<u>d_id</u>，d_name，d_desc ……）</li></ul></li></ul><ul><li><p>2NF：在1NF前提下，非主属性必须完全依赖于任何一个候选码；不满足2 NF就可能出现以下异常：</p><ul><li><p>插入异常：将学生和成绩单合并成新的关系模式 student+sc（<u>stu_id，c_id</u>，stu_name，grade ……），其中非主属性stu_name部分依赖与码，即不符合2NF，当插入一个学生而他还没有选课时，就无法插入，因为主码缺少一个属性c_id；</p></li><li><p>删除异常：还是上面的 student+sc 关系模式，当某学生退课时，会连同该学生的信息都被删除；</p></li><li><p>更新异常：假设学生改名了，而他选了n门课，表中就有n条记录，不仅数据冗余，而且还要保证所有的姓名都修改，倘若其中一条修改失败，就会导致数据不一致性；</p></li></ul></li></ul><ul><li><p>3NF：在2NF前提下，非主属性不能传递依赖于码；即在 2NF的基础上，消除了非主属性对码的传递依赖；考虑student+dept（<u>stu_id</u>，stu_name，d_name，d_desc），d_desc传递依赖于stu_id，不符合3NF，同样会发生上面三种异常：</p><ul><li>插入异常：想插入一个新的部门，至少得有一个学生才行；</li><li>更新异常：冗余，更新d_desc需要更新每个学生的d_desc；</li><li>删除异常：例子没举好，非要说的话可以和上面一样，删除d_desc需要在每一个student记录中都删除；</li></ul></li></ul><ul><li><p>BCNF：在1NF前提下，每一个决定因素都包含码；消灭了3NF中可能存在的主属性对码的部分依赖和传递依赖；</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/jioewX983Ic0.png" alt="举例"></p><ul><li>由此也可以看出为什么我们一般满足3NF即可，因为BCNF消除了主属性对码的部分和传递依赖，而一般我们的表中主码元组中只有一个属性，就不会发生主属性对码的依赖；</li></ul></li></ul><h3 id="3-E-R图转化为数据库模型"><a href="#3-E-R图转化为数据库模型" class="headerlink" title="3. E-R图转化为数据库模型"></a>3. E-R图转化为数据库模型</h3><p>　　E-R图的实体就是表，属性就是表的字段，主要解决的问题是关系的处理：</p><ul><li>1:1 关系，如学生和校园卡是一对一的关系，通常进行合并，也可以将一方的主键作为属性加到另一方中；</li><li>1:n 关系，如学生和部门是一对多的关系，可以合并（会冗余），但通常将 1 方的主键作为属性加到 n 方中；</li><li>m:n 关系，如学生和课程是多对多关系，需要提取一个中间关系sc，m、n两方的主键作为属性加入其中；</li><li>三个或以上关系，同m:n；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 学习笔记</title>
      <link href="JavaEE/Back%20End/SpringMVC.html"/>
      <url>JavaEE/Back%20End/SpringMVC.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/0CUlLFDFs64k.png" alt="mark" style="zoom: 33%;" /><blockquote><p><strong>注意区分三层架构与MVC模型的区别。</strong></p><p>三层架构：数据访问层，业务逻辑层，界面层。<br>MVC：是界面层上的一种模型，是实现界面层的一种办法。</p><ul><li><p>Model 可以理解为封装数据用的pojo；</p></li><li><p>View 可以理解为”真·页面层”，只负责展示数据；</p></li><li><p>Controller 负责流程的控制和业务的分发，响应用户的请求，调用业务逻辑层相关方法，获取结果转发给View层进行展示。切记Controller只负责业务流程的分发控制，不负责具体的业务处理。</p></li></ul><p>SpringMVC 有着清晰的角色划分：核心控制器、处理映射器、处理适配器、视图解析器…… 分工明确，扩展灵活，而且其强大的数据验证、格式化和绑定机制大大提高了我们的开发效率。</p></blockquote><p>　</p><hr><a id="more"></a><h3 id="1-HelloSpringMVC"><a href="#1-HelloSpringMVC" class="headerlink" title="1. HelloSpringMVC"></a>1. HelloSpringMVC</h3><blockquote><p>　　学习SpringMVC一定要联想到Servlet，<strong>SpringMVC的入口就是一个Servlet</strong>，所有的请求发过来首先都会经过核心控制器DispatcherServlet。</p></blockquote><h4 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h4><ol start="0"><li><p>配置的思路：因为入口是DispatcherServlet，所以当服务器启动时最好对其进行初始化；与此同时让其帮我们读取配置文件，创建Spring的核心容器；</p></li><li><p>创建Maven工程，导入坐标；</p></li></ol><figure class="highlight xml"><figcaption><span>pom.xml >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>web.xml</code>中配置核心控制器（SpringMVC的入口）；</li></ol><figure class="highlight xml"><figcaption><span>web.xml >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置核心控制器的初始化参数，让它读取配置文件，创建spring容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:SpringMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置servlet启动时创建核心控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 请求发来都会先经过核心控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写<code>SpringMVC.xml</code>;</li></ol><figure class="highlight xml"><figcaption><span>SpringMVC.xml >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.istudy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置spring开启注解mvc的支持--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置了此行，还会自动帮我们将处理映射器、处理适配器等一些必备模块注册到spring容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>编写jsp 与 HelloSpringMVC控制类;</li></ol><figure class="highlight"><figcaption><span>index.jsp >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- &lt;a href=&quot;hello&quot;&gt;相对路径不要写斜杠&lt;/a&gt; --&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/hello&quot;&gt;点我跳转&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><figcaption><span>success.jsp >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;Hello SpringMVC！！&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>HelloSpringMVC.java >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringMVC</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(path=&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-流程分析"><a href="#1-2-流程分析" class="headerlink" title="1.2 流程分析"></a>1.2 流程分析</h4><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载SpringMVC.xml配置文件，创建spring核心容器并创建我们需要的类实例；</li><li>开启了注解扫描，那么HelloSpringMVC对象就会被创建并加入到spring容器；</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法；</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件；</li><li>Tomcat服务器渲染页面，做出响应。</li></ol><p>　</p><hr><h3 id="2-请求参数绑定"><a href="#2-请求参数绑定" class="headerlink" title="2. 请求参数绑定"></a>2. 请求参数绑定</h3><blockquote><p>　　请求参数的绑定是自动的，但必须符合一定的规范；其次，前端发送过来的都是字符串类型，能够容易的封装是因为SpringMVC内置了很多类型转换器，基本上能够满足所有的需求，但有时我们还是需要定义类型转换器，如我们想要把日期转换成我们自定义的格式。</p></blockquote><h4 id="2-1-参数绑定"><a href="#2-1-参数绑定" class="headerlink" title="2.1 参数绑定"></a>2.1 参数绑定</h4><ul><li>基本型和String型：控制器方法的形参名称与所提交数据的name属性保持一致；</li><li>pojo类型：所提交数据的name属性要与pojo类中的属性名保持一致，若pojo1关联到另一个pojo2中，则name属性应该这样写：<code>pojo1在pojo2中的名字.pojo1中的属性名</code>；</li><li>集合类型：name属性使用类似JS的写法，如：<code>accounts[0].name，accounts[0].money</code>；<code>accountMap[&#39;one&#39;].name，accountMap[&#39;one&#39;].money</code>。</li></ul><p>总结：其实就是让方法的形参名、提交数据的name属性与定义的java类中的属性名一致。</p><h4 id="2-2-封装-json"><a href="#2-2-封装-json" class="headerlink" title="2.2 封装 json"></a>2.2 封装 json</h4><ul><li>见4.3节。</li></ul><h4 id="2-3-配置过滤器解决乱码问题"><a href="#2-3-配置过滤器解决乱码问题" class="headerlink" title="2.3 配置过滤器解决乱码问题"></a>2.3 配置过滤器解决乱码问题</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在SpringMVC.xml配置静态资源不过滤 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-自定义类型转换器"><a href="#2-4-自定义类型转换器" class="headerlink" title="2.4 自定义类型转换器"></a>2.4 自定义类型转换器</h4><ol><li>自定义一个转换类实现<code>Converter&lt;Source,Target&gt;</code>的接口；</li><li>重写方法制定转换规则；</li><li>注册自定义的类型转换器：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converterService&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置自定义类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.istudy.utils.StringToDateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 annotation-driven 标签中引用配置的类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>　</p><hr><h3 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h3><ul><li><p><code>@RequestMapping</code></p><ul><li>value：指定请求的url；</li><li>method：指定请求方式；</li><li>params：指定请求参数的条件，可以使用简单的表达式；</li><li>headers：指定请求消息头的条件；</li></ul></li><li><p><code>@RequestParam</code>：</p><ul><li>value：指定请求参数的name属性；</li></ul></li><li><p>required：指定该参数是否必须，默认为true；</p></li><li><p><code>@RequestBody</code>：获取请求体</p><ul><li>required：指定是否必须有请求体，默认为true；<ul><li>默认情况下使用get请求会报错，改为false后使用get请求返回null；</li></ul></li></ul></li><li><p><code>@RequestHeader</code></p><ul><li>value：消息头名称；</li><li>required：是否必须有此消息头；</li></ul></li><li><p><code>@PathVariable</code>：restful</p><ul><li>value：指定url中的占位符名称；</li><li>required：是否必须提供占位符；</li></ul></li><li><p><code>@CookieValue</code></p><ul><li>value：指定cookie名称;</li><li>required：是否必须有此cookie;</li></ul></li><li><p><code>@SessionAttribute</code>：</p><ul><li>value：指定存入的属性名称；</li><li>type：指定存入的数据类型；</li></ul></li><li><p><code>@ModelAttribute</code>：</p><ul><li>出现在方法上，表示当前方法会在控制器的方法执行之前执行；<ul><li>有返回值，返回值会传递给控制器方法；</li><li>无返回值，将值加入到一个map中，通过在控制器方法参数上注解绑定；</li></ul></li><li>出现在参数上，获取指定的数据给参数赋值；</li></ul><figure class="highlight java"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showModel</span><span class="params">(String username,Map&lt;String,User&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟去数据库查询</span></span><br><span class="line">    User user = findUserByName(username);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了 showModel 方法&quot;</span>+user);</span><br><span class="line">    map.put(<span class="string">&quot;abc&quot;</span>,user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/updateUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(<span class="meta">@ModelAttribute(&quot;abc&quot;)</span>User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;控制器中处理请求的方法：修改用户：&quot;</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　</p></li></ul><hr><h3 id="4-响应数据处理"><a href="#4-响应数据处理" class="headerlink" title="4. 响应数据处理"></a>4. 响应数据处理</h3><h4 id="4-1-返回值分类"><a href="#4-1-返回值分类" class="headerlink" title="4.1 返回值分类"></a>4.1 返回值分类</h4><ul><li><p><strong>字符串</strong>：作为逻辑视图的名称传递给视图解析器；</p></li><li><p><strong>void</strong>：默认寻找和访问路径同名的页面，可以通过转发或者重定向避免默认情况的发生，还可以直接使用response写回数据。</p></li><li><p><strong>ModelAndView</strong>：SpringMVC为我们提供的一个对象，用于封装数据加入到request域，原理和使用形参+返回String相同；有两个主要方法：<code>addObject(key,value)</code>和<code>setViewName(str)</code>;</p></li></ul><h4 id="4-2-转发和重定向"><a href="#4-2-转发和重定向" class="headerlink" title="4.2 转发和重定向"></a>4.2 转发和重定向</h4><ul><li>转发：<code>return &quot;forward:/WEB-INF/pages/success.jsp&quot;</code>;</li><li>重定向：<code>return &quot;redirect:/user/findAll&quot;</code>;<ul><li>重定向到本服务器，则前缀可以不写，即只写uri。</li></ul></li></ul><h4 id="4-3-响应json数据"><a href="#4-3-响应json数据" class="headerlink" title="4.3 响应json数据"></a>4.3 响应json数据</h4><blockquote><p>导包：jackson-annotations、jackson-databind、jackson-core；</p><p>使用 @RequestBody、@ResponseBody注解</p></blockquote><ol><li>封装Json数据：</li></ol><p>　　使用<code>@RequestBody</code>可以获取到请求体内容，注解到String类型参数上可以直接获取json串，若参数是pojo类，pojo中的属性名称和json串中的key对应，可以自动封装；</p><ol start="2"><li>响应Json数据：</li></ol><p>　　使用<code>@ResponseBody</code>注解修饰方法返回值即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">testResponseJson</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;异步请求：&quot;</span>+account);</span><br><span class="line"><span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　</p><hr><h3 id="5-异常处理器和拦截器"><a href="#5-异常处理器和拦截器" class="headerlink" title="5. 异常处理器和拦截器"></a>5. 异常处理器和拦截器</h3><h4 id="5-1-异常处理器"><a href="#5-1-异常处理器" class="headerlink" title="5.1 异常处理器"></a>5.1 异常处理器</h4><blockquote><p>　　SpringMVC中异常层层上抛，若抛到核心控制器层还没有捕获，则会继续抛出到页面上，非常不友好，我们需要注册一个异常处理器，当核心控制器接到异常时会转交给异常处理器，在异常处理器中我们可以跳转到用户友好页面。</p></blockquote><ol start="0"><li>自定义异常和错误页面；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>自定义异常处理器，继承自<code>HandlerExceptionResolver</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        CustomException e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取到异常对象</span></span><br><span class="line">        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> CustomException) &#123;</span><br><span class="line">            <span class="comment">// 向下转型</span></span><br><span class="line">        e = (CustomException) ex;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        e = <span class="keyword">new</span> CustomException(<span class="string">&quot;请联系管理员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 存入错误的提示信息</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 跳转的Jsp页面</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册异常处理器；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置异常处理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;sysExceptionResolver&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.istudy.exception.CustomExceptionResolver&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="5-2-拦截器"><a href="#5-2-拦截器" class="headerlink" title="5.2 拦截器"></a>5.2 拦截器</h4><blockquote><p>　　区别于Servlet的过滤器，过滤器可以过滤对任何资源的请求；而SpringMVC的拦截器只能拦截对控制器中方法的请求，它利用了AOP思想。</p></blockquote><ol><li><strong>自定义拦截器，实现<code>HandlerInterceptor</code>接口；</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor&#123;</span><br><span class="line">    @Override</span><br><span class="line">    Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是登录页面则放行</span><br><span class="line">        if(request.getRequestURI().indexOf(&quot;login.action&quot;)&gt;&#x3D;0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpSession session &#x3D; request.getSession();</span><br><span class="line">        &#x2F;&#x2F;如果用户已登录也放行</span><br><span class="line">        if(session.getAttribute(&quot;user&quot;)!&#x3D;null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;用户没有登录跳转到登录页面</span><br><span class="line">        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;login.jsp&quot;).forward(request,response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>重写方法：</strong></li></ol><ul><li><code>Boolean preHandle()</code>：再控制器方法执行之前执行；<ul><li>return true 则放行；</li></ul></li><li><code>void postHandle()</code>：在控制器方法执行之后<strong>未返回之前</strong>执行；<ul><li>可以转发、重定向到其他资源，原控制器的return不生效；</li></ul></li><li><code>void afterCompletion()</code>：在控制器方法执行且<strong>返回之后</strong>执行；<ul><li>无法转发、重定向，因为控制器方法已经返回了。</li></ul></li></ul><ol start="3"><li><strong>注册拦截器：</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handlerInterceptorDemo1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.istudy.web.interceptor.HandlerInterceptorDemo1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-拦截器顺序说明"><a href="#5-3-拦截器顺序说明" class="headerlink" title="5.3 拦截器顺序说明"></a>5.3 拦截器顺序说明</h4><p>　　设多个拦截器<strong>按配置顺序</strong>为：HandlerInterceptor A，HandlerInterceptor B，则执行顺序如下，</p><p>　　A.preHandle() &gt;&gt; B.preHandle() &gt;&gt; 控制器方法 &gt;&gt; B.postHandle() &gt;&gt; A.postHandle() &gt;&gt; B.afterCompletion() &gt;&gt; A.afterCompletion() &gt;&gt; View；其中若A.preHandle()返回了false，则直接 &gt;&gt; View，若B.preHandle()返回了false，则返回到A.afterCompletion()执行。</p><p>　　总结：这个过程类似于中断调用与返回。</p><p>　</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建博客并部署到GiteePages步骤记录</title>
      <link href="Others/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GiteePages.html"/>
      <url>Others/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GiteePages.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　原本没打算进行记录，但是手贱使用了一下某网盘的同步盘功能，导致本地一些文件被覆盖，最终又得重新配置一遍。为了让以后悲剧再次发生时能够将损失减到最小，特此记录一下此次过程。</p><a id="more"></a><h3 id="1-Hello-Hexo"><a href="#1-Hello-Hexo" class="headerlink" title="1. Hello Hexo"></a>1. Hello Hexo</h3><ol><li><p><strong>安装<code>Node.js</code>，命令行<code>node -v</code> 验证；</strong></p><ul><li>安装时要选择自动写入环境变量，免得自己再配置；</li></ul></li><li><p><strong>安装<code>Git</code>，命令行<code>git version</code>验证；</strong></p><p>2.1  配置姓名与邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>2.2 生成密钥，会在用户目录下生成<code>,ssh</code>文件夹，里面包含公钥<code>id_rsa.pub</code>和私钥<code>id_rsa</code>，后面部署要用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>安装<code>Hexo</code></strong></p><p>3.1 换淘宝源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>3.2 安装cnpm，后面安装都通过cnpm命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm</span><br></pre></td></tr></table></figure><p>3.3 安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>3.4 说一下<code>-D,-S,-g</code>的区别</p><ul><li>-D 依赖写入 devDependencies，用于开发环境；</li><li>-S 依赖写入 Dependencies，用于生产环境；</li><li>-g 全局安装到用户目录下，可以通过 <code>npm config set prefix</code>设置默认路径；<ul><li>不使用 -g 则安装到当前命令窗口所指的目录；</li></ul></li></ul></li><li><p><strong>初始化Hexo</strong></p><p>4.1 选择一个空文件夹用于初始化 Hexo，例如在D盘下新建一个<code>_Blog</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 进入到该文件夹右键GitBash Here</span><br><span class="line">// 或者<span class="built_in">cd</span>进入</span><br><span class="line">d:</span><br><span class="line"><span class="built_in">cd</span> _Blog</span><br><span class="line">// 执行Hexo初始化命令</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>4.2 安装<code>hexo-server</code>插件，这样就能在本地运行看效果了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-server</span><br></pre></td></tr></table></figure><p>4.3 构建博客（生成静态页面）并在本地浏览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>g 是 generate，s 是 server</li><li>访问本地 4000 端口，看见默认主题的博客即成功；</li></ul><p>4.4 写博客并在本地浏览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名&quot;</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><ul><li>hexo new 会在博客的<code>source/_posts/</code>下创建博客名文件，通过编辑器打开编写博客；</li><li>hexo clean 用于清除上一次生成的缓存；</li></ul><p>4.5 常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean 清理缓存</span><br><span class="line">hexo g   构建博客</span><br><span class="line">hexo s   本地服务器</span><br><span class="line">hexo d   推送到远端，下面讲</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-部署到GiteePages"><a href="#2-部署到GiteePages" class="headerlink" title="2. 部署到GiteePages"></a>2. 部署到GiteePages</h3><ol><li><p><strong>Gitee 设置</strong></p><p>1.1 在Gitee密钥管理设置中添加公钥，将Git公钥<code>id_rsa.pub</code>中的内容复制进去；</p><p>1.2 创建 blog 仓库，注意下<strong>仓库的ssh地址</strong>，下面用；</p><p>1.3进入仓库选择服务-&gt;Pages-&gt;启用，注意下分配的<strong>站点url</strong>，下面用；</p></li><li><p><strong>配置博客目录下的站点配置文件<code>_config.yml</code></strong></p><p>2.1 配置站点url</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">Pages服务得到的站点url</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/仓库名</span></span><br></pre></td></tr></table></figure><p>2.2 配置部署地址，就是仓库的ssh地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="comment">#repo: git@github.com:HenryKang99/HenryKang99.github.io.git       </span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@gitee.com:henrykang99/blog.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span>                           </span><br><span class="line">    <span class="attr">message:</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推送到仓库</strong></p><p>3.1 安装<code>hexo-deployer-git</code>插件用于Git推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>3.2 运行<code>hexo -d</code>命令推送到仓库</p><p>3.3 因为GiteePages普通版不支持自动部署，所以需要去Pages页面手动点击更新；</p><ul><li>可以免费体验一个月GiteePagesPro服务，自动部署且可以自定义域名和Https；</li></ul><p>3.4 等上两三分钟，访问你的站点url，成功；</p><p>3.5 <a href="https://www.henrykang.site/">点点看我的博客</a></p></li></ol><hr><h3 id="3-更换主题与个性化"><a href="#3-更换主题与个性化" class="headerlink" title="3. 更换主题与个性化"></a>3. 更换主题与个性化</h3><ol><li><p>挑选主题</p><p>网上自己找（关键字：Hexo主题top10），下载（解压）放在博客目录下的<code>themes</code>文件夹中，推荐选择用的人多的主题，碰到问题容易找到解决方法；</p></li><li><p>站点配置文件<code>_config,yml</code>中配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">你的主题文件夹名称</span></span><br></pre></td></tr></table></figure></li><li><p>再hexo三连，进行本地浏览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li><li><p>遇到问题就查找本主题的文档（一般都有）或一些使用者写的博客，主题文件夹下也有一个<code>_config.yml</code>配置文件，用于对主题的一些个性化的配置；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习笔记</title>
      <link href="JavaEE/Back%20End/Spring.html"/>
      <url>JavaEE/Back%20End/Spring.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>Spring是一个轻量级的以<strong>控制反转</strong>(IoC)和<strong>面向切面编程</strong>(AOP)思想为核心的容器框架。</p><p>IOC：我们可以将所有对象的创建和依赖关系的维护交由Spring管理，方便解耦，简化开发；</p><p>AOP：可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性；也可以在不修改源代码的情况下，对某些方法进行增强，例如日志记录，事务处理用aop来实现，和真正的业务逻辑分离开来，降低了耦合度。</p></blockquote><ul><li>一个简单的工厂模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line">    <span class="comment">// 创建一个存放对象的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; beans;</span><br><span class="line">    <span class="comment">//使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化对象</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//获取properties文件的流对象</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">            props.load(in);</span><br><span class="line">            <span class="comment">//实例化容器</span></span><br><span class="line">            beans = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">            Enumeration keys = props.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())&#123;</span><br><span class="line">                String key = keys.nextElement().toString();</span><br><span class="line">                String beanPath = props.getProperty(key);</span><br><span class="line">                Object value = Class.forName(beanPath).newInstance();</span><br><span class="line">                beans.put(key,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">&quot;初始化properties失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-HelloSpring"><a href="#1-HelloSpring" class="headerlink" title="1. HelloSpring"></a>1. HelloSpring</h3><h4 id="1-1-快速入门"><a href="#1-1-快速入门" class="headerlink" title="1.1 快速入门"></a>1.1 快速入门</h4><ol><li>创建Maven工程, 导入坐标;</li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring5.x版本要求junit4.x、tomcat8.5、jdk8以上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建核心配置文件<code>bean.xml</code>;</li><li>配置<code>&lt;bean&gt;</code>标签</li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--把对象的创建交给spring来管理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认调用无参构造函数，没有找到会报错--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签的其他属性在后面有记录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;site.henrykang.domain.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>步骤:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGetBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ac = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：通过ApplicationContext获取容器对象</span></span><br><span class="line">        ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student stu = (Student) ac.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanByBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式二：通过BeanFactory获取容器对象</span></span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br><span class="line">        Student stu = (Student) factory.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心容器接口</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/LRBc7Al25nRe.png" alt="mark"></p><table><thead><tr><th align="left">接口</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ApplicationContext</td><td align="left">（读取完配置文件）立即加载</td></tr><tr><td align="left">BeanFactory</td><td align="left">延迟加载</td></tr></tbody></table><ul><li>ApplicationContext 三个常用的实现类</li></ul><table><thead><tr><th align="left">实现类</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ClassPathXmlApplicationContext</td><td align="left">加载<strong>类路径</strong>下的配置文件</td></tr><tr><td align="left">FileSystemXmlApplicationContext</td><td align="left">加载磁盘任意路径下的配置文件</td></tr><tr><td align="left">AnnotationConfigApplicationContext</td><td align="left">用于读取<strong>注解</strong>创建容器</td></tr></tbody></table><h4 id="1-2-Bean"><a href="#1-2-Bean" class="headerlink" title="1.2 Bean"></a>1.2 Bean</h4><h5 id="1-2-1-生命周期"><a href="#1-2-1-生命周期" class="headerlink" title="1.2.1 生命周期"></a>1.2.1 生命周期</h5><ul><li><strong>单例对象:</strong> 容器创建时创建, 没有外部引用的话容器销毁时释放, 否则容器销毁后由GC回收;<ul><li>即只要容器在，对象就在；</li></ul></li><li><strong>多例对象:</strong> 使用对象时创建, GC回收;</li></ul><h5 id="1-2-2-bean标签属性"><a href="#1-2-2-bean标签属性" class="headerlink" title="1.2.2 bean标签属性"></a>1.2.2 bean标签属性</h5><ul><li><p><code>id</code>：bean的唯一标识；</p></li><li><p><code>class</code>：bean的全类名；</p><ul><li>使用静态工厂方法创建对象时，指定静态工厂类；</li></ul></li><li><p><code>scope</code>：控制单例或者多例；</p></li></ul><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">singleton</td><td align="left">单例（默认）</td></tr><tr><td align="left">prototype</td><td align="left">多例</td></tr><tr><td align="left">request</td><td align="left">作用于web应用的请求范围</td></tr><tr><td align="left">session</td><td align="left">作用于web应用的会话范围</td></tr></tbody></table><ul><li><code>init-method</code>、<code>destroy-method</code>：指定初始化、销毁时执行的方法；</li><li><code>factory-method</code>：使用某静态工厂的方法创建对象；</li><li><code>factory-bean</code>：当把工厂类交给spring管理时，使用该标签指定工厂id，再使用factory-method指定工厂中的方法。</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><blockquote><p>上面的测试用例会发现打印出来都是null，因为默认调用的是无参构造函数，接下来就要开始注入灵魂。</p></blockquote><h4 id="2-1-构造函数注入"><a href="#2-1-构造函数注入" class="headerlink" title="2.1 构造函数注入"></a>2.1 构造函数注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;site.henrykang.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;stu_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;stu_gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;stu_birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;newDate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个日期对象加入容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;newDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>constructor-arg</code>属性说明</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>构造函数参数列表中对应参数的名称（推荐）</td></tr><tr><td>value</td><td>仅能赋值基本型和String型</td></tr><tr><td>ref</td><td>赋值其他由 spring 管理的 bean 类型的 id</td></tr><tr><td>index</td><td>指定在构造函数参数列表中的索引位置（不推荐）</td></tr><tr><td>type</td><td>指定在构造函数参数列表中的数据类型（不推荐）</td></tr></tbody></table><h4 id="2-2-set方法注入"><a href="#2-2-set方法注入" class="headerlink" title="2.2 set方法注入"></a>2.2 set方法注入</h4><blockquote><p>和上面大同小异，就标签名不同，属性只有 value 和 ref。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;site.henrykang.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stu_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stu_gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stu_birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;newDate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;newDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-P名称空间注入"><a href="#2-3-P名称空间注入" class="headerlink" title="2.3 P名称空间注入"></a>2.3 P名称空间注入</h4><blockquote><p>通过在 bean 标签内使用属性 p:propertyName 注入，本质还是set方法。</p><p>发现报红的话是因为没导入p标签的约束：</p><p>​    xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;site.henrykang.domain.Student&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">p:stu_id</span>=<span class="string">&quot;1003&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">p:stu_name</span>=<span class="string">&quot;张三&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">p:stu_gender</span>=<span class="string">&quot;男&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">p:stu_birthday-ref</span>=<span class="string">&quot;newDate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;newDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-集合类型注入"><a href="#2-4-集合类型注入" class="headerlink" title="2.4 集合类型注入"></a>2.4 集合类型注入</h4><blockquote><p>主要分两大类，同一大类的标签可以互用。</p></blockquote><ul><li>List型使用<code>&lt;list&gt;</code>、<code>&lt;array&gt;</code>、<code>&lt;set&gt;</code>标签与<code>&lt;value&gt;</code>、<code>&lt;ref&gt;</code>配合;</li><li>Map型使用<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签与<code>&lt;entry&gt;</code>、<code>&lt;prop&gt;</code>及<code>key(-ref)</code>、<code>value(-ref)</code>配合;</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;site.henrykang.domain.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>唱<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>跳<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>rap<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;career&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;2017&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大一&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;nowDate&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;xx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;2017&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>大一<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;2018&quot;</span>&gt;</span>大二<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;nowDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-IOC注解开发"><a href="#3-IOC注解开发" class="headerlink" title="3. IOC注解开发"></a>3. IOC注解开发</h3><ul><li>约束文件</li></ul><figure class="highlight xml"><figcaption><span>注解开发的xml约束 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- IoC注解配置约束 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在配置文件中告诉Spring要扫描的包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;site.henrykang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-常用注解"><a href="#3-1-常用注解" class="headerlink" title="3.1 常用注解"></a>3.1 常用注解</h4><ol><li><code>@Component</code> 相当于 <code>&lt;bean&gt;</code></li></ol><ul><li>默认id为当前类名(首字母小写), 也可以通过value属性修改;</li><li>三个子类, 作用一样, 只是为了方便标识<ul><li>表现层: <code>@Controller</code></li><li>业务层: <code>@Service</code></li><li>持久层: <code>@Repository</code></li></ul></li></ul><ol start="2"><li><code>@Autowired</code>相当于<code>&lt;property&gt;</code></li></ol><ul><li>过程：在容器中，先根据类型查找, 有唯一匹配的注入成功; 若有多个类型匹配, 则再进一步根据变量名称查找, 找到与变量名相同的的beanId则注入; 其他情况都会报错.</li><li>使用<code>@Qualifier</code>与<code>@resource</code>解决上述问题:<ul><li>@Qualifier(“id”) 要与@Autowired配合使用, 指明要注入的BeanId;<ul><li>在方法上可以单独使用;</li></ul></li><li>@Resource(<strong>name</strong>=”id”) 可以单独使用, 作用也是指明要注入的BeanId;<ul><li>注意使用的是@Resource的name属性;</li></ul></li></ul></li><li>使用<code>@Value</code>注入基本型和String型数据;<ul><li>配置了@PropertySource注解的时候可以使用使用SPEL表达式：@Value(“${jdbc.driver}”)；</li></ul></li></ul><ol start="3"><li><p><code>@Scope</code> 指定bean的作用范围；</p></li><li><p><code>@PreDestroy</code>与<code>@PostConstruct</code> 指定销毁与初始化方法。</p></li></ol><h4 id="3-2-全注解配置"><a href="#3-2-全注解配置" class="headerlink" title="3.2 全注解配置"></a>3.2 全注解配置</h4><blockquote><p>获取容器时需要使用AnnotationApplicationContext(注解配置类.class)。</p></blockquote><ol><li><code>@Configuration</code>：指定当前类是一个配置类；</li><li><code>@ComponentScan</code>：指定创建容器时要扫描的包；</li><li><code>@Bean</code>：只能写在方法上，表示将当前方法的返回值作为bean存入容器；<ul><li>name属性指定beanId，默认为方法名称；</li></ul></li><li><code>@Import</code>：导入其他配置类，value是配置类.class；</li><li><code>@PropertySource</code>：指定要使用的properties文件位置；<ul><li>类路径下要写上前面<code>classpath:</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;site.henrykang&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-整合Junit注解"><a href="#3-3-整合Junit注解" class="headerlink" title="3.3 整合Junit注解"></a>3.3 整合Junit注解</h4><blockquote><p>　　在执行测试方法时，JUnit根本不知道我们是不是使用了Spring框架，所以也就不会为我们读取配置文件、配置类去创建Spring核心容器，没有了容器，就算写了Autowired注解，也无法实现注入。</p><p>使用 spring 5.x版本的时候，要求 JUnit 的jar必须是4.12以上。</p></blockquote><ol><li>导入jar包</li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>测试类添加下面两个注解</li></ol><ul><li><p>@RunWith(SpringJUnit4ClassRunner.class)：声明替换程序入口为spring提供的；</p></li><li><p>@ContextConfiguration</p><ul><li><p>@ContextConfiguration(classes = SpringConfiguration.class)：指定注解配置类的位置；</p></li><li><p>@ContextConfiguration(locations = “classpath: bean.xml”)：指定xml配置文件的位置。</p></li></ul></li></ul><h3 id="4-AOP"><a href="#4-AOP" class="headerlink" title="4. AOP"></a>4. AOP</h3><blockquote><p>Aspect Oriented Programming 面向切面编程。</p></blockquote><h4 id="4-0-为什么要AOP"><a href="#4-0-为什么要AOP" class="headerlink" title="4.0 为什么要AOP"></a>4.0 为什么要AOP</h4><p><strong>了解一些名词：</strong></p><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Joinpoint</td><td align="left">连接点：程序运行过程中的某一点</td></tr><tr><td align="left">Pointcut</td><td align="left">切入点：一组我们要拦截切分的连接点</td></tr><tr><td align="left">Advice</td><td align="left">通　知：拦截之后要做的增强</td></tr><tr><td align="left">Target</td><td align="left">目　标：目标对象就是我们需要增强的业务对象</td></tr><tr><td align="left">Proxy</td><td align="left">代　理：为增强目标对象而产生的一个新的代理对象</td></tr><tr><td align="left"><strong>Aspect</strong></td><td align="left">切　面：将 Advice 抽取出来形成的一个模块</td></tr><tr><td align="left"><strong>Weaving</strong></td><td align="left">织　入：将 Aspect 加入到(拦截器)方法中为对象增加额外功能的过程</td></tr></tbody></table><p><strong>说明：</strong></p><p>　　Spring的AOP其实就是<strong>让Spring帮我们完成动态代理</strong>的过程。我们都知道想要对原方法进行增强而又不能修改其源码的时候可以选择使用动态代理，而AOP其实不光是为了增强而存在的，它更是为了将一些重复的业务逻辑代码进行抽取形成一个模块（即<strong>切面</strong>），在需要的地方进行复用（即<strong>织入</strong>）。而有的人就要问了，抽取重复代码不是抽取出一个公共方法就可以了吗？有些时候抽取一个公共方法出来其实并不是那么的容易，而且别忘了使用SpringAOP同时还达到了<strong>解耦</strong>的目的。</p><p><strong>一个关于数据库事务控制的例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xxxServiceImpl的伪码</span></span><br><span class="line">doSth1()&#123;</span><br><span class="line">beginTransaction();</span><br><span class="line">doSth1...</span><br><span class="line">    <span class="function"><span class="keyword">if</span> success then <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> rollback();</span><br><span class="line">    <span class="function"><span class="keyword">finally</span> <span class="title">endTransaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">doSth2()&#123;</span><br><span class="line">beginTransaction();</span><br><span class="line">doSth2...</span><br><span class="line">    <span class="function"><span class="keyword">if</span> success then <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> rollback();</span><br><span class="line">    <span class="function"><span class="keyword">finally</span> <span class="title">endTransaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">doSth3()&#123;...&#125;</span><br></pre></td></tr></table></figure><p>　　会发现相同的业务逻辑造成了大量的重复代码，而且因为每次doSth都不同，所以不好抽取重复代码；不仅如此，试想一下假设beginTransaction()变成了startTransaction()，那使用到它的每一个地方都要更改，这种耦合可以想办法消除一下，为此我们就可以想到使用动态代理。</p><h4 id="4-1-动态代理"><a href="#4-1-动态代理" class="headerlink" title="4.1 动态代理"></a>4.1 动态代理</h4><h5 id="4-1-1-Proxy"><a href="#4-1-1-Proxy" class="headerlink" title="4.1.1 Proxy"></a>4.1.1 Proxy</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">producer.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用：执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">* 方法参数的含义</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> proxy   代理对象的引用</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> method  当前执行的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args    当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>        和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//提供增强的代码</span></span><br><span class="line">Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxyProducer.saleProduct(<span class="number">10000f</span>); <span class="comment">//输出 8000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于接口的代理：<strong>被代理类最少实现一个接口</strong></li><li><code>newProxyInstance()</code>方法的参数：<ul><li>ClassLoader：类加载器，用于加载代理对象字节码的，和被代理对象使用相同的类加载器；</li><li>Interfaces：和被代理对象具有相同的行为，实现相同的接口；</li><li>InvocationHandler：用于提供增强的代码。</li></ul></li></ul><h5 id="4-1-2-cglib"><a href="#4-1-2-cglib" class="headerlink" title="4.1.2 cglib"></a>4.1.2 cglib</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer(); </span><br><span class="line">        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), </span><br><span class="line"><span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强的代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于子类的代理：<strong>被代理类不能是最终类</strong></li><li><code>create()</code>方法的参数：<ul><li>Class：字节码，用于指定被代理对象的字节码；</li><li>Callback：用于提供增强的代码，一般写其实现类MethodInterceptor。</li></ul></li></ul><h4 id="4-2-AOP的XML配置"><a href="#4-2-AOP的XML配置" class="headerlink" title="4.2 AOP的XML配置"></a>4.2 AOP的XML配置</h4><p>　　使用动态代理解决了我们的麻烦，但也得手工的为一个一个的被代理类制定增强规则，即便是大量的被代理类具有相同的增强规则，例如记录日志的工作。这时就轮到SpringAOP出场了，它将相同的增强规则抽取为一个<strong>切面</strong>，在<strong>切入点</strong>进行<strong>织入</strong>。</p><h5 id="4-2-1-基本步骤"><a href="#4-2-1-基本步骤" class="headerlink" title="4.2.1 基本步骤"></a>4.2.1 基本步骤</h5><figure class="highlight xml"><figcaption><span>bean.xml约束 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="0"><li><p>导入aspectjweaver.jar</p></li><li><p>将增强Bean交由Spring容器;</p></li><li><p><code>&lt;aop:config&gt;</code>声明aop配置;</p></li><li><p><code>&lt;aop:aspect&gt;</code>声明切面, 属性:</p><ul><li>id，切面id</li><li>ref，增强BeanId</li></ul></li><li><p>在<code>&lt;aop:aspect&gt;</code>内部织入</p><ul><li><code>&lt;aop:before&gt;</code>表示前置增强<ul><li>method：指定使用增强Bean中的哪个方法作为增强方法</li><li>pointcut：指定<strong>切入点</strong></li></ul></li><li>切入点表达式写法: execution(表达式)<ul><li>格式：<code>访问修饰符  返回值  包名...类名.方法名(参数列表)</code></li><li>访问修饰符可以省略，返回值、包名、类名、方法名可以使用通配符<code>*</code>；</li><li>几层包就要写几个<code>*</code>, 可以使用<code>..</code>来表示当前包及其子包；</li><li>参数列表写法：<ul><li>基本型直接写，引用型写全类名；</li><li>通配符<code>*</code>表示至少一个参数， <code>..</code>表示任意个参数；</li></ul></li><li>全通配写法: <code>* *..*.*(..)</code></li></ul></li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置增强Logger类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.istudy.utils.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置增强的类型，并且建立增强方法和切入点方法的关联--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">&quot;printLog&quot;</span><span class="attr">pointcut</span>=<span class="string">&quot;execution(*com.istudy.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-2-几类通知（4-1）"><a href="#4-2-2-几类通知（4-1）" class="headerlink" title="4.2.2 几类通知（4+1）"></a>4.2.2 几类通知（4+1）</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切入点在切面内, 只能供一个切面使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切入点在切面外, 可以使所有切面共用, 但是必须写在切面前面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.istudy.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置前置增强：在切入点方法执行之前执行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforePrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置后置增强：在切入点方法正常执行之后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置异常增强：在切入点方法执行产生异常之后执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置最终增强：无论切入点方法是否正常执行它都会在其后面执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置环绕增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;aroundPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>环绕增强需要特别明确切入点的调用 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">Object rtValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;</span>);</span><br><span class="line"></span><br><span class="line">rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rtValue;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-AOP的注解配置"><a href="#4-3-AOP的注解配置" class="headerlink" title="4.3 AOP的注解配置"></a>4.3 AOP的注解配置</h4><figure class="highlight xml"><figcaption><span>bean.xml约束 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.istudy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置spring开启注解AOP的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">注解</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">@Aspect</td><td align="left">表示当前类是一个切面类</td></tr><tr><td align="left">@Pointcut<br />private void pt1(){}</td><td align="left">配置切入点表达式，<br />在一个方法上面声明，方法名就是表达式id</td></tr><tr><td align="left"><code>@Before(&quot;切入点表达式()&quot;) </code>方法括号必须带</td><td align="left">在切入点方法执行之前执行</td></tr><tr><td align="left">@AfterReturning(“pt1()”)</td><td align="left">在切入点方法正常执行之后执行</td></tr><tr><td align="left">@AfterThrowing(“pt1()”)</td><td align="left">在切入点方法发生异常后执行</td></tr><tr><td align="left">@After(“pt1()”)</td><td align="left">在切入点方法执行之后执行</td></tr><tr><td align="left">@Around(“pt1()”)</td><td align="left">环绕增强</td></tr></tbody></table><p><strong>注意：</strong></p><p>　　当使用@Before、@After…四个注解进行增强配置时，<strong>最终通知会在后置/异常通知前执行</strong>；而使用@Around环绕增强时，因为我们显示的声明了何时调用切入点方法，所以不会出现这个问题。</p><p>　　不使用bean.xml，即全注解配置时，需要在配置类前加上注解：<code>@EnableAspectJAutoProxy</code>。</p><h4 id="4-4-Spring-中的事务控制"><a href="#4-4-Spring-中的事务控制" class="headerlink" title="4.4 Spring 中的事务控制"></a>4.4 Spring 中的事务控制</h4><blockquote><p>事务控制很重要，而且也非常能体现AOP的特点，Spring当然也为我们提供了事务控制的相关方法。</p></blockquote><ul><li>导包或坐标：<code>spring-tx...</code>、<code>spring-jdbc...</code></li><li>tx 相关的约束：<code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></li></ul><h5 id="4-4-1-相关的类与接口"><a href="#4-4-1-相关的类与接口" class="headerlink" title="4.4.1 相关的类与接口"></a>4.4.1 相关的类与接口</h5><ul><li><p><code>PlatformTransactionManager</code>接口：事务管理器</p><ul><li><p>getTransaction(<strong>TransactionDefinition</strong> definititon)</p></li><li><p>getTransaction(<strong>TransactionStatus</strong> status)</p></li><li><p>rollback(TransactionStatus status)</p></li><li><p>我们使用Spring为我们提供好的实现类：</p><p><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></p></li></ul></li><li><p><code>TransactionDefinition</code>接口：定义事务</p><ul><li>getPropagationBehavior()：获取事务传播行为<ul><li>PROPAGATION_REQUIRED：默认，如果当前没有事务就创建一个，若有则加入该事务；</li><li>PROPAGATION_SUPPORTS：支持当前事务，若没有事务就以非事务的方式执行；</li><li>PROPAGATION_MANDATORY：使用当前的事务，若当前没有事务，抛异常；</li><li>PROPAGATION_REQUIRES_NEW：挂起当前事务，新建一个；</li><li>PROPAGATION_NOT_SUPPORTED：挂起当前事务，以非事务的方式执行下面的操作；</li><li>PROPAGATION_NEVER：以非事务的方式运行，若当前有事务，抛异常；</li><li>PROPAGATION_NESTED：嵌套事务执行；</li></ul></li><li>getIsolationLevel()：获取事务隔离级别<ul><li>ISOLATION_DEFAULT = -1：默认与所用数据库隔离级别一致；</li><li>ISOLATION_READ_UNCOMMITTED：读未提交；</li><li>ISOLATION_READ_COMMITTED：读已提交，解决脏读；</li><li>ISOLATION_REPEATABLE_READ：可重复度，解决不可重复读，MySQL默认；</li><li>ISOLATION_SERIALIZABLE：可串行化，解决幻读；</li></ul></li><li>getTimeout()：获取事务超时时间<ul><li>int 秒值，默认 -1 永不超时；</li></ul></li><li>isReadOnly()：事务是否只读</li><li>getName()：获取事务对象名称</li></ul></li><li><p><code>TransactionStatus</code>接口：获取事务状态</p><ul><li>isNewTransaction()：是否为新事务；</li><li>hasSavepoint()：是否存在存储点；</li><li>setRollbackOnly()：设置事务回滚；</li><li>isRollbackOnly()：是否回滚；</li><li>flush()：刷新事务；</li><li>isCompleted()：是否完成；</li></ul></li></ul><h5 id="4-4-2-XML配置步骤"><a href="#4-4-2-XML配置步骤" class="headerlink" title="4.4.2 XML配置步骤"></a>4.4.2 XML配置步骤</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.配置事务管理器，相当于增强Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.配置事务增强和增强Bean绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置事务属性：</span></span><br><span class="line"><span class="comment">- read-only：是否只读，默认false；</span></span><br><span class="line"><span class="comment">- isolation：隔离级别，默认和数据库一致；</span></span><br><span class="line"><span class="comment">- propagation：传播行为；</span></span><br><span class="line"><span class="comment">- timeout：超时时间；</span></span><br><span class="line"><span class="comment">- rollback-for：指定一个异常，当其发生时，事务回滚；产生其他异常时，不回滚；</span></span><br><span class="line"><span class="comment">- no-rollback-for：和上面相反，指定一个异常，只有当该异常发生时，事务才回滚；</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4.配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切入点表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span>  <span class="attr">expression</span>=<span class="string">&quot;execution(*  com.istudy.service.impl.*.*(..))&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将事务的配置与切入点绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 入门笔记</title>
      <link href="JavaEE/Back%20End/MyBatis.html"/>
      <url>JavaEE/Back%20End/MyBatis.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　MyBatis是一个基于Java的持久层框架，基于 ORM（对象关系映射）的思想解决pojo与数据库表的映射关系，分离了数据层与逻辑层，封装了JDBC，使我们只用去关注sql即可。</p></blockquote><ul><li>传统 JDBC 存在的问题: <ol><li>操作繁琐：注册驱动、创建connection、statement、resultset、释放资源……</li><li>动态sql的问题：使用StringBuilder拼接动态sql，使用List封装参数toArray传给占位符 ……</li><li>……</li></ol></li><li>mybatis和hibernate：<ul><li>hibernate 都是基于orm思想的持久层框架，hibernate封装性较mybatis强，它有着自己的一套HQL，学习成本比较高，因为过度的封装处理复杂业务时的灵活度就较差；但它也有一个好处就是容易更换底层的数据库实现，因为使用HQL作为了一层中间层，更换数据库就是将HQL映射到不同的数据库方言。</li></ul></li></ul><a id="more"></a><h3 id="1-Hello-MyBatis"><a href="#1-Hello-MyBatis" class="headerlink" title="1. Hello MyBatis"></a>1. Hello MyBatis</h3><h4 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h4><ol><li><p>创建maven工程并导入坐标</p><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>创建数据库表、实体类和dao的接口</p><figure class="highlight sql"><figcaption><span>sql >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    stu_id <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    stu_name <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="built_in">char</span>(<span class="number">1</span>),</span><br><span class="line">    stu_birthday <span class="built_in">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>实体类和dao >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stu_id;</span><br><span class="line">    <span class="keyword">private</span> String stu_name;</span><br><span class="line">    <span class="keyword">private</span> String stu_gender;</span><br><span class="line">    <span class="keyword">private</span> Date stu_birthday;</span><br><span class="line"><span class="comment">// getter and setter……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudnetDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mybatis的主配置文件 <code>SqlMapConifg.xml</code></p></li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置mysql的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置事务类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据源（连接池）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置连接数据库的信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/?&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;?&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;?&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定映射配置文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;映射文件路径&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在resources中创建和dao接口路径相对应的映射文件 <code>IXXXDao.xml</code></li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;接口全类名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;实体类全类名&quot;</span>&gt;</span></span><br><span class="line">        sql语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当接口和映设文件目录结构相同，映射文件中<code>namespace</code>为接口全类名，<code>id</code>为方法名时，可以不写DaoImpl;</li></ul><h4 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//1 读取配置问文件</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//2 创建sqlSessionFactory工厂</span></span><br><span class="line">    <span class="comment">// &gt;构建者模式(隐藏细节)</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    SqlSessionFactory factory = builder.build(in);</span><br><span class="line">    <span class="comment">//3 使用工厂创建sqlSession对象</span></span><br><span class="line">    <span class="comment">// &gt;工厂模式(解耦)</span></span><br><span class="line">    <span class="comment">// 传递参数 true 自动提交事务</span></span><br><span class="line">    SqlSession session = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//4 使用sqlSession对象创建dao接口的代理对象</span></span><br><span class="line">    <span class="comment">// &gt;代理模式(增强方法)</span></span><br><span class="line">    IStudnetDao StudentDao = session.getMapper(IStudnetDao.class);</span><br><span class="line">    <span class="comment">//5 使用代理执行方法</span></span><br><span class="line">    List&lt;Student&gt; Students = StudentDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (Student s : Students) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6 释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-单表简单CRUD"><a href="#1-3-单表简单CRUD" class="headerlink" title="1.3 单表简单CRUD"></a>1.3 单表简单CRUD</h4><blockquote><p>　　数据库字段和pojo属性名不一致时，可以在查询时使用别名，但显然不方便；可以使用resultMap参数配置字段和属性的映射关系，在后面的多表查询中说明，这里先让字段与属性名相同。</p></blockquote><figure class="highlight xml"><figcaption><span>IStudnetDao.xml >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.IStudnetDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.Student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from student where stu_id = #&#123;stu_id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">        insert into student values(#&#123;stu_id&#125;,#&#123;stu_name&#125;,#&#123;stu_gender&#125;,#&#123;stu_birthday&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from student where stu_id = #&#123;stu_id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">        update student set stu_name = #&#123;stu_name&#125;,stu_gender = #&#123;stu_gender&#125;,stu_birthday = #&#123;stu_birthday&#125; where stu_id = #&#123;stu_id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>TestCRUD.java >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCRUD</span> </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">    IStudnetDao StudentDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        session = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">        StudentDao = session.getMapper(IStudnetDao.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAllAndDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; Students = StudentDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Student u : Students) &#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;女&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        StudentDao.insert(stu);</span><br><span class="line">        System.out.println();</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">        StudentDao.deleteById(<span class="number">1</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;女&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        StudentDao.update(stu);</span><br><span class="line">        System.out.println();</span><br><span class="line">        findAllAndDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student stu = StudentDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>标签或参数解释：<ol><li>resultMap 配置列名和字段名对应关系；</li><li>resultType 返回值类型；</li><li>parameterType 传入参数类型；<ul><li>具体参数写法： <code>#&#123;属性名&#125;</code>，如：<code>#&#123;stu_id&#125;</code>；</li><li>属性包含另一个类的对象写法： <code>#&#123;属性对象.属性&#125;</code>， 如： <code>#&#123;user.userID&#125;</code>；</li><li><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别：#相当于<code>？</code>可以防止SQL注入，$只是字符串的拼接。</li></ul></li></ol></li></ul><h4 id="1-4-主配置文件中的几个标签"><a href="#1-4-主配置文件中的几个标签" class="headerlink" title="1.4 主配置文件中的几个标签"></a>1.4 主配置文件中的几个标签</h4><ol><li><code>&lt;properties&gt;</code> <ul><li>直接在&lt;properties&gt;标签下配置子标签&lt;property name = ? , value = ? &gt;;</li><li>有两个属性可以指定外部配置文件;<ul><li><code>&lt;resource = ?&gt;</code>只能指定存在于类路径下的文件;</li><li><code>&lt;url = ?&gt;</code>可以指定任意位置的文件;</li></ul></li><li>配置完成后, 可以使用<code>$&#123;name&#125;</code> 引用.</li></ul></li></ol><ol start="2"><li><code>&lt;typeAliases&gt;</code>标签中给实体类注册别名(不区分大小写)，有两个子标签 :<ul><li>指定某一个类 <ul><li>&lt;typeAlias type=”com.istudy.domain.User” alias=”user”&gt;&lt;/typeAlias&gt;</li></ul></li><li>配置包下所有类(类名就是别名)<ul><li>&lt;package name=”com.istudy.domain”&gt;&lt;/package&gt;</li></ul></li><li>配置完成后, 输入输出参数类型可以不写全类名, 用别名代替.</li></ul></li></ol><ul><li>约束要求将其配置在最前面；</li></ul><ol start="3"><li><code>&lt;mappers&gt;</code>下子标签<code>&lt;package&gt;</code>配置DAO接口所在的包;<ul><li>&lt;package name=”com.istudy.dao”&gt;&lt;/package&gt;</li><li>配置完成后, 不用再使用resource或class指定映射配置文件路径，会自动扫描.</li></ul></li></ol><hr><h3 id="2-多表查询与动态sql"><a href="#2-多表查询与动态sql" class="headerlink" title="2. 多表查询与动态sql"></a>2. 多表查询与动态sql</h3><h4 id="2-1-动态sql"><a href="#2-1-动态sql" class="headerlink" title="2.1 动态sql"></a>2.1 动态sql</h4><ul><li>注意<code>where</code>、<code>and</code>与不要写<code>;</code></li></ul><ol><li><code>&lt;if&gt;</code> </li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.Student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stu_name != null&quot;</span>&gt;</span></span><br><span class="line">        and stu_name = #&#123;stu_name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>&lt;where&gt;</code> 可以省略”where 1 = 1”</li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;domain.Student&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stu_name != null&quot;</span>&gt;</span></span><br><span class="line">            and stu_name = #&#123;stu_name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stu_gender != null&quot;</span>&gt;</span></span><br><span class="line">            and stu_gender = #&#123;stu_gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>&lt;foreach&gt;</code> 解决 in 查询问题</li></ol><figure class="highlight java"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个类封装查询参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; stu_ids;</span><br><span class="line"><span class="comment">// getter and setter ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findInIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;domain.QueryVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stu_ids != null and stu_ids.size()&gt;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;stu_ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and stu_id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">                #&#123;stu_id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>&lt;include&gt;</code> sql 复用</li></ol><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 抽取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectAllStu&quot;</span>&gt;</span><span class="comment">&lt;!-- id唯一标识一条sql --&gt;</span></span><br><span class="line">   select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectAllStu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where ...</span><br></pre></td></tr></table></figure><h4 id="2-2多表查询"><a href="#2-2多表查询" class="headerlink" title="2.2多表查询"></a>2.2多表查询</h4><blockquote><p>两种办法 :</p><ol><li>创建一个新类, 太难受, 不用;</li><li>由 “has a” 确定组合关系，使用 resultMap 进行映射配置;</li></ol></blockquote><figure class="highlight plain"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#再建仨表：course课程表、sc选课表、学生卡card</span><br><span class="line">CREATE TABLE &#96;course&#96; (</span><br><span class="line">  &#96;course_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;course_name&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;course_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;sc&#96; (</span><br><span class="line">  &#96;sc_id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;stu_id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;course_id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;sc_id&#96;),</span><br><span class="line">  KEY &#96;stu_id&#96; (&#96;stu_id&#96;),</span><br><span class="line">  KEY &#96;course_id&#96; (&#96;course_id&#96;),</span><br><span class="line">  CONSTRAINT &#96;sc_ibfk_1&#96; FOREIGN KEY (&#96;stu_id&#96;) REFERENCES &#96;student&#96; (&#96;stu_id&#96;) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">  CONSTRAINT &#96;sc_ibfk_2&#96; FOREIGN KEY (&#96;course_id&#96;) REFERENCES &#96;course&#96; (&#96;course_id&#96;) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;card&#96; (</span><br><span class="line">  &#96;stu_id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;card_id&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;card_id&#96;),</span><br><span class="line">  KEY &#96;stu_id&#96; (&#96;stu_id&#96;),</span><br><span class="line">  CONSTRAINT &#96;card_ibfk_1&#96; FOREIGN KEY (&#96;stu_id&#96;) REFERENCES &#96;student&#96; (&#96;stu_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br><span class="line"># 创建相应的实体类，建立相应的组合关系</span><br></pre></td></tr></table></figure><h5 id="2-2-1-一对一"><a href="#2-2-1-一对一" class="headerlink" title="2.2.1 一对一"></a>2.2.1 一对一</h5><ul><li>关键字<code>association</code> &amp; <code>javaType</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- student has a card，所以在student中添加card属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询所有学生及其学生卡信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentCardMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_gender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_birthday&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  1.级联方式：（不太推荐）</span></span><br><span class="line"><span class="comment">    即直写方式，但是由于外围type是student，所以访问student中的card自身的属性时需要用‘.’</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;card.card_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;card_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;card.stu_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  2.association方式：（推荐）</span></span><br><span class="line"><span class="comment">相较于级联方式，比较清晰，能直接看出来card是Student中的另一个实体属性；</span></span><br><span class="line"><span class="comment">property：Card类在Student类中的成员名称；</span></span><br><span class="line"><span class="comment">Javatype：指定Card类的全类名；</span></span><br><span class="line"><span class="comment">有了上面两个属性，就可以确定card，所以访问card的属性时，不需要&#x27;.&#x27;。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;card&quot;</span>  <span class="attr">javaType</span>=<span class="string">&quot;domain.Card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;card_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;card_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllStuNameAndCardId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentCardMap&quot;</span>&gt;</span></span><br><span class="line">    select * from student,card where student.stu_id = card.stu_id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-一对多查询"><a href="#2-2-2-一对多查询" class="headerlink" title="2.2.2 一对多查询"></a>2.2.2 一对多查询</h5><ul><li>关键字<code>collection</code> &amp; <code>ofType</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询一个学生的选课情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;stuCourseMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_gender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_birthday&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">property：指定Student中的course集合的属性名称;</span></span><br><span class="line"><span class="comment">ofType：指定集合中元素类型全类名； </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;courses&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;domain.Course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;course_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;course_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;course_name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;course_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOneStuAndCourses&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;stuCourseMap&quot;</span>&gt;</span></span><br><span class="line">    select student.*,course.* from student,sc,course where student.stu_name = #&#123;stu_name&#125; and student.stu_id = sc.stu_id and sc.course_id = course.course_id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-3-多对多"><a href="#2-2-3-多对多" class="headerlink" title="2.2.3 多对多"></a>2.2.3 多对多</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询所有学生的选课情况 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 复用了stuCourseMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllStuAndCourses&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;stuCourseMap&quot;</span>&gt;</span></span><br><span class="line">    select * from student,sc,course where student.stu_id = sc.stu_id and sc.course_id = course.course_id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>总结：对一使用association与javaType；对多使用collection与ofType；</li></ul><hr><h3 id="3-延时加载与缓存"><a href="#3-延时加载与缓存" class="headerlink" title="3. 延时加载与缓存"></a>3. 延时加载与缓存</h3><h4 id="3-1-延时加载"><a href="#3-1-延时加载" class="headerlink" title="3.1 延时加载"></a>3.1 延时加载</h4><blockquote><p>本质是分步查询，先单表查询，使用到相关数据时，再使用单表查询的结果去关联查询多表。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局配置文件中设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><figcaption><span>association</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    改造上面的一对一：查询所有学生及其学生卡信息； </span></span><br><span class="line"><span class="comment">    先查出所有student，再根据stuId查询对应的card信息；</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentCardMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_gender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;stu_birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;stu_birthday&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentCardMap&quot;</span>&gt;</span></span><br><span class="line">    select * from student;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-缓存"><a href="#3-2-缓存" class="headerlink" title="3.2 缓存"></a>3.2 缓存</h4><blockquote><p>经常被访问但不常发生变化的数据可以缓存; </p></blockquote><ol><li>一级缓存<br>一级缓存由<strong>SqlSession</strong>对象提供, 当我们进行<strong>增删改</strong>操作或者释放sqlSession对象时, 一级缓存被清空或释放.</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 关闭一级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STATEMENT&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>二级缓存<br>二级缓存由<strong>SqlSessionFactory</strong>对象提供, 由同一个Factory对象创建的SqlSession共享其缓存数据;</li></ol><p>　　<strong>使用二级缓存实体类必须 实现Serializable；</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主配置文件添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 映射文件添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 具体的select添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>属性 useCache=&quot;true&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="4-注解使用"><a href="#4-注解使用" class="headerlink" title="4. 注解使用"></a>4. 注解使用</h3><table><thead><tr><th align="left">注解</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">@Insert</td><td align="left">新增</td></tr><tr><td align="left">@Delete</td><td align="left">删除</td></tr><tr><td align="left">@Update</td><td align="left">修改</td></tr><tr><td align="left">@Select</td><td align="left">查询</td></tr><tr><td align="left">@Result</td><td align="left">结果集封装</td></tr><tr><td align="left">@Results</td><td align="left">与@Result 一起使用，封装多个结果集</td></tr><tr><td align="left">@ResultMap</td><td align="left">引用@Results 定义的map</td></tr><tr><td align="left">@One</td><td align="left">对一结果集封装</td></tr><tr><td align="left">@Many</td><td align="left">对多结果集封装</td></tr><tr><td align="left">@SelectProvider</td><td align="left">动态 SQL</td></tr><tr><td align="left">@CacheNamespace(blocking=true)</td><td align="left">二级缓存使用</td></tr><tr><td align="left">fetchType=FetchType.LAZY/EAGER</td><td align="left">配置延迟加载，会覆盖全局的配置参数 lazyLoadingEnabled</td></tr></tbody></table><p>简单的单表crud不再记录：</p><ol><li>一对一，查询所有学生及其学生卡信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ICardDao</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from card where card.stu_id = #&#123;stu_id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ResultType(Card.class)</span></span><br><span class="line"><span class="function">Card <span class="title">findCardByStuId</span><span class="params">(<span class="meta">@Param(&quot;stu_id&quot;)</span> <span class="keyword">int</span> stuId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IStudentDao</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from student&quot;)</span></span><br><span class="line">    <span class="meta">@Results(id = &quot;studentCardMap&quot;,</span></span><br><span class="line"><span class="meta">            value = &#123;</span></span><br><span class="line"><span class="meta">                    @Result(id = true, property = &quot;stu_id&quot;,column = &quot;stu_id&quot;),</span></span><br><span class="line"><span class="meta">                    @Result(property = &quot;stu_name&quot;,column = &quot;stu_name&quot;),</span></span><br><span class="line"><span class="meta">                    @Result(property = &quot;stu_gender&quot;,column = &quot;stu_gender&quot;),</span></span><br><span class="line"><span class="meta">                    @Result(property = &quot;stu_birthday&quot;,column = &quot;stu_birthday&quot;),</span></span><br><span class="line"><span class="meta">                    @Result(property = &quot;card&quot;,column = &quot;stu_id&quot;,one=@One(select = &quot;dao.ICardDao.findCardByStuId&quot;,fetchType = FetchType.EAGER))</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStuNameAndCardId</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>开启二级缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主配置文件中</span></span><br><span class="line">&lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line"><span class="comment">// 响应接口上</span></span><br><span class="line"><span class="meta">@CacheNamespace(blocking=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudnetDao</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 入门笔记</title>
      <link href="JavaEE/Back%20End/Maven.html"/>
      <url>JavaEE/Back%20End/Maven.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p><strong>官方介绍</strong></p><p>Maven, a <a href="https://en.wikipedia.org/wiki/Maven">Yiddish word</a> meaning <em>accumulator of knowledge</em>, began as an attempt to simplify the build processes in the Jakarta Turbine project. There were several projects, each with their own Ant build files, that were all slightly different. JARs were checked into CVS. We wanted <strong>a standard way to build the projects, a clear definition of what the project consisted of, an easy way to publish project information and a way to share JARs across several projects.</strong></p><p>Maven 是一个项目管理工具, 帮助我们 清理、编译、测试、打包、发布项目……</p></blockquote><a id="more"></a><h3 id="1-Hello-Maven"><a href="#1-Hello-Maven" class="headerlink" title="1. Hello Maven"></a>1. Hello Maven</h3><h4 id="1-1-安装maven"><a href="#1-1-安装maven" class="headerlink" title="1.1 安装maven"></a>1.1 安装maven</h4><ol><li>官网下载,  解压到没有中文和空格的目录下即可;</li><li>配置 MAVEN_HOME 与 PATH 环境变量;</li><li>要正确配置JAVA_HOME；<ul><li>若使用的Maven版本较新的话，要去官网查看对应的版本所需最低的JDK要求;</li></ul></li><li>cmd 输入 <code>mvn -v</code> 检验是否安装成功;</li></ol><h4 id="1-2-配置本地仓库-amp-中央仓库"><a href="#1-2-配置本地仓库-amp-中央仓库" class="headerlink" title="1.2 配置本地仓库 &amp; 中央仓库"></a>1.2 配置本地仓库 &amp; 中央仓库</h4><blockquote><p>核心配置文件<code>/conf/settings.xml</code>;<br>本地仓库没有找到所需资源时, 会去中央仓库下载, 而国外镜像下载较慢, 所以我们切换到aliyun镜像;</p></blockquote><ol><li>网上搜索下载一个较全面的maven本地仓库;</li><li>在<code>settings.xml</code>中配置标签<code>&lt;localRepository&gt;</code>为本地仓库路径;</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\DevelopmentKit\maven_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>继续在<code>&lt;mirrors&gt;</code>标签体中配置如下<code>&lt;mirror&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意:</strong> <code>/conf</code>下的setting称为全局配置文件, 在windows用户目录下<code>.m2</code>下 还可以声明一个用户配置文件, 优先使用用户配置文件. 如果修改了全局配置文件, 死活都没有生效, 就要考虑是不是有用户配置文件. 使用IDE创建maven工程时可以选择配置信息. </li></ul><h4 id="1-3-Maven常用命令"><a href="#1-3-Maven常用命令" class="headerlink" title="1.3 Maven常用命令"></a>1.3 Maven常用命令</h4><blockquote><p>先只记一些笼统的命令, 便于理解maven的生命周期, 还有很多具体的命令细节参数等, 以后用到再做补充.</p></blockquote><p> <img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/20200215095017.png"></p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">mvn  clean</td><td align="left">清理之前编译出的文件（编译的文件放在tagart文件夹中）</td></tr><tr><td align="left">mvn  compile</td><td align="left">编译除了test</td></tr><tr><td align="left">mvn  test</td><td align="left">编译所有包括test</td></tr><tr><td align="left">mvn  package</td><td align="left">编译所有且打包</td></tr><tr><td align="left">mvn  install</td><td align="left">编译所有并打包且安装到本地仓库</td></tr><tr><td align="left">mvn  deploy</td><td align="left">部署到远程仓库</td></tr></tbody></table><h4 id="1-4-IDEA创建Maven工程"><a href="#1-4-IDEA创建Maven工程" class="headerlink" title="1.4 IDEA创建Maven工程"></a>1.4 IDEA创建Maven工程</h4><ol><li><p>IDEA设置中配置Maven根目录与配置文件位置等信息;</p></li><li><p>新建一个maven工程, 选择使用 archetype 为 webapp;</p></li><li><p><code>pom.xml</code>中添加依赖:</p><ul><li>依赖范围说明</li></ul><table><thead><tr><th align="left">scope</th><th align="center">编译</th><th align="center">运行</th><th align="center">测试</th><th>例子</th></tr></thead><tbody><tr><td align="left">compile(默认)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td></td></tr><tr><td align="left">test</td><td align="center"></td><td align="center"></td><td align="center">√</td><td>junit</td></tr><tr><td align="left">provided</td><td align="center">√</td><td align="center"></td><td align="center">√</td><td>jsp、servlet</td></tr><tr><td align="left">runtime</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td>jdbc</td></tr><tr><td align="left">system</td><td align="center">√</td><td align="center"></td><td align="center">√</td><td></td></tr></tbody></table><ul><li>system：类似于 provided，区别在于声明为system则不会去仓库找jar包，而是需要显式的提供jar包；</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>pom.xml</code>的<code>&lt;build&gt;&lt;plugins&gt;</code>中配置maven编译插件和tomcat插件；</li></ol><ul><li>为什么要配置这两个插件?<ul><li>因为maven默认的编译版本不符合我们的要求；</li><li>可以使用idea的live template配置；</li></ul></li><li>配置tomcat插件成功后, 可以在plugins下看到 tomcat 的相关命令, 点击tomcat:run 即可运行;</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>setting.xml</code>下<code>&lt;profiles&gt;</code>标签内可以全局设置编译版本, 这样就不用每次在pom中配置编译插件了,  如下:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-Maven-项目目录结构"><a href="#1-4-Maven-项目目录结构" class="headerlink" title="1.4 Maven 项目目录结构"></a>1.4 Maven 项目目录结构</h4><ul><li>普通 Java 工程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-src</span><br><span class="line">|  --main</span><br><span class="line">|    ---java</span><br><span class="line">|    ---resources</span><br><span class="line">|  --test</span><br><span class="line">|    ---java</span><br><span class="line">|    ---resources</span><br><span class="line">|-target</span><br><span class="line">|-pom.xml</span><br></pre></td></tr></table></figure><ul><li>Java Web 工程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-src</span><br><span class="line">|  --main</span><br><span class="line">|    ---java</span><br><span class="line">|    ---resources</span><br><span class="line">|    ---webapp</span><br><span class="line">|      ----WEB-INF</span><br><span class="line">|        -----web.xml web项目核心配置文件</span><br><span class="line">|        -----classes 放置src编译后的字节码</span><br><span class="line">|        -----lib  放置依赖的jar包</span><br><span class="line">|  --test</span><br><span class="line">|    ---java</span><br><span class="line">|    ---resources</span><br><span class="line">|-pom.xml</span><br></pre></td></tr></table></figure><p>　　maven创建的web工程<strong>资源路径</strong>写法要注意：不写<code>/</code>会在 resources 下寻找，写<code>/</code>会在classes中寻找。</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax &amp; JSON</title>
      <link href="JavaEE/Front%20End/Ajax%E4%B8%8EJSON.html"/>
      <url>JavaEE/Front%20End/Ajax%E4%B8%8EJSON.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　<strong>异步的 JavaScript 和 XML</strong>（Asynchronous JavaScript and XML，AJAX），是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。减少了不必要的请求，提升了用户的体验。</p><p>　　<strong>JavaScript对象表示法</strong>（JavaScript Object Notation，JSON），是存储和交换文本信息的语法，类似 XML。早期就是JS用来表示对象的一种语法，由于JSON比XML更易传输和解析，后来使用的越来越广泛。回想JS创建对象的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">firstname : <span class="string">&quot;k&quot;</span>,</span><br><span class="line">lastname  : <span class="string">&quot;hy&quot;</span>,</span><br><span class="line">id        : <span class="number">1234</span>，</span><br><span class="line">talk : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.firstname+<span class="built_in">this</span>.lastname+<span class="built_in">this</span>.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　</p><a id="more"></a><hr><h3 id="1-JQuery方式实现AJAX请求"><a href="#1-JQuery方式实现AJAX请求" class="headerlink" title="1. JQuery方式实现AJAX请求"></a>1. JQuery方式实现AJAX请求</h3><blockquote><p><a href="https://www.runoob.com/jquery/jquery-ref-ajax.html">菜鸟教程JQuery实现AJAX</a></p></blockquote><ul><li><code>$.ajax(&#123;键值对&#125;)</code><ul><li>url：请求路径；</li><li>type：请求方式；</li><li>dataType：响应结果的类型；<ul><li>如果不设置则浏览器会根据响应头的content-type自动设置；</li></ul></li><li>data：请求参数，格式可以为键值对或 <strong>JSON</strong>；</li><li>success：响应后执行的函数，用于操作数据；</li><li>error：响应失败后执行的函数；</li><li>……</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;ajaxServlet1111&quot;</span>,</span><br><span class="line">    type:<span class="string">&quot;POST&quot;</span>, </span><br><span class="line">    dataType:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">    <span class="comment">//data: &quot;username=hyk&amp;age=20&quot;,</span></span><br><span class="line">    data:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;hyk&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>$.get(url,data,callback,dataType)</code><ul><li>url：请求路径；</li><li>data：请求参数；</li><li>callback：回调函数；</li><li>dataType：响应结果的类型；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&quot;ajaxServlet&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;rose&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">alert(data);</span><br><span class="line">&#125;,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>$.post(url,data,callback,dataType)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">&quot;ajaxServlet&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;rose&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">alert(data);</span><br><span class="line">&#125;,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure><p>　　</p><hr><h3 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2. JSON"></a>2. JSON</h3><h4 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h4><ul><li><p><strong>语法规则</strong></p><p>数据以键值对保存，各个数据由逗号隔开，大括号保存对象，中括号保存数组。</p><p>　　获取元素通过 <code>对象.key</code>、<code>对象[&quot;key&quot;]</code>，数组对象通过下标获取 <code>数组[index]</code>。</p><p>　　如下表示 sites 数组中有三个对象，对象的属性是name和url，sites本身是个对象所以也有大括号包裹。注意键值要加引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;sites&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;菜鸟教程&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.runoob.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;微博&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.weibo.com&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 JS 中等价于：</span></span><br><span class="line"><span class="keyword">var</span> sites = [</span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;runoob&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.runoob.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;微博&quot;</span> , <span class="string">&quot;url&quot;</span>:<span class="string">&quot;www.weibo.com&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line">sites[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;菜鸟&quot;</span>;</span><br><span class="line">sites[<span class="number">1</span>].name = <span class="string">&quot;谷歌&quot;</span>;</span><br><span class="line"><span class="comment">// 遍历打印对象</span></span><br><span class="line"><span class="comment">// 使用let是因为for循环不是函数，使用var声明的都是全局变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sites.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> site = sites[i];</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> key <span class="keyword">in</span> site</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里不能使用site.key获取，因为key是一个字符串</span></span><br><span class="line"><span class="built_in">document</span>.write(key+<span class="string">&quot;:&quot;</span>+site[key]);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>数据类型</strong></p><p>可以是数字型（整数或浮点数）、字符串（在双引号中）、逻辑值（true 或 false）、数组（在中括号中）、对象（在大括号中）、null。</p></li></ul><h4 id="2-2-与Java对象的转换"><a href="#2-2-与Java对象的转换" class="headerlink" title="2.2 与Java对象的转换"></a>2.2 与Java对象的转换</h4><p>　　JavaScript 与 AJAX 天然的支持 JSON，而Java不支持，我们就需要对其进行转换。</p><ul><li><p>使用Jackson解析器的步骤：</p><ul><li><p>导入jar包；</p></li><li><p>创建Jackson的核心对象<code>ObjectMapper</code>；</p></li><li><p>调用相关方法；</p><ul><li><code>om.readValue(jsonStr,Class)</code>：JSON → Java对象</li><li><code>om.writeValue(parameter，obj)</code>：Java对象 → JSON</li><li><code>om.writeValueAsString(obj)</code>：Java对象 → jsonStr</li></ul></li><li><p>parameter：</p><ul><li><p>Writer：将obj转换为JSON串并写入到字符输出流；</p></li><li><p>OutputStream：将obj转换为JSON串并写入到字节输出流；</p></li><li><p>File：将obj转换为JSON串并存储到指定文件；</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="JavaEE/Front%20End/JSP.html"/>
      <url>JavaEE/Front%20End/JSP.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　Java服务器端页面（JSP，Java Server Pages），是一种以 Java 作为脚本语言的运行在服务端的语言，为程序员响应用户请求而动态生成页面提供了便利。它在本质上是一个Servlet，当浏览器发起对JSP的请求时，服务器找到相应的JSP资源转换输出为Servlet，再编译成为class字节码文件加载进 JVM，创建servlet对象，调用service方法。</p><p>　　验证：Tomcat自带的启动默认访问的项目<code>ROOT</code>，其目录<code>\webapps\ROOT</code>下有一个<code>index.jsp</code>，启动Tomcat，观察<code>\work</code>目录，发现<code>\work\Catalina\localhost\ROOT</code>为空，浏览器访问localhost:8080端口后，<code>\work\Catalina\localhost\ROOT\org\apache\jsp</code>目录下生成两个文件<code>index_jsp.java</code>和<code>index_jsp.class</code>。</p><p>　　打开<code>index_jsp.java</code>文件，发现该类继承自<code>org.apache.jasper.runtime.HttpJspBase</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">index_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceImports</span></span></span><br></pre></td></tr></table></figure><p>　　在Tomcat源码中找到该类，发现它继承自<code>HttpServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpJspBase</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">HttpJspPage</span></span></span><br></pre></td></tr></table></figure><p>　　即证明 Jsp 本质是一个Servlet。</p><p>　　除此之外，在<code>index_jsp.java</code>中还发现了大量的<code>out.write()</code>语句，这输出的其实就是写回到浏览器的页面，<code>out</code>是JSP内置对象中的一个，我们学习JSP除了语法之外学习的就是这几个内置对象。</p><a id="more"></a><br><hr><h3 id="1-JSP"><a href="#1-JSP" class="headerlink" title="1. JSP"></a>1. JSP</h3><h4 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h4><ul><li><code>&lt;% 代码 %&gt;</code>：包裹的代码将转换后将出现在service方法中；</li><li><code>&lt;%! 代码 %&gt;</code>：包裹的代码转换后将出现在类成员中；</li><li><code>&lt;%= 代码 %&gt;</code>：包裹的代码将输出到页面上;</li><li><code>&lt;%@ 指令 属性=值 ... %&gt;</code>：用于配置JSP的属性，指令如下：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> isErrorPage=<span class="string">&quot;true&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li>page 指令：<ul><li>contentType：等于 response.setContentType()；</li><li>import：导jar包；</li><li>errorPage：指定当前页面错误后是否跳转到错误页面；</li><li>isErrorPage：指定当前页面是否为错误页面；</li><li>include 指令：用于导入<strong>页面</strong>资源，用于页面组合；</li><li>taglib 指令：用于导入标签库；</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;!-- 内容 --&gt;</code>：只能注释html片段，会原样输出；</li><li><code>&lt;%-- --%&gt;</code>：代码级注释，不会输出到页面，推荐；</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><br><h4 id="1-2-内置对象"><a href="#1-2-内置对象" class="headerlink" title="1.2 内置对象"></a>1.2 内置对象</h4><p>　　内置对象不用创建，直接使用，实则是JSP转换为Servlet过程中帮我们创建了：</p><table><thead><tr><th>JSP中对象</th><th>对应对象</th><th>说明</th></tr></thead><tbody><tr><td>request</td><td>HttpServletRequest</td><td>请求对象</td></tr><tr><td>response</td><td>HttpServletResponse</td><td>响应对象</td></tr><tr><td>application</td><td>ServletContext</td><td>全局共享对象</td></tr><tr><td>page</td><td>当前Servlet</td><td>即this</td></tr><tr><td>pageContext</td><td>pageContext（jsp的）</td><td>可以在当前页面内共享数据，<br />可以获取其他内置对象</td></tr><tr><td>config</td><td>ServletConfig</td><td>servlet配置对象</td></tr><tr><td>session</td><td>HttpSession</td><td>会话对象</td></tr><tr><td>out</td><td>JspWriter（继承java.io.Writer）</td><td>输出对象</td></tr><tr><td>exception</td><td>Throwable</td><td>异常对象，只有声明为IsErrorPage才有</td></tr></tbody></table><ul><li>上述对象都声明在service方法内，即作用域在service方法内，只能在<code>&lt;% %&gt;</code>中调用。</li><li><code>out.write()</code>和<code>resp.getWriter().write()</code>的区别：两者有不同的缓冲区，resp的缓冲区优先输出，然后输出out的缓冲区，所以建议只使用out输出，html的body和<code>&lt;%= %&gt;</code>也会转化为out输出。</li></ul><br><hr><h3 id="2-EL-表达式"><a href="#2-EL-表达式" class="headerlink" title="2. EL 表达式"></a>2. EL 表达式</h3><p>　　表达式语言（Expression Language，EL），帮助我们简化JSP中Java代码的书写。</p><p>　　JSP 默认支持EL表达式，使用<code>&lt;%@page isELIgnore=&quot;true&quot;%&gt;</code>全局忽EL表达式，也可以在表达式前使用转义字符<code>\</code>。</p><ul><li><p><strong>语法：<code>$&#123;表达式&#125;</code></strong></p></li><li><p><strong>运算：</strong></p><ul><li>算数运算、比较运算、逻辑运算不用多说；</li><li>空运算<code>empty</code>和非空运算<code>not  empty</code>：用于判断对象是否为null，若不为null同时判断长度是否为0；</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;empty str&#125;</span><br><span class="line">$&#123;not empty str&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取值：<code>$&#123;域名称.键名&#125;</code></strong></p></li></ul><table><thead><tr><th>EL域名城</th><th>对应JSP域名称</th></tr></thead><tbody><tr><td>pageScope</td><td>pageContext</td></tr><tr><td>requestScope</td><td>request</td></tr><tr><td>sessionScope</td><td>session</td></tr><tr><td>applicationScope</td><td>application（ServletContext）</td></tr></tbody></table><p>　　注意：上述域的范围从小到大，取值的时候可以省略域名称，会自动按照域的范围从小到大查找；没找到也不会报错，只是不输出而已，这就很方便；</p><p>　　另外，获取对象的本质是调用对象的get方法，所以boolean类型要注意更改get方法将<code>isXxx()</code>修改为<code>getXxx()</code>，或者声明布尔值为包装类Boolean也可以。</p><p>　　获取 List：<code>$&#123;域名称.键名称[index]&#125;</code></p><p>　　获取 Map：<code>$&#123;域名称.键名称.key名称&#125;</code> 或 <code>$&#123;域名称.键名称[&quot;key名称&quot;]&#125;</code></p><ul><li><p><strong>内置对象</strong></p><p>上面几个域就是EL的内置对象，还有一个最关键的内置对象<code>PageContext</code>，它和JSP中的pageContext可以理解为一个对象，可以用它获取JSP其他的内置对象，如获取虚拟目录：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;@-- 本质是连环调用get方法 --@&gt;</span><br><span class="line">$pageContext.request.contextPath;</span><br></pre></td></tr></table></figure></li></ul><br><hr><h3 id="3-JSTL-标签库"><a href="#3-JSTL-标签库" class="headerlink" title="3. JSTL 标签库"></a>3. JSTL 标签库</h3><blockquote><p><a href="https://www.runoob.com/jsp/jsp-jstl.html">菜鸟JSTL教程</a></p></blockquote><p>　　JSP标准标签库（JavaServer Pages Tag Library，JSTL），用于更进一步简化、替换JSP中Java代码的书写，它支持通用的、结构化的业务操作，如循环、条件判断、SQL标签。</p><p>　　需要导入jar包和在JSP中使用taglib指令引入JSTL标签：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li>常用标签</li></ul><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-out-tag.html">c:out</a></td><td align="left">相当于&lt;%= … &gt;</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-set-tag.html">c:set</a></td><td align="left">用于保存数据</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-remove-tag.html">c:remove</a></td><td align="left">用于删除数据</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-catch-tag.html">c:catch</a></td><td align="left">用来处理产生错误的异常状况，并且将错误信息储存起来</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-if-tag.html"><strong>c:if</strong></a></td><td align="left">if逻辑</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-choose-tag.html"><strong>c:choose</strong></a></td><td align="left">switch逻辑</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-choose-tag.html">c:when</a></td><td align="left">c:choose的子标签，相当于case</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-choose-tag.html">c:otherwise</a></td><td align="left">c:choose的子标签，相当于default</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-import-tag.html">c:inport</a></td><td align="left">检索一个绝对或相对 URL，然后将其内容暴露给页面</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-foreach-tag.html"><strong>c:forEach</strong></a></td><td align="left">for逻辑</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-foreach-tag.html">c:forTokens</a></td><td align="left">根据指定的分隔符来分隔内容并迭代输出</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-param-tag.html">c:forTokens</a></td><td align="left">用来给包含或重定向的页面传递参数</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-redirect-tag.html">c:redirect</a></td><td align="left">重定向至一个新的URL.</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsp/jstl-core-url-tag.html">c:url</a></td><td align="left">使用可选的查询参数来创造一个URL</td></tr></tbody></table><ul><li><p>if 标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;&lt;boolean&gt;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;&lt;string&gt;&quot;</span> scope=<span class="string">&quot;&lt;string&gt;&quot;</span>&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><ul><li>test：条件；</li><li>var：存储条件结果的变量；</li><li>scope：var的作用域，默认为page；</li></ul></li><li><p>choose 标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;&lt;boolean&gt;&quot;</span>&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;&lt;boolean&gt;&quot;</span>&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">   ...</span><br><span class="line">    ...</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></li><li><p>forEach 标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach</span><br><span class="line">    items=<span class="string">&quot;&lt;object&gt;&quot;</span></span><br><span class="line">    begin=<span class="string">&quot;&lt;int&gt;&quot;</span></span><br><span class="line">    end=<span class="string">&quot;&lt;int&gt;&quot;</span></span><br><span class="line">    step=<span class="string">&quot;&lt;int&gt;&quot;</span></span><br><span class="line">    <span class="keyword">var</span>=<span class="string">&quot;&lt;string&gt;&quot;</span></span><br><span class="line">    varStatus=<span class="string">&quot;&lt;string&gt;&quot;</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><ul><li>items：要遍历的对象；</li><li>var：遍历到的当前元素的名称；</li><li>begin：起始索引，默认为0；</li><li>end：终止索引，默认为最后一个元素；</li><li>step：步长；</li><li>varStatus：代表循环状态的对象的名称<ul><li>count属性表示当前遍历到第几次。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 学习笔记</title>
      <link href="JavaEE/Back%20End/Servlet.html"/>
      <url>JavaEE/Back%20End/Servlet.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　Servlet (server applet) 运行在服务器端的程序,  它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的<strong>中间层</strong>。<br>　　通俗讲,  servlet就是一个接口,  它定义了一套规范,  实现了这一套规范的Java类就可以被Tomcat等服务器软件识别到。</p></blockquote><a id="more"></a><h3 id="1-Hello-Servlet"><a href="#1-Hello-Servlet" class="headerlink" title="1. Hello Servlet"></a>1. Hello Servlet</h3><h4 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h4><ol><li><p>创建一个 JavaEE 项目（选择WebApplication，勾选Creat web.xml）;</p></li><li><p>创建一个类实现 Servlet 接口,  实现service方法;</p><ul><li>若IDE没有自动导包，手动导入tomcat/lib/servlet-api；</li></ul><figure class="highlight java"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.henrykang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Web-INF/web.xml</code>中配置 Servlet 的映射信息</p></li></ol><ul><li><p>也可以在相应的Servlet上使用<code>@webServlet(&quot;url-pattern&quot;)</code>注解;</p></li><li><p><code>@WebServlet(&#123;&quot;/u1&quot;,&quot;/u2&quot;,&quot;/u3&quot;&#125;)</code>可以指定多个访问路径;</p><figure class="highlight xml"><figcaption><span>>folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 全类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>site.henrykang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>访问localhost:8080/helloServlet ，控制台会打印hello servlet</li></ol><ul><li><strong>WEB-INF目录说明</strong>：用户<strong>无法直接</strong>访问该目录下的资源<ul><li>web.xml：web项目的核心配置文件；</li><li>classes：放置src编译后的字节码文件；</li><li>lib：放置依赖的jar包。</li></ul></li></ul><h4 id="1-2-流程分析"><a href="#1-2-流程分析" class="headerlink" title="1.2 流程分析"></a>1.2 流程分析</h4><ol><li>服务器接收到请求后分析取得请求的虚拟路径；</li><li>查找<code>web.xml</code>文件,  是否有对应的<code>url-pattern</code>；</li><li>找到对应的<code>servlet-class</code>；<ul><li>有了全限定类名</li></ul></li><li>将字节码文件加载进内存,  创建对象并调用<code>service()</code>方法。<ul><li>Tomcat 根据全限定类名反射创建对象</li></ul></li></ol><p>####　1.3 生命周期</p><ol><li><strong>创建</strong><ul><li>执行且仅执行一次<code>init()</code>方法创建servlet;<ul><li>servlet是单例的, 即存在线程安全问题, 但写多个servlet-mapping（即有多个虚拟路径）映射到一个servlet上，则会创建多个servlet;</li></ul></li><li>执行的时机在相应的<code>&lt;servlet&gt;</code>标签下配置:<ul><li><code>&lt;load-on-startup&gt;</code>的值为负数时, 表示第一次访问时执行(默认);</li><li><code>&lt;load-on-startup&gt;</code>的值为非负数时, 表示在服务器启动的时候执行;</li></ul></li></ul></li><li><strong>服务</strong><ul><li>执行<code>service()</code>方法,  每次访问servlet时都会执行一次。</li></ul></li><li><strong>销毁</strong><ul><li>执行<code>destroy()</code>方法,  服务器<strong>正常关闭</strong>时执行;</li><li>servlet 对象由 GC 回收。</li></ul></li></ol><h4 id="1-4-HttpServlet-说明"><a href="#1-4-HttpServlet-说明" class="headerlink" title="1.4 HttpServlet 说明"></a>1.4 HttpServlet 说明</h4><ul><li><p><strong>servlet继承结构</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/20200214111224.png"></p></li></ul><p>　　抽象类<code>GenericServlet</code> 对servlet接口中除了其他方法做了空实现,  只留下service()方法作为抽象方法;</p><p>　　HTTP协议有7种请求方式，服务器通常要对不同的请求方式做出相应的相应，<code>HttpServlet</code> 是对http协议的封装，简化了操作，它的service方法中包含了对7中请求方式的判断，根据请求方式调用不同方法。我们使用时，只需要重写相应的<code>doXxx()</code>方法。</p><ul><li><strong>HTTP协议</strong>：超文本传输协议(Hyper Text Transfer Protocol)，定义了客户端和服务器交互数据的格式。<ul><li>特点:<ul><li>一次请求对应一次相应;</li><li>每次请求之间相互独立, 无法交互数据;    </li></ul></li><li>版本:<ul><li><code>1.0</code>: 每次请求都会建立新链接;</li><li><code>1.1</code>: 链接资源复用;</li></ul></li><li>响应状态码: <ul><li>1xx:  代表请求已被接受，需要继续处理</li><li>2xx:  成功</li><li>3xx:  重定向</li><li>4xx:  客户端错误</li><li>5xx:  服务器端错误    </li></ul></li></ul></li></ul><hr><h3 id="2-Request-amp-Response"><a href="#2-Request-amp-Response" class="headerlink" title="2. Request &amp; Response"></a>2. Request &amp; Response</h3><p>　　request和response分别用来获取请求消息和设置响应消息，均是由服务器(tomcat)创建，tomcat去实现HttpServletRequest/Response 接口、创建相应对象、封装信息，再传递给service方法。</p><h4 id="2-1-Request"><a href="#2-1-Request" class="headerlink" title="2.1 Request"></a>2.1 Request</h4><ul><li><p><strong>请求消息</strong></p><p><strong>请求行</strong></p><p>　　格式：请求方式/请求url  请求协议/版本</p><p>　　例如：Post/index.html  HTTP/1.1</p><p><strong>请求头</strong></p><p>　　user-agent：浏览器信息；</p><p>　　referer：请求的来源；</p><p>　　Accept、Accept-Language、Accept-Encoding</p><p>　　……</p><p><strong>请求体</strong></p><p>　　用于封装post请求的参数。</p></li><li><p><strong>常用方法</strong></p></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">String getMethod()</td><td align="left">获取请求方式</td></tr><tr><td align="left">String getProtocol()</td><td align="left">获取协议及版本</td></tr><tr><td align="left"><strong>String getContextPath()</strong></td><td align="left">获取访问的虚拟目录</td></tr><tr><td align="left"><strong>String getServletPath()</strong></td><td align="left">获取访问的servlet路径</td></tr><tr><td align="left">String getQueryString()</td><td align="left">获取get方式的请求参数</td></tr><tr><td align="left"><strong>String getRequestURI()</strong></td><td align="left">获取URI=contentPath+servletPath</td></tr><tr><td align="left">StringBuffer getRequestURL()</td><td align="left">获取URL=IP+URI</td></tr><tr><td align="left">String getRemoteAddr()</td><td align="left">获取客户端的IP</td></tr><tr><td align="left">String getHeader(String name)</td><td align="left">根据请求头名称获取值</td></tr><tr><td align="left">Enumeration<String> getHeaderNames()</td><td align="left">获取所有请求头名称</td></tr><tr><td align="left">ServletInputStream getInputStream()</td><td align="left">获取输入字节流（请求体）</td></tr><tr><td align="left">BufferedReader getReader()</td><td align="left">获取输入字符流</td></tr><tr><td align="left"><strong>String getParameter(String name)</strong></td><td align="left">根据参数名获取值</td></tr><tr><td align="left">String[] getParameterValues(String name)</td><td align="left">根据参数名获取值的数组</td></tr><tr><td align="left">Enumeration<String> getParameterNames()</td><td align="left">获取所有请求参数名称</td></tr><tr><td align="left">Map&lt;String,String[]&gt; getParameterMap()</td><td align="left">获取所有请求参数的集合</td></tr><tr><td align="left"><strong>static void setCharacterEncoding(“utf-8”)</strong></td><td align="left">指定编码格式（解决中文乱码）</td></tr><tr><td align="left">RequestDispatcher getRequestDispatcher(String path)</td><td align="left">获取转发器</td></tr></tbody></table><ul><li><strong>请求转发</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = request.getRequestDispatcher(String path);</span><br><span class="line">rd.forward(ServletRequest request, ServletResponse response) ;</span><br></pre></td></tr></table></figure><p>特点：</p><p>　　转发是一次请求；</p><p>　　地址栏不变；</p><p>　　只能转发到本服务器的资源。</p><ul><li><strong>共享数据</strong></li></ul><p>　　一次请求会创建一个request对象，若在<strong>一次请求中涉及到了多个servlet</strong>（转发），这些servlet就可以使用request域来共享数据;</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void setAttribute(String name, Object value)</td><td align="center">存储一个域属性</td></tr><tr><td align="center">Object getAttribute(String name)</td><td align="center">根据名称获取一个域中的值</td></tr><tr><td align="center">void removeAttribute(String name)</td><td align="center">移除request中的域属性</td></tr><tr><td align="center">Enumeration getAttributeNames()</td><td align="center">获取所有域属性的名称</td></tr></tbody></table><br><h4 id="2-2-Response"><a href="#2-2-Response" class="headerlink" title="2.2 Response"></a>2.2 Response</h4><ul><li><p><strong>响应消息</strong></p><p><strong>响应行</strong></p><p>　　格式：协议/版本  响应状态码  状态码描述</p><p>　　例如： HTTP/1.1 200 OK</p><p><strong>响应头</strong></p><p>　　content-type：text/html; charset=UTF-8 告诉浏览器响应体的格式</p><p>　　content-disposition：告诉浏览器打开响应体的方式</p><p>　　　　in-line：在当前页面打开</p><p>　　　　attachment；filename=xxx：以附件形式打开</p><p>　　content-length：响应体长度</p><p>　　date：日期</p><p><strong>响应体</strong></p></li><li><p><strong>常用方法</strong></p></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">void setStatus(int var1)</td><td align="left">设置状态吗</td></tr><tr><td align="left">void setHeader(String var1, String var2)</td><td align="left">设置响应头</td></tr><tr><td align="left">void sendRedirect(String var1)</td><td align="left">重定向</td></tr><tr><td align="left">ServletOutputStream getOutputStream()</td><td align="left">获取字节输出流</td></tr><tr><td align="left">PrintWriter getWriter()</td><td align="left">获取字符输出流</td></tr><tr><td align="left">response.setContentType(“text/html;charset=utf-8”)</td><td align="left">设置响应数据编码，解决中文乱码</td></tr></tbody></table><ul><li><strong>重定向</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;主机&quot;</span>,<span class="string">&quot;访问路径&quot;</span>);</span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;访问路径&quot;</span>);</span><br></pre></td></tr></table></figure><p>特点:</p><p>　　重定向是两次请求, 不能使用 request 域来共享数据；</p><p>　　地址栏发生变化,  可以访问其他服务器的资源。</p><h4 id="2-3-ServletContent"><a href="#2-3-ServletContent" class="headerlink" title="2.3 ServletContent"></a>2.3 ServletContent</h4><p>　　ServletContent对象代表整个web应用,  可以和服务器交换数据。通过HttpServlet（this）对象或request对象的<code>getServletContent()</code>方法获取；</p><ul><li><strong>常用方法</strong>;<ul><li>获取MIME类型 <code>getMimeType(String file)</code><ul><li>是HTTP协议使用的文件数据类型，如：text/html，image/png</li></ul></li><li>共享数据,  方法同request域,  但是范围更大, 可以在所有用户的请求之间交换数据，生命周期随着服务器，所以要慎用；</li><li>获取服务器<strong>资源的真实路径</strong>, <code>getRealPath(String path)</code>,  path相对路径写法要注意: <ul><li>获取<code>/webapp</code>下资源路径:  “/haha.txt”</li><li>获取<code>/WEB-INF</code>下资源路径:  “/WEB-INF/haha.txt”</li><li>获取<code>src</code>下资源路径:  “/WEB-INF/classes/haha.txt”</li></ul></li></ul></li></ul><hr><h3 id="3-Cookie-amp-Session"><a href="#3-Cookie-amp-Session" class="headerlink" title="3. Cookie &amp; Session"></a>3. Cookie &amp; Session</h3><blockquote><p>在浏览器与服务器的<strong>一次会话</strong>中共享数据</p></blockquote><h4 id="3-1-Cookie"><a href="#3-1-Cookie" class="headerlink" title="3.1 Cookie"></a>3.1 Cookie</h4><blockquote><p>应用场景：提供个性化服务, 服务器使用Cookie记录了一些用户的操作, 例如经常浏览哪些商品, 听那些歌曲, 分析后进行个性化的推送;<br><strong>方法：</strong></p></blockquote><ul><li>创建:  <code>new Cookie(String name, String value) </code> </li><li>发送:  <code>response.addCookie(Cookie cookie) </code></li><li>获取:  <code>Cookie[]  request.getCookies()</code></li><li>共享:  默认范围是当前服务器的当前项目<ul><li><code>setPath(String path)</code> 将path设为”/“, 可以在当前服务器的不同web项目之间共享;</li><li><code>setDomain(String path)</code> 设置path为一级域名, 则可以在当前域名下共享;</li></ul></li><li>设置存活时间: <code>setMaxAge(int second)</code>，默认关闭浏览器时销毁;<ul><li>正数：持久化到硬盘相应秒数；</li><li>负数：关闭浏览器删除，默认；</li><li>零：让浏览器删除cookie。</li></ul></li></ul><p><strong>过程：</strong></p><p>　　第一次访问服务器时，服务器发送cookie给浏览器，浏览器保存下来，在下次请求时将cookie添加到请求头中再发送给服务器，服务器就可以使用cookie中的信息。</p><p><strong>问题：</strong></p><ul><li>cookie存储在客户端,  由浏览器进行管理, 一般默认最多存储 300 个, 同一域名下最多 20 个, 单个cookie大小最大 4 kb;</li><li>中文问题，将内容编码解码；<ul><li><code>URLEncoder.encode(str,&quot;utf-8&quot;)</code></li><li><code>URLEncoder.decode(str,&quot;utf-8&quot;)</code></li></ul></li></ul><h4 id="3-2-Session"><a href="#3-2-Session" class="headerlink" title="3.2 Session"></a>3.2 Session</h4><blockquote><p>存储在服务器端, 可以存储任意类型/大小的数据;</p></blockquote><p><strong>方法：</strong></p><ul><li>获取:  <code>request.getSession();</code></li><li>使用:  <ul><li><code>Object getAttribute(String name)</code></li><li><code>void setAttribute(String name, Object value)</code></li><li><code>void removeAttribute(String name)</code></li></ul></li></ul><p><strong>问题：</strong></p><ul><li><p>session什么时候销毁?</p><ul><li>调用<code>session.invalidate()</code>方法;</li><li>默认生存时间为 30 分钟，<code>web.xml</code>配置文件中可修改;</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>session的序列化?</p><ul><li>服务器正常关闭时, 会将session对象序列化保存到硬盘上, 启动时复原；</li></ul></li><li><p>两次打开浏览器, 做相同请求, 得到的session是同一个吗?</p><ul><li>不是同一个, 将第一次访问的SessionID存到cookie中(字段名称必须为”JSESSIONID”), 第二次访问可以取到相同的Session。</li></ul></li></ul><hr><h3 id="4-Filter-amp-Listener"><a href="#4-Filter-amp-Listener" class="headerlink" title="4. Filter &amp; Listener"></a>4. Filter &amp; Listener</h3><h4 id="4-1-Filter"><a href="#4-1-Filter" class="headerlink" title="4.1 Filter"></a>4.1 Filter</h4><ul><li>步骤:<ol><li>定义一个类, 实现 <code>javax.servlet.Filter</code> 接口, 实现相应方法;</li><li><code>web.xml</code>中配置拦截路径</li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>site.henrykang.filter.TestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照路径拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照请求方式拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span><span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Filter方法<ul><li><code>init()</code>  服务器启动后, 创建Filter对象,  执行init方法;</li><li><code>doFilter()</code> 每一次请求被拦截的资源时执行;<ul><li><code>filter.doFilter(req,resp)</code>放行；</li></ul></li><li><code>destroy()</code> 服务器正常关闭时执行;</li></ul></li><li><code>@WebFilter</code>注解<ul><li>urlPatterns（=values）：按照路径拦截</li><li>DispatcherType：按照请求方式拦截<ul><li>REQUEST(默认)：浏览器直接请求</li></ul></li><li>FORWARD：转发请求<ul><li>INCLUDE：包含访问</li><li>ERROR：错误跳转</li><li>ASYNC：异步访问</li></ul></li></ul></li><li>配置多个过滤器的执行顺序问题<ul><li>xml配置中, 相对位置决定执行顺序;</li><li>注解配置中, 按字符串比较规则比较类名, 小的在前执行;</li></ul></li></ul><h4 id="4-2-Listener"><a href="#4-2-Listener" class="headerlink" title="4.2 Listener"></a>4.2 Listener</h4><ul><li>xml配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>实现相应监听器接口的类<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注解 <code>@WebListener</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 入门笔记</title>
      <link href="JavaEE/Back%20End/Tomcat.html"/>
      <url>JavaEE/Back%20End/Tomcat.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　<strong>Tomcat</strong> 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet 容器，作为开源免费的一个中小型服务器，只支持少量的servlet、jsp等JavaEE规范。同类产品还有Oracle的webLogic，IBM的webSphere，JBoss的JBoss等，他们都支持所有的JavaEE规范。<br>　　JavaEE十三大规范：JDBC、JNDI、EJB、RMI、JavaIDL/CORBA、JSP、Java Servlet、XML、JMS、JTA、JTS、JavaMail、JAF。　　</p></blockquote><a id="more"></a><h3 id="1-Hello-Tomcat"><a href="#1-Hello-Tomcat" class="headerlink" title="1. Hello Tomcat"></a>1. Hello Tomcat</h3><p>　　安装：下载解压即可，路径下不要有中文。　　</p><h4 id="1-1-主要目录"><a href="#1-1-主要目录" class="headerlink" title="1.1 主要目录"></a>1.1 主要目录</h4><ul><li><code>/bin</code> 存放用于启动及关闭的文件，以及其他一些脚本；</li><li><code>/conf</code> 配置文件，其中server.xml是容器的主配置文件；</li><li><code>/logs</code> 日志文件的默认目录；</li><li><code>/webapps</code> 存放 Web 应用；</li><li><code>/work</code>存放临时资源文件（如jsp生成的servlet.java）。</li></ul><h4 id="1-2-启动"><a href="#1-2-启动" class="headerlink" title="1.2 启动"></a>1.2 启动</h4><ul><li>__启动:__双击 <code>./bin/startup.bat</code> 即可，(<code>.sh</code>用于Linux下，相当于win下的<code>.bat</code>).  访问<code>localhost:8080</code>会显示Tomcat 欢迎界面 . </li><li><strong>问题:</strong><ul><li>没有正确配置<code>JAVA_HOME</code>会导致黑窗口一闪而过；</li><li>端口号占用解决：(默认端口号为8080)<ol><li>在<code>/conf/server.xml</code>中修改关键字<code>Connector port</code>为其他值;</li><li>cmd使用<code>netstat -ano</code>找到占用8080端口的进程,  记住他的<code>PID</code>在让任务管理器中停止运行.</li></ol></li><li>为什么通常将web服务器软件端口号设置为<code>80</code>?<br>答:  因为 <em>http协议</em> 的默认端口号为 80 ,  而浏览器默认请求时地址栏中url后80端口可以省略,  当我们将 tomcat 默认端口设置为 80 后,  访问时就不用在写端口号.</li></ul></li><li>**关闭:**点击<code>ctrl +ｃ</code>或者双击<code>/bin/shutdown.bat</code>.</li></ul><br><hr><h3 id="2-Tomcat部署方式"><a href="#2-Tomcat部署方式" class="headerlink" title="2. Tomcat部署方式"></a>2. Tomcat部署方式</h3><ol><li>直接将项目放到<code>/webapps</code>下,  项目名称就是访问的虚拟路径,  通常会将项目打成一个<code>war</code>包放置在<code>/webapps</code>下.</li><li>在<code>/conf/server.xml</code>的<code>&lt;Host&gt;</code>标签中配置<strong>资源路径</strong>和<strong>虚拟路径</strong>:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:/HelloTomcat&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>/conf/Catalina/localhost</code>下创建以<strong>虚拟路径命名</strong>的xml文件,  文件内容为<strong>资源路径</strong>:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:/hello tomcat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br><hr><h3 id="3-IDEA整合Tomcat"><a href="#3-IDEA整合Tomcat" class="headerlink" title="3. IDEA整合Tomcat"></a>3. IDEA整合Tomcat</h3><ul><li>整合方式:  在IDEA设置中添加本地Tomcat路径即可;</li><li>需要注意的问题:<ol><li>IDEA 不使用上面/conf/server.xml中的配置文件,  而是为每一个使用到Tomcat的项目单独建立一份配置文件,  默认存放在<code>C:\Users\用户名\.IntelliJIdea版本\system\tomcat\项目名</code>路径下;</li><li>控制台乱码问题：在<code>tomcat\conf\logging.properties</code>中修改java.util.logging.ConsoleHandler.encoding = <code>GBK</code></li><li>Tomcat <strong>无法直接</strong>访问到项目<code>WEB-INF</code>目录下的资源.</li></ol></li></ul><br><hr><h3 id="4-Tomcat运行机制"><a href="#4-Tomcat运行机制" class="headerlink" title="4. Tomcat运行机制 ?"></a>4. Tomcat运行机制 ?</h3><ol><li>首先必须实现<code>servlet</code>规范;</li><li>socket监听获取http请求, 封装请求，构造HttpServletRequest;</li><li>把获取的用户请求字节流转换成java对象httprequest, 并构造httpResponse;</li><li>创建/调用servlet,  调用<code>inti()</code>, 调用<code>service()</code>;</li><li>socket写回基于http协议的数据;</li><li>……</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery</title>
      <link href="JavaEE/Front%20End/JQuery.html"/>
      <url>JavaEE/Front%20End/JQuery.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　JQuery 是一个 JavaScript 框架，宗旨是“Write Less，Do More”，它优化了DOM操作、事件处理、Ajax、动画等操作。</p><p>　　回想 JS 的DOM操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line">getElementById()</span><br><span class="line">getElementsByTagName()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">getElementsByName()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;文本&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;id1&#x27;</span>).style.color=<span class="string">&#x27;red&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>　　显然使用原生的 JS 进行 DOM 操作有点繁琐，操作层级元素更是不太直观。JQuery就是封装了这些操作，为我们提供了极大的便利，使用<code>$</code>符号就可以方便的获取对象、操作属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素获取与属性设置</span></span><br><span class="line">$(<span class="string">&quot;#div1&quot;</span>).html(<span class="string">&quot;HTML内容&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(&#123;<span class="string">&quot;background-color&quot;</span>:<span class="string">&quot;red&quot;</span>,<span class="string">&quot;font-size&quot;</span>:<span class="string">&quot;20px&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数（可以定义多次，区别于window.onload()定义多次会覆盖）</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">// 等价于下面的简写形式</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line">$(<span class="string">&quot;#b1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;事件绑定&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>　　</p><hr><h3 id="1-JQuery对象"><a href="#1-JQuery对象" class="headerlink" title="1. JQuery对象"></a>1. JQuery对象</h3><h4 id="1-1-使用选择器获取JQ对象"><a href="#1-1-使用选择器获取JQ对象" class="headerlink" title="1.1 使用选择器获取JQ对象"></a>1.1 使用选择器获取JQ对象</h4><p>　　JQuery让我们可以像使用CSS的选择器一样方便的获取对象，只需要在<code>$&#123;&#125;</code>中传入一个选择器即可。<br>　　<a href="https://www.runoob.com/jquery/jquery-ref-selectors.html">菜鸟教程JQ选择器</a></p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>$(“#id”)</td><td>id选择器</td></tr><tr><td>$(“.class”)</td><td>类选择器</td></tr><tr><td>$(“element”)</td><td>元素选择器</td></tr><tr><td>$(“选择器1,选择器2….”)</td><td>并集选择器，逗号隔开</td></tr><tr><td>$(“Father Son”)</td><td>后代选择器，选取Father所有的Son子孙</td></tr><tr><td>$(“F &gt; S”)</td><td>儿子选择器，只选取Father的Son儿子</td></tr><tr><td>$(“[属性名]”)</td><td>属性选择器，按名称</td></tr><tr><td>$(“[属性名=’值’]”)<br />$(“div[id!=’123’]”)<br />$(“div[id^=’a’]”)<br />$(“div[id$=’z’]”)<br />$(“div[id*=’abc’]”)</td><td>属性选择器，按属性值<br />选择div中不包含id=123的属性，包括没有id属性的<br />选择以 a 开头的<br />选择以 z 结尾的<br />选择包含 abc 的</td></tr><tr><td>$(“[属性名=’值’][属性名=’值’]…”)</td><td>属性选择器，取交集</td></tr><tr><td>—过滤选择器—</td><td>—过滤选择器—</td></tr><tr><td>:first</td><td>获取选择的第一个元素</td></tr><tr><td>:last</td><td>获取选择的最后一个元素</td></tr><tr><td>:not(选择器)</td><td>不包括指定内容的元素</td></tr><tr><td>:even</td><td>偶数选择器，从0开始</td></tr><tr><td>:odd</td><td>奇数选择器，从0开始</td></tr><tr><td>:eq(index)</td><td>等于指定索引的元素</td></tr><tr><td>:gt(index)</td><td>大于指定索引的元素</td></tr><tr><td>:lt(index)</td><td>小于指定索引的元素</td></tr><tr><td>:header</td><td>标题选择器</td></tr><tr><td>:enabled</td><td>可用元素</td></tr><tr><td>:disabled</td><td>不可用元素</td></tr><tr><td>:checked</td><td>单选框、复选框选中元素</td></tr><tr><td>:selected</td><td>下拉框选中元素，<br />下拉框配置multiple属性可多选</td></tr></tbody></table><h4 id="1-2-JQ对象与JS对象的转换"><a href="#1-2-JQ对象与JS对象的转换" class="headerlink" title="1.2 JQ对象与JS对象的转换"></a>1.2 JQ对象与JS对象的转换</h4><p>　　使用<code>$</code>获取的对象和使用JS的DOM操作获取的对象含义相同，但是本质上还是有所区别，它们的方法和属性都不通用，所以我们有时需要对二者进行转换：</p><ul><li><p>JS 对象 → JQ对象</p><ul><li>$(JS对象)</li></ul></li><li><p>JQ 对象 → JS对象</p><ul><li>JQ对象[index] </li><li>JQ对象.get(index)</li></ul></li><li><p>JQ对象可以看做是对JS对象的一层封装。</p></li></ul><p>　　</p><hr><h3 id="2-DOM操作"><a href="#2-DOM操作" class="headerlink" title="2. DOM操作"></a>2. DOM操作</h3><h4 id="2-1-内容操作"><a href="#2-1-内容操作" class="headerlink" title="2.1 内容操作"></a>2.1 内容操作</h4><ul><li><p><code>text()</code>：设置或返回所选元素的文本内容；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是<span class="tag">&lt;<span class="name">b</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">b</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--获取：&quot;这是Test文本&quot; --&gt;</span></span><br><span class="line">$(&quot;#test&quot;).text()</span><br><span class="line"><span class="comment">&lt;!--设置：将&lt;p&gt;标签清空，包括里面的标签，设置内容为&quot;text&quot; --&gt;</span></span><br><span class="line">$(&quot;#test&quot;).text(&quot;text&quot;)</span><br></pre></td></tr></table></figure></li><li><p><code>html()</code>：设置或返回所选元素的内容（包括 HTML 标记）；</p></li><li><p><code>val()</code>：设置或返回value属性的值；</p></li></ul><h4 id="2-2-属性操作"><a href="#2-2-属性操作" class="headerlink" title="2.2 属性操作"></a>2.2 属性操作</h4><ul><li><strong>获取属性</strong><ul><li><code>prop()</code>：HTML固有的属性使用此方法；没有找到属性会返回 “ ”（空字符串）；</li><li><code>attr()</code>：自定义的DOM属性使用此方法，没有找到属性会返回undefined；</li></ul></li><li><strong>删除属性</strong><ul><li><code>removeProp()</code></li><li><code>removeAttr()</code></li></ul></li><li><strong>class属性操作</strong><ul><li><code>addClass()</code>：添加class属性值；</li><li><code>removeClass()</code>：删除class属性值；</li><li><code>toggleClass()</code>：切换class属性，若有则添加，若没有则删除；</li></ul></li></ul><h4 id="2-3-元素节点的增删操作"><a href="#2-3-元素节点的增删操作" class="headerlink" title="2.3 元素节点的增删操作"></a>2.3 元素节点的增删操作</h4><ul><li><p><strong>删除</strong></p><ul><li><code>元素.move()</code>：删除该元素及其子元素；</li><li><code>元素.empty()</code>：删除该元素的子元素；</li></ul></li><li><p><strong>新增</strong></p><p>第一类：<strong>在元素内部加入</strong></p><ul><li><code>元素A.append(元素B)</code>：在元素A结尾插入元素B；</li><li><code>元素A.prepend(元素B)</code>： 在元素Ａ开头插入元素Ｂ；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">$(&quot;p&quot;).append(&#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;);</span><br><span class="line"><span class="comment">&lt;!--执行结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二类：<strong>在元素外面加入</strong></p><ul><li><code>A.after(B)</code>：在A元素之后插入B元素</li><li><code>A.before(B)</code>：在A元素之前插入B元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">$(&quot;p&quot;).after(&#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;);</span><br><span class="line"><span class="comment">&lt;!--执行结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>　　</p><h4 id="2-4-JQ-的遍历"><a href="#2-4-JQ-的遍历" class="headerlink" title="2.4 JQ 的遍历"></a>2.4 JQ 的遍历</h4><ul><li><p><strong>JS 遍历</strong></p><ul><li>for 循环</li><li>for in 循环</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> txt=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;Zhang&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;San&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person)&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>JQ 遍历</strong></p><ul><li><code>元素.each(callback)</code>  或 <code>$.each(元素, callback)</code>： 为每个匹配元素执行函数；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(选择器).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// =continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// =break</span></span><br><span class="line">&#125;);</span><br><span class="line">$.each(元素, <span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index:元素在集合中的索引</span></span><br><span class="line"><span class="comment">element：集合中的每一个元素对象</span></span><br><span class="line"><span class="comment">this：= element</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>for...of(元素 of 容器)</code>（JQuery3.0以上）</li></ul></li></ul><p>　　</p><h4 id="2-5-事件"><a href="#2-5-事件" class="headerlink" title="2.5 事件"></a>2.5 事件</h4><ul><li><strong>常用事件</strong></li></ul><table><thead><tr><th align="left">鼠标事件</th><th align="left">键盘事件</th><th align="left">表单事件</th><th align="left">文档/窗口事件</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/jquery/event-click.html">click</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-keypress.html">keypress</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-submit.html">submit</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-load.html">load</a></td></tr><tr><td align="left"><a href="https://www.runoob.com/jquery/event-dblclick.html">dblclick</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-keydown.html">keydown</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-change.html">change</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-resize.html">resize</a></td></tr><tr><td align="left"><a href="https://www.runoob.com/jquery/event-mouseenter.html">mouseenter</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-keyup.html">keyup</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-focus.html">focus</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-scroll.html">scroll</a></td></tr><tr><td align="left"><a href="https://www.runoob.com/jquery/event-mouseleave.html">mouseleave</a></td><td align="left"></td><td align="left"><a href="https://www.runoob.com/jquery/event-blur.html">blur</a></td><td align="left"><a href="https://www.runoob.com/jquery/event-unload.html">unload</a></td></tr><tr><td align="left"><a href="https://www.runoob.com/jquery/event-hover.html">hover</a></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li><strong>绑定事件</strong><ul><li><code>元素.事件名(回调函数)</code></li><li><code>元素.(&quot;事件名&quot;,回调函数)</code></li></ul></li><li><strong>解除事件</strong><ul><li><code>元素.off(&quot;事件名&quot;)</code>：解除该元素的该事件；<ul><li>参数为空，则解除该元素的所有事件；</li></ul></li></ul></li><li><strong>切换事件</strong><ul><li><code>元素.toggle(fn1,fn2...)</code>：事件每发生一次，执行方法列表的下一个方法；<ul><li>JQuery1.9将此方法删除，需要引入<code>JQuery Migrate </code>插件方能使用。</li></ul></li></ul></li></ul><p>　　</p><hr><h3 id="3-动画"><a href="#3-动画" class="headerlink" title="3. 动画"></a>3. 动画</h3><ul><li><strong>显示/隐藏/切换</strong><ul><li><code>show(speed,easing,callback)</code><ul><li>speed：毫秒值表示动画完成的时间<ul><li>默认值：slow，nomal，fast</li></ul></li><li>easing：动画的效果<ul><li>swing：平滑</li><li>linear：匀速</li></ul></li><li>callback：动画完成后执行的函数</li></ul></li><li><code>hide(...)</code></li><li><code>toggle(...)</code></li></ul></li><li><strong>淡入淡出</strong><ul><li><code>fadeIn(...)</code></li><li><code>fadeOut(...)</code></li><li><code>fadeToggle(...)</code></li><li><code>fadeTo(spead,opacity,callback)</code>：渐变为给定的不透明度<ul><li>opacity ∈ [0,1]；</li></ul></li></ul></li><li><strong>滑动</strong><ul><li><code>fadeIn(...)</code></li><li><code>fadeOut(...)</code></li><li><code>fadeToggle(...)</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="JavaEE/Front%20End/JavaScript.html"/>
      <url>JavaEE/Front%20End/JavaScript.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　HTML 定义了网页的<strong>内容</strong>，CSS 规划了内容的<strong>布局</strong>，而 JavaScript 体现了网页的<strong>行为</strong>；</p><p>　　JS 最早是为了用于表单校验，减轻服务器压力，而后来发展成了一门独立的客户端脚本语言。JavaScript 在1995年由 Netscape 公司的 Brendan Eich 开发，最初名叫 Mocha，后与 SUN 公司合作改名为 JavaScript， 1996 年Netscape 将 JS 提交到 ECMA（欧洲计算机制造商协会） 组织进行标准化，于1997 年被采纳，制定了 ECMAScript 标准，统一了客户端脚本语言。</p><p>　　标准包含的内容范围较小，而 JavaScript 等是对 ECMAScript 标准的实现，除了包含 ECMAScript 还包含了其他功能。就好比 SQL 标准与MySQL、Oracle等实现的关系，因此我们主要学习的是它的标准与一些特有功能，学会了标准再学习其他实现就会比较容易。</p><a id="more"></a><p>　　</p><hr><h3 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1. ECMAScript"></a>1. ECMAScript</h3><h4 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h4><h5 id="1-与html的结合方式"><a href="#1-与html的结合方式" class="headerlink" title="1. 与html的结合方式"></a>1. 与html的结合方式</h5><ul><li>使用<code>&lt;script&gt;&lt;/script&gt;</code>包裹，可以放在 body 和 head 中的任何地方，通常将函数放在 head 或者 body 的尾部，因为放的位置会影响执行顺序，我们想要的是页面资源加载完成之后再使用JS；</li><li>外部引入方式<code>&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;</code>；</li></ul><br><h5 id="2-输出语句"><a href="#2-输出语句" class="headerlink" title="2. 输出语句"></a>2. 输出语句</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>window.alert()</td><td>弹框</td></tr><tr><td>document.write()</td><td>将内容写入到html</td></tr><tr><td>innerHTML</td><td>将内容写入html元素</td></tr><tr><td>console.log()</td><td>写出到浏览器控制台</td></tr></tbody></table><p>　　<strong>注意：</strong>若在页面加载完成后（例如函数中）使用 <code>document.write()</code>，会覆盖此页面。</p><br><h5 id="3-变量与数据类型"><a href="#3-变量与数据类型" class="headerlink" title="3. 变量与数据类型"></a>3. 变量与数据类型</h5><ul><li><p><strong>关于变量：</strong></p><ul><li><p>JS 是弱类型语言，声明变量可以使用使用<code>var</code>、<code>const</code>、<code>let</code>（ES6），区别如下：</p><ul><li>var 可以<strong>变量提升</strong>（可以先使用后声明），const和let不行；</li><li>var 声明的全局变量属于 window 对象，可以通过 window.变量名 调用，let、const 不行；</li><li>var 可以在作用域内随时随地重新声明已声明的变量，且覆盖已声明的变量；</li><li>const 和 let 声明的变量都是作用域都是块级，在相同块内不能重新声明，在不同块中可以重新声明，但不会覆盖；</li><li>const 类似于 Java 中的 final，声明时必须初始化，指向引用的值，引用的值不可变，引用的内容可以变；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 可以随时重新声明已声明的变量，且覆盖</span></span><br><span class="line"><span class="comment">// 当然在函数体内声明得变量属于局部变量，和当前正在讨论的无关，注意区别</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> i =<span class="number">1</span> ;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块内&quot;</span>+i+<span class="string">&quot;&lt;br&gt;&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块外&quot;</span>+i); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">i =<span class="number">1</span> ;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块内&quot;</span>+i+<span class="string">&quot;&lt;br&gt;&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块外&quot;</span>+i); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> i =<span class="number">1</span> ;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块内&quot;</span>+i+<span class="string">&quot;&lt;br&gt;&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;块外&quot;</span>+i); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>变量名可以以字母、<code>$</code>、<code>_</code>开始，且对大小写敏感；</p></li><li><p>字符串使用单引号或双引号包裹；</p></li><li><p><strong>关于数据类型：</strong></p><ul><li>基本类型：String、Number、Boolean、Null、Undefined、symbol（ES6）；</li><li>引用数据类型：Object、Array、Function（方法也是一个对象）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 运算符，用于判断对象时什么类型，注意下面不会得到我们想要的结果：</span></span><br><span class="line"><span class="comment">// 所以，我们常用instanceof方法来判断；</span></span><br><span class="line"><span class="keyword">typeof</span> 数组 <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>只声明未赋值时，为 undefined 状态；</li><li>Boolean 只有true和false；</li><li>null和undefined的区别：可以理解为 null 也是一个值，只不过代表此处没有对象，而undefined则是缺少值，即此处什么都没有。还有就是下面会提到的与namber运算时的转换，null=0，undefined=NaN；</li></ul></li></ul><br><h5 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h5><ul><li>赋值、加、减、乘、除、自增、自减……和 Java 类似；<ul><li>有字符串参与运算都转字符串；<ul><li>boolean、NaN、null 和 undefined 转相应的字面量；</li></ul></li><li>无字符串参与运算都转number；<ul><li>true 等于 1，false、null 等于 0；</li><li>undefined等于NaN，运算结果也是NaN；</li></ul></li></ul></li><li>比较运算符：&gt;、 &lt;、 &gt;=、 &lt;=、 ==、 ===、!=、!==<ul><li>对于对象比较的都是地址；</li><li>类型相同则按顺序比较，否则先转化类型再比较；<ul><li>null==undefined 与 null==null 返回true；</li><li>NaN六亲不认，和自己比都返回false；</li></ul></li><li><code>===</code> 与<code>!==</code>先判断类型，类型不同直接false/true；<ul><li>null === undefined，返回false</li></ul></li></ul></li><li>逻辑运算符：&amp;&amp; || !<ul><li>运算时都转 boolean<ul><li>0、NaN、空字符串<code>“ ”</code>、null、undefined 都为 false；</li><li>所有对象都为 true；</li></ul></li></ul></li></ul><br><h5 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a>5. 流程控制</h5><ul><li><p>if-else、switch、while、do while、for 与java大同小异；</p></li><li><p><code>for in</code> 用于遍历对象和数组，相当于forEach；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> txt=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;Zhang&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;San&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;; </span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person)&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br><h5 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h5><ul><li>创建函数的方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">var1,var2...</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="comment">// return xxx;</span></span><br><span class="line">    <span class="comment">// return后面的代码不会执行；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">var1,var2...</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li><p>函数实际是一个<strong>Function</strong>对象，重名方法会被覆盖重写，<strong>没有重载</strong>一说；</p></li><li><p>每个函数内都内置了一个<strong>arguments</strong>数组对象，封装了传进来的参数；</p></li><li><p>方法的定义不用写参数类型也不用写返回类型；</p></li><li><p>声明在函数内的是<strong>局部变量</strong>，在函数运行以后被删除；</p></li><li><p>声明在函数外的是<strong>全局变量</strong>，在页面关闭后被删除；</p></li></ul></li><li><p>函数 VS 方法：方法特指我们自己创建的对象中的函数，通过对象.方法名调用（函数其实也是window对象的方法），看下面对象的创建就理解了；</p></li></ul><h4 id="1-2-对象"><a href="#1-2-对象" class="headerlink" title="1.2 对象"></a>1.2 对象</h4><p>　　JS 中一切都是对象，数字型、字符串、布尔、数组、函数……都是对象；</p><h5 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接创建，键值对的形式</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">firstname : <span class="string">&quot;k&quot;</span>,</span><br><span class="line">lastname  : <span class="string">&quot;hy&quot;</span>,</span><br><span class="line">id        : <span class="number">1234</span>，</span><br><span class="line">talk : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.firstname+<span class="built_in">this</span>.lastname+<span class="built_in">this</span>.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用属性的两种方式</span></span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[<span class="string">&quot;lastname&quot;</span>];</span><br><span class="line"><span class="comment">// 调用方法要加括号</span></span><br><span class="line">name=person.talk(); </span><br><span class="line">name=person[<span class="string">&quot;talk&quot;</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname,lastname,id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstname=firstname;</span><br><span class="line">    <span class="built_in">this</span>.lastname=lastname;</span><br><span class="line">    <span class="built_in">this</span>.id=id;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.getId = <span class="function"><span class="keyword">function</span> <span class="title">getId</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Li&quot;</span>,<span class="string">&quot;Si&quot;</span>,<span class="number">2345</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>关于 this：</strong>this写在谁的作用域里面就指代谁；</p><ul><li>对象方法中，this 指向调用它的对象；</li><li>外部使用时，this 指向全局对象（Global，浏览器中就是window对象）；</li><li>函数中，this 指向函数的所属者（浏览器就是window对象）；<ul><li>严格模式下 this 是 undefined；</li></ul></li><li>在 HTML 事件中，this 指向了发出事件的 HTML 元素（事件源）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------对象与外部使用this--------</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar) &#125;,</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fun = obj.fun;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// this 指对象obj</span></span><br><span class="line">obj.fun() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// this 指全局对象</span></span><br><span class="line">fun() <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//------事件中的this------</span></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;我是button1&quot;</span> onclick=<span class="string">&quot;alert(this.id)&quot;</span> value=<span class="string">&quot;按我测试&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;我是button2&quot;</span> onclick=<span class="string">&quot;alert(this.id)&quot;</span> value=<span class="string">&quot;按我测试&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li></ul><br><h5 id="2-基本对象"><a href="#2-基本对象" class="headerlink" title="2. 基本对象"></a>2. 基本对象</h5><p><a href="https://www.w3cschool.cn/jsref/jsref-obj-date.html">w3cschool</a></p><ul><li><p><strong>Array</strong> 数组对象：</p><ul><li>JS 中数组的元素和类型都是可变的；</li><li>创建数组的方式：<ul><li><code>var arr = new Array(元素列表)</code>;</li><li><code>var arr = new Array(默认长度)</code>;</li><li><code>var arr = [元素列表]</code>;</li></ul></li><li>方法：<ul><li>toString( )，将数组转化为字符串；</li><li>join(分隔符)，将数组中的元素按分隔符（默认为逗号）拼接为字符串；</li><li>push(元素)，向数组的末尾添加一个或更多元素，返回新的长度；</li><li>pop()，返回并删除最后一个元素；</li><li>shift()，返回并删除第一个元素；</li><li>……</li></ul></li></ul></li><li><p><strong>Date</strong> 日期对象：</p><ul><li><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 当前日期和时间        </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(milliseconds) <span class="comment">//返回从 1970 年 1 月 1 日至今的毫秒数        </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString)        </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month, day, hours, minutes, seconds, milliseconds)</span><br></pre></td></tr></table></figure></li><li><p>方法：</p><ul><li>getFullYear() 获取年份；</li><li>getTime() 返回毫秒数；</li><li>toLocalString() 返回当地格式的时间字符串；</li><li>……</li></ul></li><li><p>实例：显示时钟</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">startTime</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> today=<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> h=today.getHours();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> m=today.getMinutes();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> s=today.getSeconds();<span class="comment">// 在小于10的数字钱前加一个‘0’</span></span></span><br><span class="line">m=checkTime(m);</span><br><span class="line">s=checkTime(s);</span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).innerHTML=h+<span class="string">&quot;:&quot;</span>+m+<span class="string">&quot;:&quot;</span>+s;</span></span><br><span class="line"><span class="javascript">t=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;startTime()&#125;,<span class="number">500</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span>(<span class="params">i</span>)</span>&#123;</span></span><br><span class="line">if (i&lt;10)&#123;</span><br><span class="line"><span class="javascript">i=<span class="string">&quot;0&quot;</span> + i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span> i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;startTime()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Math</strong> 对象：</p><p>类似Java中的一个静态工具类；</p><ul><li>方法：通过 <code>Math.方法名</code> 调用<ul><li>abs(x) 绝对值</li><li>pow(x,y)  求 X<sup>y</sup></li><li>random( ) 返回 [0,1) 的随机数</li><li>max()、min() 求最值</li><li>round(x) 四舍五入</li><li>……</li></ul></li></ul></li><li><p><strong>RegExp</strong> 对象：</p><ul><li><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w+/</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> flag = reg.test(name);</span><br></pre></td></tr></table></figure></li><li><p>规则：</p><ul><li><code>[]</code>表示单个字符，例如 [a]、[a-z]</li><li><code>\d</code> 表示单个数字；<ul><li><code>\w</code> 表示单个字符；</li></ul></li><li>起止：<ul><li><code>^</code>表示以某个字符开始；</li><li><code>$</code> 表示以某个字符结束；</li></ul></li><li>量词：<ul><li><code>?</code> 表示0或1次；</li><li><code>*</code>表示0或多次；</li><li><code>+</code>表示至少1次；</li><li><code>&#123;a,b&#125;</code> 表示[a,b]次；</li></ul></li></ul></li></ul></li><li><p><strong>Global</strong> 对象：</p><ul><li>方法：</li></ul></li></ul><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">decodeURI()</td><td align="left">解码URI为字符串</td></tr><tr><td align="left">decodeURIComponent()</td><td align="left">解码范围更广的URI为字符串</td></tr><tr><td align="left">encodeURI()</td><td align="left">把字符串编码为 URI</td></tr><tr><td align="left">encodeURIComponent()</td><td align="left">把范围更广的字符串编码为 URI</td></tr><tr><td align="left">escape()</td><td align="left">对字符串进行编码</td></tr><tr><td align="left">unescape()</td><td align="left">对由 escape() 编码的字符串进行解码</td></tr><tr><td align="left">eval()</td><td align="left">计算 JavaScript 字符串，并把它作为脚本代码来执行</td></tr><tr><td align="left">isFinite()</td><td align="left">检查某个值是否为有穷大的数</td></tr><tr><td align="left">isNaN()</td><td align="left">检查某个值是否为NaN</td></tr><tr><td align="left">Number()</td><td align="left">把对象的值转换为数字</td></tr><tr><td align="left">parseFloat()</td><td align="left">逐一解析一个字符串并返回一个浮点数直到不是数字停止</td></tr><tr><td align="left">parseInt()</td><td align="left">逐一解析一个字符串中的字符直到不是数字停止<br />开头就是非数字字符则转为NaN</td></tr><tr><td align="left">String()</td><td align="left">把对象的值转换为字符串</td></tr></tbody></table><hr><h3 id="2-BOM"><a href="#2-BOM" class="headerlink" title="2. BOM"></a>2. BOM</h3><p>　　BOM（Browser Object Model），浏览器对象模型。将浏览器的各个部分封装成为对象，拥有一些属性和方法，便于我们与浏览器“交流”；</p><p>主要包含下面几个对象：</p><table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td>Navigator</td><td>浏览器对象，包含有关浏览器的信息</td></tr><tr><td>Screen</td><td>显示器对象，包含有关用户屏幕的信息</td></tr><tr><td><strong>Window</strong></td><td>窗口对象，可以用来获取其他对象（包括DOM对象）</td></tr><tr><td>History</td><td>历史记录对象，包含用户在当前窗口访问过的 URL</td></tr><tr><td>Location</td><td>地址栏对象，包含有关当前 URL 的信息</td></tr></tbody></table><br><h4 id="2-1-window-对象"><a href="#2-1-window-对象" class="headerlink" title="2.1 window 对象"></a>2.1 window 对象</h4><ul><li>常用属性（获取其他对象）</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>navigator</td><td>获取浏览器对象</td></tr><tr><td>screen</td><td>获取屏幕对象</td></tr><tr><td>history</td><td>获取历史记录对象</td></tr><tr><td>location</td><td>获取地址栏对象</td></tr><tr><td>document</td><td>获取dom对象</td></tr></tbody></table><ul><li>常用方法：</li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">alert()</td><td align="left">显示带有一段消息和一个确认按钮的警告框</td></tr><tr><td align="left">confirm()</td><td align="left">显示带有一段消息以及确认按钮和取消按钮的对话框</td></tr><tr><td align="left">prompt()</td><td align="left">显示可提示用户输入的对话框</td></tr><tr><td align="left">open()</td><td align="left">打开一个新的浏览器窗口，可以传一个url</td></tr><tr><td align="left">close()</td><td align="left">关闭当前浏览器窗口，谁调用关谁</td></tr><tr><td align="left">setInterval(方法str，毫秒值)</td><td align="left">按照指定的周期（以毫秒计）来调用函数或计算表达式</td></tr><tr><td align="left">setTimeout(方法str，毫秒值)</td><td align="left">在指定的毫秒数后调用函数或计算表达式</td></tr><tr><td align="left">clearInterval()</td><td align="left">取消由 setInterval() 设置的 timeout</td></tr><tr><td align="left">clearTimeout()</td><td align="left">取消由 setTimeout() 方法设置的 timeout</td></tr></tbody></table><h4 id="2-2-history-对象"><a href="#2-2-history-对象" class="headerlink" title="2.2 history 对象"></a>2.2 history 对象</h4><ul><li>常用属性：</li></ul><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">length</td><td align="left">返回当前窗口历史列表中的网址数</td></tr></tbody></table><ul><li>常用方法：</li></ul><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">back()</td><td align="left">加载 history 列表中的前一个 URL</td></tr><tr><td align="left">forward()</td><td align="left">加载 history 列表中的下一个 URL</td></tr><tr><td align="left">go()</td><td align="left">前进后退具体个数的历史页面</td></tr></tbody></table><h4 id="2-3-location-对象"><a href="#2-3-location-对象" class="headerlink" title="2.3 location 对象"></a>2.3 location 对象</h4><ul><li>常用属性：</li></ul><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">hash</td><td align="left">返回一个URL的锚部分</td></tr><tr><td align="left">host</td><td align="left">返回一个URL的主机名和端口</td></tr><tr><td align="left">hostname</td><td align="left">返回URL的主机名</td></tr><tr><td align="left">href</td><td align="left">返回完整的URL</td></tr><tr><td align="left">pathname</td><td align="left">返回URL路径名</td></tr><tr><td align="left">port</td><td align="left">返回一个URL服务器使用的端口号</td></tr><tr><td align="left">protocol</td><td align="left">返回一个URL协议</td></tr><tr><td align="left">search</td><td align="left">返回一个URL的查询部分</td></tr></tbody></table><ul><li>常用方法：</li></ul><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">assign()</td><td align="left">载入一个新的文档，可以后退到上一页</td></tr><tr><td align="left">reload()</td><td align="left">重新载入当前文档</td></tr><tr><td align="left">replace()</td><td align="left">用新的文档替换当前文档，不能后退到上一页</td></tr></tbody></table><hr><h3 id="3-DOM"><a href="#3-DOM" class="headerlink" title="3. DOM"></a>3. DOM</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/i4wjO7c4hlUL.png" alt="DOM数"></p><p>　　DOM（Document Object Model），文档对象模型。将文档的各个部分封装成为对象，使用这些对象可以动态的对文档的元素、属性、样式等进行操作；</p><p>　　DOM 包含document对象、element对象、attribute对象、text对象……这些对象都被看做是一个个节点，父子关系就对应着html文件中的标签及属性，例如 tr 是 td 的父节点，href 是 a 标签的一个子节点。</p><p>　　可以通过<code>appendChild()</code>来添加节点，<code>removeChild()</code>来删除节点，属性<code>parentNode</code>来获取父节点；</p><ul><li>element（标签）对象的方法：</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getElementById()</td><td>根据 id 属性获取，要唯一</td></tr><tr><td>getElementsByTagName()</td><td>根据元素（标签）名获取</td></tr><tr><td>getElementsByClassName()</td><td>根据 class 属性获取</td></tr><tr><td>getElementsByName()</td><td>根据 name 属性获取</td></tr><tr><td>setAttribute()</td><td>设置属性</td></tr><tr><td>removeAttribute()</td><td>删除属性</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test01&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>创建节点对象的方法：</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>createElement()</td><td>创建一个标签对象</td></tr><tr><td>createAttribute(name)</td><td>创建一个属性对象</td></tr><tr><td>createTextNode()</td><td>创建一个文本对象</td></tr></tbody></table><ul><li><p>DOM HTML 与 DOM CSS 属性：</p><ul><li>innerHTML 属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;文本&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>style 属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;id1&#x27;</span>).style.color=<span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>　　</p><h4 id="3-2-DOM-事件"><a href="#3-2-DOM-事件" class="headerlink" title="3.2 DOM 事件"></a>3.2 DOM 事件</h4><blockquote><p><a href="https://www.runoob.com/jsref/dom-obj-event.html">菜鸟教程</a></p></blockquote><ul><li>绑定事件的两种方法举例：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;getElementById(&#x27;demo&#x27;).innerHTML=Date()&quot;</span>&gt;</span>现在的时间是?<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML &amp; CSS</title>
      <link href="JavaEE/Front%20End/HTML%E4%B8%8ECSS.html"/>
      <url>JavaEE/Front%20End/HTML%E4%B8%8ECSS.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　<strong>超文本标记语言</strong>（HyperText Markup Language，HTML），<strong>标记</strong>体现在通过一些标签将网络上的文本格式统一化，便于传播；<strong>超文本</strong>一方面体现在内容不限于文字还包括图片视频表格等，另一方面是通过超链接的方式将分布在互联网各个角落的资源连接成为一个整体，便于访问。</p><p>　　<strong>CSS</strong>（Cascading Style Sheets），层叠样式表。如果将HTML比作图书，那CSS就是书架，用于规划HTML的样式。虽然HTML也可以通过标签的一些属性设置样式，但是为了便于统一维护（解耦），通常只用HTML来体现内容，用CSS体现样式。</p><p>　　由于标记语言并不是编程语言，只有HTML与CSS制作的页面还欠缺与用户的动态交互性，所以后来就有了<strong>JavaScript</strong>。</p><a id="more"></a><h3 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1. HTML"></a>1. HTML</h3><p><a href="https://www.runoob.com/html/html5-intro.html">HTML菜鸟教程链接</a></p><h4 id="１-１-Hello-HTML"><a href="#１-１-Hello-HTML" class="headerlink" title="１.１ Hello HTML"></a>１.１ Hello HTML</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello HTML!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>&lt;!DOCTYPE html&gt; 声明此文档是html文档；</li><li>&lt;html&gt;&lt;/html&gt; 称为根标签；</li><li>&lt;head&gt;&lt;/head&gt; 称为头标签，用于指定文档的一些属性和引入外部资源；</li><li>&lt;title&gt;&lt;/title&gt; 标题标签，指定标签页的名字；</li><li>&lt;body&gt; 称为体标签，用于定义我们的文档内容；</li></ul><h4 id="1-2-文本标签"><a href="#1-2-文本标签" class="headerlink" title="1.2 文本标签"></a>1.2 文本标签</h4><ul><li>标签</li></ul><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>&lt;!–  –&gt;</td><td>注释</td></tr><tr><td>&lt;h1&gt; 到 &lt;h6&gt;</td><td>标题标签，h1-h6 逐渐缩小</td></tr><tr><td>&lt;p&gt;</td><td>声明一个段落</td></tr><tr><td>&lt;br/&gt;</td><td>换行</td></tr><tr><td>&lt;hr/&gt;</td><td>分割线</td></tr><tr><td>&lt;b&gt;、&lt;i&gt;、&lt;u&gt;</td><td>斜体粗体下划线</td></tr><tr><td>&lt;font&gt;</td><td>字体标签</td></tr><tr><td>&lt;center&gt;</td><td>内容居中</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><ul><li><p>说明：</p><ul><li>标签按是否自动换行可分为块级标签、行内标签；</li><li>标签属性大小写都行，属性值用单引号双引号都行；</li></ul></li></ul><ul><li>描述文本的属性</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>color</td><td>颜色，表示为rgb(255,255,255) 或 color = “#FFFFFF”</td></tr><tr><td>width、size</td><td>宽度、高度，默认单位是像素，可以使用百分比</td></tr><tr><td>align</td><td>对齐方式</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><h4 id="1-3-图片、链接标签"><a href="#1-3-图片、链接标签" class="headerlink" title="1.3 图片、链接标签"></a>1.3 图片、链接标签</h4><p><strong>1. 图片标签</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./xxx.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;美丽的图片&quot;</span> <span class="attr">weight</span>=<span class="string">&quot; &quot;</span>  <span class="attr">height</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>属性：</p><ul><li>src 指定图片路径；</li><li>alt 指定图片加载失败显示的文字；</li><li>weight、height 指定宽高，注意与描述文本宽度的属性size区分；</li><li>……</li></ul></li></ul><p><strong>2. 链接标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.henrykang.site&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>链接\<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性：<ul><li>target：<ul><li>_self 在本页打开</li><li>_blank 在新标签页打开</li></ul></li></ul></li></ul><h4 id="1-4-列表、表格标签"><a href="#1-4-列表、表格标签" class="headerlink" title="1.4 列表、表格标签"></a>1.4 列表、表格标签</h4><p><strong>1. 无序列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性：<ul><li>type：circle、square、disc(默认)</li></ul></li></ul><p><strong>2. 有序列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span> <span class="attr">start</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性：<ul><li>type：A、a、……</li><li>start：开始的编号；</li></ul></li></ul><p><strong>3. 自定义列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>- 100分<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>- 99分<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 表格</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span> <span class="attr">weight</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格名称<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>属性 || 说明<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;6&quot;</span>&gt;</span>table<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>border<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>边界<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>width、height<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>宽高<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>bgcolor<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>颜色<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>align<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>对齐方式<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cellpandding<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格内边距<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cellspacing<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格外边距<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>caption<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>声明表格标题<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>th<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>声明表头<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>tr<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>声明行<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>td<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>声明列（单元格）<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>rowspan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>合并行<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>colspan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>合并列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>效果如下：</strong></li></ul><table border="2" weight="100" height="100" align="center" cellpadding="10" cellspacing="0"><caption>表格名称</caption><tr><th align="center">标签</th><th colspan="2" align="center">属性 || 说明</th></tr><tr><td rowspan="6">table</td><td>border</td><td>边界</td></tr><tr><td>width、height</td><td>宽高</td></tr><tr><td>bgcolor</td><td>颜色</td></tr><tr><td>align</td><td>对齐方式</td></tr><tr><td>cellpandding</td><td>表格内边距</td></tr><tr><td>cellspacing</td><td>表格外边距</td></tr><tr><td>caption</td><td colspan="2">声明表格标题</td></tr><tr><td>th</td><td colspan="2">声明表头</td></tr><tr><td>tr</td><td colspan="2">声明行</td></tr><tr><td>td</td><td colspan="2">声明列（单元格）</td></tr><tr><td>rowspan</td><td colspan="2">合并行</td></tr><tr><td>colspan</td><td colspan="2">合并列</td></tr></table><h4 id="1-5-表单标签"><a href="#1-5-表单标签" class="headerlink" title="1.5 表单标签"></a>1.5 表单标签</h4><blockquote><p>表单通常用于提交数据，要提交的数据必须有name属性，因为name将作为键值对的键。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">                女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;20&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;24&quot;</span> <span class="attr">name</span>=<span class="string">&quot;introduction&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>爱好<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                唱<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sing&quot;</span> /&gt;</span></span><br><span class="line">                跳<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dance&quot;</span> /&gt;</span></span><br><span class="line">                rap<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;rap&quot;</span> /&gt;</span></span><br><span class="line">                篮球<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;basketball&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>地址<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;null&quot;</span> <span class="attr">checked</span>&gt;</span>--请选择--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>出生日期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;verifycode&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入验证码&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/xxx&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>效果如下：</strong></li></ul><form action="" method="get"><table><tr><td><label for="username">用户名</label></td><td><input type="text" name="username" id="username" placeholder="请输入用户名" /></td></tr><tr><td><label for="pwd">密码</label></td><td><input type="password" name="pwd" id="pwd" placeholder="请输入密码"></td></tr><tr><td>邮箱</td><td><input type="email" name="email" placeholder="请输入邮箱"></td></tr><tr><td>性别</td><td>男<input type="radio" name="gender" value="male" checked>女<input type="radio" name="gender" value="female"></td></tr><tr><td>简介</td><td><textarea rows="20" cols="24" name="introduction"></textarea></td></tr><tr><td>爱好</td><td>唱<input type="checkbox" name="hobby" value="sing" />跳<input type="checkbox" name="hobby" value="dance" />rap<input type="checkbox" name="hobby" value="rap" />篮球<input type="checkbox" name="hobby" value="basketball" /></td></tr><tr><td>地址</td><td><select name="addr"><option value="null" checked>--请选择--</option><option value="beijing">北京</option><option value="shanghai">上海</option><option value="guangzhou">广州</option></select></td></tr><tr><td>出生日期</td><td><input type="date" name="birth"></td></tr><tr><td>验证码</td><td><input type="text" name="verifycode" placeholder="请输入验证码"><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="img/xxx"></td></tr><tr><td colspan="2" align="center"><input type="submit" value="注册"></td></tr></table></form><p><strong>说明：</strong></p><ul><li><p>&lt;form&gt; 声明表单范围：</p><ul><li>action 指定提交的url；</li><li>method 指定提交的方式；</li></ul></li><li><p>&lt;input&gt; 声明输入：</p><ul><li>type 指定输入样式：<ul><li>text 文本输入框</li><li>password 密码输入框</li><li>radio 单选框，name属性一致可保证单选</li><li>checkbox 复选框，每一项都要指定 value 作为选中时提交的值</li><li>file 文件选择框</li><li>submit 提交按钮</li><li>image 提交图片按钮</li><li>button 普通按钮</li></ul></li></ul></li><li><p>&lt;textarea&gt;：文本域</p><ul><li>rows 指定行数</li><li>cols 指定列数</li></ul></li><li><p>&lt;label&gt; 声明一个标签：</p><ul><li>for 属性与 input 的 id 属性保持一致，可以点击 label 使 input 获得焦点，提升用户体验；</li></ul></li><li><p>&lt;select&gt; 下拉列表：</p><ul><li>option 指定下拉列表的每一项；</li></ul></li><li><p>……</p></li></ul><hr><h3 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2. CSS"></a>2. CSS</h3><p><a href="https://www.runoob.com/css/css-tutorial.html">CSS菜鸟教程链接</a></p><h4 id="2-1-HTML-结合-CSS-的三种方式"><a href="#2-1-HTML-结合-CSS-的三种方式" class="headerlink" title="2.1 HTML 结合 CSS 的三种方式"></a>2.1 HTML 结合 CSS 的三种方式</h4><ol><li><p>内联样式</p><p>在标签内使用<code>style</code>声明css代码，多个属性用分号隔开；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello CSS!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>与HTML写在同一个文件</p><p>在 &lt;head&gt; 标签内定义 &lt;style&gt; 标签，书写css样式，分号隔开；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello CSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        font&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span>&gt;</span>Hello CSS!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外部引入</p><p>在 &lt;head&gt; 标签内定义&lt;link&gt;标签引入外部css文件，此时外部引入的文件内部不需要写style标签；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/hello_css.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-常用选择器"><a href="#2-2-常用选择器" class="headerlink" title="2.2 常用选择器"></a>2.2 常用选择器</h4><ul><li><p>id选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.className</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>并集元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element1</span>,<span class="selector-tag">element2</span> ...&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有元素选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> <span class="selector-tag">element</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>父类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &gt; <span class="selector-tag">element</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.runoob.com/cssref/css-selectors.html">详见此处</a></p></li></ul><h4 id="2-3-盒子模型"><a href="#2-3-盒子模型" class="headerlink" title="2.3 盒子模型"></a>2.3 盒子模型</h4><ul><li>布局问题，注意找准参考系：<ul><li>margin 外边距</li><li>padding 内填充<ul><li>会将盒子“撑开”</li><li>使用<code>box-sizing: border-box</code> 设置盒子的属性，让盒子固定为设置的宽高；</li></ul></li></ul></li><li>浮动问题：<ul><li>&lt;div&gt;是块级元素会自动换行，可以通过 float 属性设置左右浮动，从而不换行；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁及其检测和预防</title>
      <link href="Operating%20System/%E6%AD%BB%E9%94%81%E5%8F%8A%E5%85%B6%E6%A3%80%E6%B5%8B%E5%92%8C%E9%A2%84%E9%98%B2.html"/>
      <url>Operating%20System/%E6%AD%BB%E9%94%81%E5%8F%8A%E5%85%B6%E6%A3%80%E6%B5%8B%E5%92%8C%E9%A2%84%E9%98%B2.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>　　如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是<strong>死锁</strong>的。</p></blockquote><p>　　上面的定义比较抽象，用大白话讲就是：多个进程（线程）互相请求他人的资源而又不肯放弃自己持有的资源，就会发生死锁。<strong>本质上是资源在时序上的分配不合理造成的问题。</strong></p><p>　　<strong>资源</strong>按照被剥夺后所造成的后果严重性，分为<strong>可抢占资源</strong>和<strong>不可抢占资源</strong>。可抢占资源如主存，由操作系统保证进程所占有内存页面的换入换出，即使被抢占也不会造成严重的后果；不可抢占资源如打印机，如果打印机被抢占，那打印的内容将会混乱。</p><p>　　显然，（在系统满足的前提下）可抢占肯定不会造成死锁。</p><p>　　什么情况下可能会产生死锁？</p><ul><li><p><strong>产生死锁的必要条件：</strong></p><ol><li><p>资源互斥：一个资源只有两种状态，被占用和可用；</p><p>反例：只读资源可以不互斥；</p></li><li><p>非剥夺控制：即进程在持有某资源时，不可被抢占；</p></li><li><p>逐次请求：即请求的多个资源不能一次性打包请求；</p><p>一次性请求可能会饿死但不会死锁；</p></li><li><p>环路等待：进程和资源在请求与分配的关系上的有向图形成一个环路。</p></li></ol></li></ul><a id="more"></a><br><hr><h3 id="1-描述资源请求与分配的模型"><a href="#1-描述资源请求与分配的模型" class="headerlink" title="1. 描述资源请求与分配的模型"></a>1. 描述资源请求与分配的模型</h3><p>　　通过模型，我们可以比较容易的判断是否或可能发生死锁，我们把进程对资源的一系列操作抽象为三个步骤，请求、使用、释放，所以就有这两种状态：进程阻塞在请求的资源上和进程正在占有该资源。</p><h4 id="1-1-资源分配图"><a href="#1-1-资源分配图" class="headerlink" title="1.1 资源分配图"></a>1.1 资源分配图</h4><p>　　我们用圆形来表示进程，用方形表示资源，进程到资源的有向边表示进程正在请求并阻塞在该资源，资源到进程的有向边表示进程占有资源。</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/mpzTe1Ihm6Md.png" alt="mark"></p><p>　　如上左图所示，P1占有资源S2又请求S1，P2占有资源S1又请求S2，资源分配图形成了一个环路，即发生死锁。</p><p>　　为什么说<strong>死锁是资源分配在时序上的错误</strong>，如上右图所示，进程P1和P2同时请求资源S2，若将S2分配给P1，P2会被阻塞，但P1满足条件运行完后会释放资源，唤醒阻塞在S2上的P2；若将S2分配给P2，则和左图情形一样，会发生死锁。</p><h4 id="1-2-资源分配矩阵"><a href="#1-2-资源分配矩阵" class="headerlink" title="1.2 资源分配矩阵"></a>1.2 资源分配矩阵</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Q9Xivhpfjy0u.png" alt="mark"></p><p>　　如图所示，共有<strong>m</strong>种资源，向量<strong>E</strong>表示每种资源的总数，向量<strong>A</strong>表示某一时刻每种资源的可用个数；左边为分配矩阵，每行表示一个进程已经获得的对应资源的个数；右边为请求矩阵，每一行表示一个进程仍需要对应资源的个数才能运行。</p><p>　　显然，某时刻 <code>E - 分配矩阵的所有行 = A</code>，用 A 和请求矩阵的每一行相比较，即能发现将资源分配给哪一个进程可以避免死锁。</p><br><hr><h3 id="2-死锁的检测"><a href="#2-死锁的检测" class="headerlink" title="2. 死锁的检测"></a>2. 死锁的检测</h3><p>　　检测的结果是死锁可能发生也可能没有发生，当系统发现CPU的利用率降到了某一阈值，有多个进程阻塞很久时，就要质疑是否发生了死锁，对其进行检测。若发生死锁，通常的做法是剥夺一些死锁进程的资源重新分配，或按优先级逐个杀死一些死锁进程直到死锁解除。</p><p>　　结合资源分配图，使用相关算法来<strong>判断图中有没有环路</strong>，进而判断是否发生死锁。有常用的两种方法，拓扑排序和深度优先遍历（Depth First Search，DFS）：</p><h4 id="2-1-拓扑排序"><a href="#2-1-拓扑排序" class="headerlink" title="2.1 拓扑排序"></a>2.1 拓扑排序</h4><blockquote><p>　　对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则<u>u在线性序列中出现在v之前</u>。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p></blockquote><ul><li><p>步骤：</p><ol><li>从图中找到一个没有前驱结点（入度为0）的顶点输出；</li><li>删除以这个顶点为起点的边（以产生下一个入度为0的节点）；</li><li>重复上述过程，若最终有顶点没有被输出，说明有环。</li></ol><p>注意：结果可能不唯一；</p></li><li><p>举例：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/yIO6ngewP7IS.png" alt="mark"></p><p>　　如上图，先找到一个入度为0的节点<code>1</code>，输出并删除其出边；然后<code>2</code>、<code>3</code>成为新的入度为0的节点，随机选取一个，假设选取<code>2</code>；然后<code>3</code>成为唯一一个入度为0的节点，选择<code>3</code>，剩下的点入度都不为0，即存在环路；</p></li></ul><h4 id="2-2-深度优先遍历"><a href="#2-2-深度优先遍历" class="headerlink" title="2.2 深度优先遍历"></a>2.2 深度优先遍历</h4><ul><li><p>步骤：</p><ol start="0"><li><p>使用一个空的点集L记录已经遍历过的点，还要有方法标记遍历过的边，对图中的每一个节点N，都执行下面几个步骤；</p></li><li><p>将L初始化为空集，清除所有边的标记；</p></li><li><p>将当前节点添加到集合L尾部，检测当前节点在L中是否唯一，不唯一则说明成环，算法结束；</p></li><li><p>从当前节点开始检测是否存在没有被标记的出边，如果有执行第4步，否则执行第5步；</p></li><li><p>随机选取一条没有被标记的出边，标记它，并顺着它找到新的当前节点，跳到第3步；</p></li><li><p>回溯到上一节点，若这一节点是起始节点，则表明没有环路。</p></li></ol></li><li><p>举例：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/3wCIMPBsBOd5.png" alt="mark"></p><p>　　如上图，假设先选取<code>4</code>，深度遍历<code>L=&#123;4，6，7&#125;</code>，回溯两次回到节点<code>4</code>，说明从节点<code>4</code>开始没有环路；再选择节点<code>1</code>，可能出现<code>L=&#123;1,3,2,4,6,7&#125;</code>，回溯到<code>2</code>，再依次走到节点<code>5，3</code>，当前<code>L=&#123;1,3,2,4,6,7,5,3&#125;</code>，出现重复节点<code>3</code>说明出现环路。</p><p>　　显然DFS没有拓扑排序方便，因为DFS要将所有节点都作为根节点穷举一遍所有路径，才能确保真的没有环路。</p></li></ul><br><hr><h3 id="3-死锁的预防"><a href="#3-死锁的预防" class="headerlink" title="3. 死锁的预防"></a>3. 死锁的预防</h3><p>　　死锁的检测是怀疑发生死锁并对其进行检测，而死锁的预防，就是要未雨绸缪，提前采取一些措施判断将资源分配给某进程后是否可能会引发死锁，从而预防死锁的发生。</p><h4 id="3-1-银行家算法"><a href="#3-1-银行家算法" class="headerlink" title="3.1 银行家算法"></a>3.1 银行家算法</h4><p>　　将金钱和借款人分别比作资源和进程，将贷款动作比作进程请求资源的动作，银行家需要合理的调度金钱以满足借款人的需求，保证银行的正常运行。即要判断将资源分配给某进程后是否安全，结合资源分配矩阵，可以比较容易理解。将剩余资源向量和资源请求矩阵的每一行进行对比，能满足的就是安全的。</p><p>　　<img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/8rXLaSgyMBcY.png" alt="mark"></p><p>　　如图所示，向量 <strong>E</strong> 是每种资源的个数，<strong>P</strong> 是当前已分配出的相应资源个数，<strong>A</strong> 是当前剩余相应资源的个数。将向量 <strong>A</strong> 与请求矩阵的每一行一一比较，容易发现，这一时刻只有将资源分配给D进程才可以避免死锁，D完成后释放资源又可以满足其他进程。</p><h4 id="3-2-破坏死锁的必要条件"><a href="#3-2-破坏死锁的必要条件" class="headerlink" title="3.2 破坏死锁的必要条件"></a>3.2 破坏死锁的必要条件</h4><p>　　银行家算法是比较难以实现的，因为系统实际运行中，进程数目可能是不断变化的，而且进程可能在运行过程中才知道自己需要哪些资源，进而发出请求，所以想要预判的较为精确是很困难的，除非某一系统就像上面例子一样，相对固定的进程、资源和请求数。</p><p>1、<strong>破坏资源互斥：</strong></p><p>　　我们一直说死锁是资源在时序上的分配错误，那当资源无限多的时候就不会发生死锁。当然资源不可能无限多，但可以从另一个角度考虑，若我们能缩短资源被占有的时间，让资源提升它的服务效率，那是不是也能降低死锁发生的概率。</p><p>　　这其实也可以看做是快速设备和慢速设备之间的不匹配问题，进程在内存中运行的速度快，资源比如打印机这样的外部设备速度慢。我们怎么解决CPU和主存之间的速度不匹配的，我们也就可以解决进程和打印机之间的速度不匹配，答案是提取出一个中间的缓存层，如<strong>假脱机方式</strong>。</p><p>　　脱机，可以想到浏览器处于断网状态时，脱机工作还可以访问本地缓存的页面，这是被迫使用缓存。而假脱机是主动使用缓存，多个要打印的进程不直接请求打印机，而是将要打印的内容输出到一个中间层，由打印机程序去决定要打印哪些内容，这样每个进程不再独立的占用打印机资源，打破了资源互斥条件，不会发生死锁。</p><p>2、<strong>破坏非剥夺：</strong></p><p>　　如一开始对资源的分类中举的例子，进程对内存的使用就可以被剥夺，因为有操作系统来保证内存页面的换入换出；对CPU的使用也是这个道理，保证进程调度之后能从断点处继续运行。这就是破坏了非剥夺条件，不会发生死锁，但是要考虑剥夺的代价。</p><p>3、<strong>破坏逐次请求：</strong></p><p>　　比如多个进程都要请求扫描仪和打印机资源，逐次请求就可能发生死锁，而若将扫描仪和打印机封装成一个资源“扫描打印机”，那逐次请求变为一次请求，就不会出现互相请求对方的资源又不放手自己的资源这种情况。但是这样会造成资源利用率的降低，假设一个进程扫描工作达10分钟，那其他只想要打印的进程在这段时间内也无法时候用打印机。</p><p>4、<strong>破坏环路：</strong></p><p>　　可以对资源进行编号，一个进程想要请求多个资源，必须按照资源的编号升序进行请求与获取。如进程P想要请求１号扫描仪，２号打印机，必须先获得扫描仪才有可能再获得打印机。</p><br>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程及其调度与通信</title>
      <link href="Operating%20System/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B6%E8%B0%83%E5%BA%A6%E4%B8%8E%E9%80%9A%E4%BF%A1.html"/>
      <url>Operating%20System/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B6%E8%B0%83%E5%BA%A6%E4%B8%8E%E9%80%9A%E4%BF%A1.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　人们对计算机的算力追求是永无止境的，当一块CPU上再难以集成更多的晶体管来提升算力时，多道程序设计的思想大大提高了CPU的利用率。</p><p>　　CPU是高速设备，硬盘等是低速设备，提升CPU利用率的方法是并发，本质是当碰到一些需要等待低速设备协作才能完成的任务时，CPU能转去执行其他操作而不是空转等待低速设备完成工作。例如磁盘I/O操作，没有DMA（Directory Memory Access）的时候磁盘I/O也要经由CPU处理，DMA的职责就是在磁盘和内存之间进行搬运工作（仍受CU的控制），有了DMA之后CPU才可以在磁盘I/O的时候进行其他工作。</p><p>　　<strong>进程（Process）：</strong>我们把内存中一个正在运行的程序称作一个进程，进程是操作系统分配资源的基本单位（在没有引入线程的概念前，它也是系统调度的基本单位），进程间隔离性强，比较安全，进程的调度代价比较大。</p><p>　　<strong>为什么需要进程？</strong>因为我们知道<code>程序=数据结构+算法</code>，语义上“程序”是一个偏向于静态的概念，仅使用“程序”二字无法体现程序是在硬盘中还是正在跑在内存中。提出进程的概念，说明了程序运行时的动态性，<u>进程除了包括程序所包含的静态文本还包括了程序运行到某一时刻的状态信息。</u>同时，提出进程的概念，屏蔽了CPU调度、内存管理等底层细节，让程序可以更加专注于实现功能。</p><p>　　<strong>线程（Thread）：</strong>线程是进程的组成单元，是CPU进行调度的基本单位；线程可以共享所属进程的资源，线程比较轻量，调度开销较小。</p><p>　　<strong>有进程为什么需要线程？</strong>因为随着技术的发展，程序的功能不再单一，很多程序中都包含着多个任务，这些任务（尤其是CPU密集型和I/O密集型的组合）的并发执行也能够提升程序运行的效率，提升用户的体验，所以将每一个任务映射成为一个线程；同时最主要的也是弥补进程的不足，因为线程可以共享资源，且较进程的调度开销小（原因看下面进程调度和线程调度的比较）。</p><a id="more"></a><br><hr><h3 id="1-调度"><a href="#1-调度" class="headerlink" title="1. 调度"></a>1. 调度</h3><h4 id="1-1-调度的前提"><a href="#1-1-调度的前提" class="headerlink" title="1.1 调度的前提"></a>1.1 调度的前提</h4><h5 id="1-进程的调度"><a href="#1-进程的调度" class="headerlink" title="1. 进程的调度"></a>1. 进程的调度</h5><p>　　想要在多个进程间来回切换，要保证切换回某个进程时它能够从断点处继续执行，就好像没有被中断过一样。想要实现这样的效果就要记录下进程切换前一时刻的状态，便于切换回来的时候进行复原，这个记录叫做<strong>进程控制块（PCB）</strong>。</p><p>　　下图是PCB包含的一些内容：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/WmljeLg1AnGY.png" alt="PCB 包含内容"></p><p>　　操作系统维护一个<strong>进程表</strong>，进程表中的每一项就是一个PCB，记录着程序计数器、堆栈指针、优先级、内存分配上下界情况等与进程当前状态有关的重要信息。进程切换前，这些信息要被保存到某个地方，切换回来后再取出来恢复原状。</p><p>　　例如响应磁盘I/O中断请求的过程，一般磁盘I/O中断都有着较高的优先级，因为磁盘是一个慢速设备，得赶紧得到CPU的响应然后去干活，才好配合后面程序的运行。当进程P正在运行时，CPU接到磁盘I/O的请求，这时与进程P相关的信息入栈，通过中断向量找到中断服务程序的入口开始执行中断服务程序，CU给DMA发信号，磁盘I/O开始，中断服务程序返回，进程P的信息出栈复原，继续执行，就好像什么事都没发生。</p><br><h5 id="2-线程的调度"><a href="#2-线程的调度" class="headerlink" title="2. 线程的调度"></a>2. 线程的调度</h5><p>　　了解了进程的切换，其实线程的切换思想也是大同小异。线程也拥有自己的运行时信息，称为 TCB，如程序计数器、堆栈等，在切换前需要被保存，见下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/IzKgKMn8eRKP.png" alt="mark"></p><br><h5 id="3-进程调度-VS-线程调度"><a href="#3-进程调度-VS-线程调度" class="headerlink" title="3. 进程调度 VS 线程调度"></a>3. 进程调度 VS 线程调度</h5><p>　　调度的开销主要体现在<strong>对当前信息的更改</strong>和<strong>管态与目态的转换</strong>。</p><p>　　进程切换意味着PCB的信息要出入栈、CPU中的缓存不能用了需要刷新、<strong>内存管理单元</strong>（Memory Management Unit，MMU）的页表信息需要更新、要从目态进入到管态、若内存比较小不足以多个进程同时存在，还会引发页面的换入换出……代价极高。</p><p>　　线程切换时，若隶属于同一个进程，则绝大部分信息都不用更改。对于进不进管，<strong>用户级线程</strong>切换不需要进管，<strong>内核级线程</strong>切换需要进管。用户级线程就是用程序来实现多个线程，从CPU的角度看，用户线程是透明的，即CPU只看到一个进程，故即便是多核处理器也无法实现用户级线程的并行，但是有个好处是可以实现自定义的调度算法。内核级线程，就是真正意义上的多线程，可以由CPU调度。</p><ul><li><strong>MMU</strong></li></ul><p>　　我们写的代码中的数据及指令在编译连接后会被分配以<strong>虚拟地址</strong>，MMU位于处理器和主存的总线之间，用于处理虚拟地址到实际物理地址的映射。这样做有什么好处呢，首先我们程序员不需要关注物理内存的实际分配，其次虚拟空间使我们的可编程地址得以扩大。</p><ul><li><strong>管态和目态</strong></li></ul><p>　　<code>操作系统=内核+系统调用</code>，<strong>内核</strong>是操作系统的核心，也是一种软件，为其他程序提供了对计算机硬件的安全访问，也定义了该系统采用的进程调度方式、页面置换算法、文件管理方式……<strong>系统调用</strong>是操作系统向上提供的接口；</p><p>　　<strong>为什么要分管态和目态</strong>？（也叫内核态与用户态）主要是为了安全考虑。<code>程序=算法+数据结构</code>也可以说成是<code>程序=数据+定义在数据上的操作</code>，如果一个程序能够肆无忌惮的访问任何地方的数据和随心所欲的操作数据，那系统将遭受危机。因此，操作系统和要限制程序的权利，包括程序能够访问的地址空间（即限制数据）和程序能够进行的操作。操作系统工作在管态，普通程序工作在目态。</p><p>　　<strong>什么是进入管态？</strong>如上所说，程序权利被限制，处于目态的程序对一些敏感操作是无权执行的，需要委托给操作系统去执行，这时就要进入管态。通过一条特殊的访管指令，提出进管请求，由操作系统响应，执行完相应的系统调用再返回该程序。</p><br><h4 id="1-2-调度策略"><a href="#1-2-调度策略" class="headerlink" title="1.2 调度策略"></a>1.2 调度策略</h4><p>　　主要分为两大类：抢占式调度和非抢占式调度。<strong>抢占式调度</strong>指当系统认为某进程运行了足够长的时间片后，直接将它挂起，即便它还没运行完，通常PC端、服务器端使用；<strong>非抢占式调度</strong>指的是一个进程一直运行直到结束或发生了阻塞，通常移动端使用。</p><p>　　一些判优条件：公平性，吞吐量，平均周转时间……</p><h5 id="1-非抢占式调度"><a href="#1-非抢占式调度" class="headerlink" title="1. 非抢占式调度"></a>1. 非抢占式调度</h5><ul><li><p><strong>先来先服务（FCFS）</strong></p><p>像超市排队收银一样维护一个队列，新来的进程排在队尾。看似公平，可是对I/O密集型进程很不友好。</p></li><li><p><strong>短进程优先</strong></p><p>大大减少了平均周转时间，提升了用户的体验，但是准确估算进程运行时间较难，而且多个进程在同一时刻到达才能发挥最大作用。</p></li></ul><br><h5 id="2-抢占式调度"><a href="#2-抢占式调度" class="headerlink" title="2. 抢占式调度"></a>2. 抢占式调度</h5><blockquote><p>下面几个本质都是时间片轮转。</p></blockquote><ul><li><p><strong>时间片轮转法</strong></p><p>最公平且使用最广泛，一视同仁的为所有进程分配相同的时间片，但是时间片的大小不容易控制，太大容易空转，太小调度太频繁。</p></li><li><p><strong>优先级调度</strong></p><p>为进程排上优先级，优先级可以是静态的也可以是动态的。静态优先级容易饿死优闲级低的进程，动态优先级的计算耗费资源。</p></li><li><p><strong>多队列轮转</strong></p><p>有多个优先级队列，低优先级队列分配的时间片多一些，当某一个进程经过一次轮转还没有结束，就降低它的优先级，下一次轮转它会获得较第一次多的时间片，即<u>减少了长进程的调度次数。</u></p></li></ul><br><hr><h3 id="2-进程间通信"><a href="#2-进程间通信" class="headerlink" title="2. 进程间通信"></a>2. 进程间通信</h3><blockquote><p><strong>进程间通信</strong>（InterProcess Communication，IPC）</p></blockquote><ul><li><p><strong>为什么进程间隔离性强？</strong>这是因为每个进程的内存分配的上下界信息会加载进一个寄存器（称为<strong>界限寄存器</strong>），CPU执行相关指令时会将操作数的内存地址与界限寄存器中的地址进行比较，从而保证了进程的隔离性。隔离性保证了安全，但是进程间的通信问题就应该被考虑了。</p></li><li><p><strong>进程间通信要解决的问题：</strong></p><ul><li>消息如何在进程间传递；</li><li>对临界资源访问（互斥问题）；</li><li>进程间的协作（同步问题）；</li></ul><p>注意：同步和互斥问题同样适用于线程。</p></li></ul><h4 id="2-1-进程间消息传递"><a href="#2-1-进程间消息传递" class="headerlink" title="2.1 进程间消息传递"></a>2.1 进程间消息传递</h4><p>　　关键字：管道、共享内存、消息、套接字、信号……</p><p>　　（插眼！）</p><h4 id="2-2-同步与互斥"><a href="#2-2-同步与互斥" class="headerlink" title="2.2 同步与互斥"></a>2.2 同步与互斥</h4><ul><li><strong>锁思想</strong></li></ul><p>　　设一个共享的锁变量lock，初值为0，进程到来时先判断锁的状态，若lock=0则表示临界区没有上锁，此时进程对其上锁修改lock=1，进入临界区进行操作，出临界区时再将锁打开。</p><p>　　存在的一个问题就是这个锁变量本身也应该被看做是一个临界资源，如当进程P0发现lock=0，准备上锁时，发生了进程调度，P1到来发现lock=0，于是修改lock=1上锁进入了临界区。若P1在时间片内还没有出临界区开锁，当再切换回P0时就会出现问题；</p><br><ul><li><strong>自旋锁（spin lock）</strong></li></ul><p>　　两个进程P0、P1，lock初始值为0，用于记录允许几号进程进入临界区，过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---进程P0---</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(lock!=<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 临界区操作;</span></span><br><span class="line">    lock = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 非临界区操作;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---进程P1---</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(lock!=<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 临界区操作;</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 非临界区操作;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　假设P0先到来，检查lock发现等于0，进入临界区操作，出临界区后将lock置为1；这时P1到来检查lock等于1，同理。这种连续检查某一个值直到出现为止成为<strong>忙等待</strong>，时间片内一直在检查lock，没有阻塞挂起一说，即浪费了CPU时间。</p><p>　　同时还会出现<strong>进程被在临界区外的其他进程阻塞</strong>的情况。假设现在P1想进入临界区，而lock=0，进程P0一直工作在非临界区，没有进入临界区的意思，就不会有出临界区修改lock的操作，这时P1被处在非临界区的P0阻塞。这个叫做<strong>不可重入</strong>，即一个进程不能连续两次持有相同的锁。</p><p>　　当然它也有优点。首先线程一直处在活动状态不会被阻塞挂起，减少了线程切换的代价，当然这一点对单核处理器来说毫无意义，因为总得切换到其他进程修改lock才可以。</p><br><ul><li><strong>Peterson解法</strong></li></ul><p>　　解决了上述不可重入的问题，过程如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/WigJmny2Ms5R.png" alt="Peterson解法"></p><br><ul><li><strong>TSL 指令</strong></li></ul><p>　　考虑进程切换只会发生在响应时钟中断和其他中断发生时，可以在某进程进入临界区后通知CPU屏蔽中断，这样在单核处理器中就不用担心其他进程在进入临界区，但是把屏蔽中断的权利交给任意进程对系统是不安全的。</p><p>　　在多核处理器中，哪个核调用屏蔽中断的指令，就只会屏蔽这个核响应中断，对其他核没有影响，于是就有了<strong>测试并加锁</strong>（Test and Set Lock，TSL）指令。执行TSL指令会锁住数据总线，屏蔽了其他处理器对内存的读写操作。</p><br><blockquote><p>上面都会出现忙等待问题。</p></blockquote><br><ul><li><strong>信号量</strong>（semaphore）</li></ul><p>　　信号量S能够表示能否进入临界区和要唤醒的次数，通过两个<strong>原子操作</strong>实现：</p><p>　　<strong>P(S):</strong>  S:=S-1；<br>　　<br>　　          若S≥0，调用P(S)的进程进入临界区；<br>　　<br>　　　　  若S&lt;0，调用P(S)的进程进入阻塞队列；<br>　　<br>　　**V(S):**  S:=S+1；<br>　　<br>　　          若S&gt;0，调用P(S)的进程继续运行；<br>　　<br>　　　　  若S≤0，调用P(S)的进程唤醒阻塞队列中的一个进程，然后继续运行；</p><p>　　因为信号量也是一种临界资源（存在内核中或共享内存中），所以对于上述这个两个过程，包括判断、修改、挂起进程的操作必须是不可分割的原子操作。单核CPU使用屏蔽中断，多核CPU使用TSL指令实现来确保同一时刻只有一个CPU能操作信号量。</p><ul><li><strong>互斥量</strong>（mutex）</li></ul><p>　　是信号量的简化版本，即信号量mutex只表示加锁和解锁两个状态。</p><ul><li><strong>管程</strong>（monitor）</li></ul><p>　　管程是一种<strong>语言特性</strong>，是一种高级同步原语，是一种互斥的自动化。考虑下面问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程P1 // 进程P2</span></span><br><span class="line">P(扫描仪)P(打印机)</span><br><span class="line">P(打印机)P(扫描仪)</span><br><span class="line">  ......</span><br><span class="line">V(打印机)V(扫描仪)</span><br><span class="line">V(扫描仪)V(打印机)</span><br></pre></td></tr></table></figure><p>　　显然上面的两个进程有可能会发生死锁，应该将P2对信号量的操作顺序改为和P1一致。这说明信号量的使用是一个非常细致的工作，稍有考虑不周全的地方就有可能出现错误，而我们程序员只是想要关心哪些代码、内存能否互斥访问，不想要在信号量上费功夫。所以有些编程语言向我们提供了这一便利，由编译器帮我们实现信号量的PV操作，更能保持并发编程的正确性。</p><p>　　如Java的<code>synchronized</code>关键字，我们用它声明一个方法可以表示互斥访问，信号量就是锁对象，具体信息记录在对象头的MarkWord中。</p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的创建、内存结构及其大小</title>
      <link href="JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%A4%A7%E5%B0%8F.html"/>
      <url>JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%A4%A7%E5%B0%8F.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><p>　　对象的创建包括new创建、反射创建、复制、反序列化这几种方式，下面主要讨论使用new创建对象的过程，以及对象的内存结构。知道了对象的内存结构，就可以知道一个对象在内存中占据的大小。</p><a id="more"></a><br><hr><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h3><p>　　<strong>总结：</strong>分配内存 → 初始化（包括赋“零”值，设置头信息）→ 引用入栈 → 构造函数。</p><p>　　当 JVM 遇到new指令时，首先会在常量池中寻找，看有没有这个类的符号引用，没有找到即不合法、不存在；然后查看该类有没有被加载过，若没有，则必须先执行类的加载过程。</p><p>　　在类加载的过程中就会确定该类的对象所需的内存块大小，为对象分配内存的过程就是从堆中划分出一个相应大小的内存块，多线程环境下这个划分操作必须保证原子性。JVM 使用CAS加失败重试的方法保证其原子性。还有一种操作叫做<strong>TLAB分配</strong>，即为每个线程分配一个<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，<strong>TLAB</strong>），每个线程创建对象时直接使用自己的TLAB，避免了多线程同时操作堆中的同一片区域，但当一个线程的TLAB不够用而去再申请一块新的TLAB时，还是采取CAS。使用<code>-XX: +/-UseTLAB</code>参数设定是否启用TLAB。</p><p>　　TLAB 是从堆中标记的一块专门给某线程创建对象的区域，本质还是在堆中，只是在分配上是线程私有，使用上还是和堆一样，线程共享。<a href="https://www.zhihu.com/question/56538259">具体可参考此处</a></p><p>　　分配完内存，JVM 要将该对象的实例数据部分初始化为<strong>“零”值</strong>，即在类中不需要赋值就能使用的默认值，如整形默认0，浮点型默认0.0，boolean默认flase，String默认空串“ ”，引用型默认为null……</p><p>　　赋“零”值完了之后，还要对对象头的信息进行设置，对象头包含了关于该对象的一些描述信息，如它是谁的实例，如何找到对应的元数据信息，GC分代信息……</p><p>　　完成上述之后，将对象的引用入栈，最后才真正开始运行到我们写的Java代码，即执行构造函数。</p><br><hr><h3 id="2-对象的内存结构"><a href="#2-对象的内存结构" class="headerlink" title="2. 对象的内存结构"></a>2. 对象的内存结构</h3><p>　　对象的内存结构可以分为三部分：对象头、实例数据、对齐填充。</p><ul><li><p><strong>对象头</strong>包含下面这几部分信息：</p><ul><li><p>第一部分称为<strong>“Mark Word”</strong>，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，它的<strong>大小</strong>和虚拟机的位数相同；</p></li><li><p>第二部分是**”Klass Word”<strong>，用于存储</strong>类型指针<strong>——一个指向该对象的</strong>元数据**信息的OOPs，它的大小要根据是否开启了指针压缩来判断；</p><ul><li>元数据（不是Class对象），即我们常说的存在于方法区（元空间）的类加载过程中从class文件中提取出来的的类结构信息，如类中包含的变量名、方法名、方法执行的代码……</li></ul></li><li><p>如果是数组，还会有一部分信息用于记录数组的长度。</p></li></ul></li></ul><p>　　有无类型指针取决于具体虚拟机的实现，寻找元数据并不一定要非要经过对象头中的类型指针，如使用句柄访问对象，句柄中除了包含对象实例的指针，还包括指向该对象的元数据的指针，这时就不必在对象头中添加类型指针。具体可参照下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/XLVpUVIx2gK6.png" alt="mark"></p><ul><li><p><strong>实例数据部分</strong>，存储我们代码中定义的成员，包括从父类继承下来的。</p><ul><li>存储顺序受到两方面影响：<ul><li>一方面是虚拟机分配策略（参数：-XX：FieldsAllocationStyle），默认分配顺序是longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary<br>Object Pointers，OOPs），即按照所占内存空间从大到小分配空间；</li><li>另一方面受到成员在代码中定义的顺序影响，且<strong>父类成员会被分配在子类之前</strong>。</li></ul></li></ul></li><li><p><strong>对齐填充</strong>，即将对象内存大小填充到 <strong>8 字节</strong> 的整数倍，方便虚拟机寻址。</p></li></ul><br><hr><h3 id="3-对象所占内存的计算"><a href="#3-对象所占内存的计算" class="headerlink" title="3. 对象所占内存的计算"></a>3. 对象所占内存的计算</h3><ul><li><p>知道了对象的内存结构，很容易可以知道：</p><ul><li><code>对象(obj) = 对象头(Header) + 实例数据(Data) + 对齐填充(Padding)</code></li></ul></li><li><p>Data和Padding比较好计算，最关键的一部分就是Header的大小：</p><ul><li><code>Header = MarkWord + KlassWord(若有) + 描述数组长度的数据(若有)</code></li></ul></li><li><p>HotSpot虚拟机采用通过指针直接访问的方式寻找对象，所以它有KlassWord，我们计算时需要加上KlassWord。MarkWord大小与VM的位数相同，KlassWord存储的是一个类型指针，它又是多大？这就得了解一下<strong>指针压缩（compressed oops）</strong>的概念：</p></li></ul><h4 id="3-1-指针压缩"><a href="#3-1-指针压缩" class="headerlink" title="3.1 指针压缩"></a>3.1 指针压缩</h4><p>　　指针压缩在 JVM 中就是将 64bit 的指针压缩为 32bit，是针对64位VM而言的。</p><ul><li><strong>为何压缩</strong></li></ul><p>　　程序里面到处都是指针引用，不压缩占内存，这也是为什么相同软件64位比32位大一点；不仅指针变”大”了，而且与其相关的操作代价也变大了，比如内存中维护的一些表就要变大。</p><ul><li><strong>怎么压缩</strong></li></ul><p>　　压缩成32bit的前提是：堆内存要在<strong>32GB以下</strong>。</p><p>　　32位按字可寻址范围为2<sup>32</sup>=4GB，回想对齐填充中说的，对象都是按8字节补齐，也就是说对象的地址末三位都是0，这意味着什么，可以省略掉末三位，就像表示浮点数时省略个位的“ 1 ”一样，取值的时候再左移三位即可恢复。</p><p>　　即我们现在的最大可寻址范围为2<sup>32+3</sup>=32GB，超过了32GB就不行了，可以理解为没压缩前按单字寻址，压缩后按“8字”寻址。</p><ul><li><p><strong>对象头大小</strong></p><p>现在就知道了<strong>非数组</strong>的对象头的大小：<code>MarkWord + KlassWord</code></p><ul><li>32位VM：32+32 = 64 bit = 8 Byte；</li><li>64位VM（不压缩指针）：64+64 = 128 bit = 16 Byte；</li><li>64位VM（压缩指针）：64+32 = 98 bit = 12 Byte；</li></ul><p><strong>数组</strong>的对象头的大小：再加上 <strong>4 Byte</strong> 的描述数组长度的信息。</p></li><li><p>其他</p><ul><li>对象中的引用型属性，只是一个引用，根据是否开启了指针压缩，为4 或 8 Byte。</li><li>静态属性属于类，不做计算。</li></ul></li></ul><h4 id="3-2-计算对象大小"><a href="#3-2-计算对象大小" class="headerlink" title="3.2 计算对象大小"></a>3.2 计算对象大小</h4><blockquote><p>环境：JDK1.8、64位、默认开启了指针压缩；</p><p>即Header大小为：12Byte 或 16Byte（含数组）；</p></blockquote><ul><li><p>看看下面的 Son 的对象占几个字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fInt;<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sInt;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sonL;<span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>12(Header) + 4(fInt) + 4(sInt) + 8(sonL) + 4(padding)= 32Byte;</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/wHQhWV8F1yo8.png" alt="mark"></p></li><li><p>如果没有开启指针压缩：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/48ybJJWCseF3.png" alt="mark"></p></li></ul></li></ul><br><ul><li><p><strong>关于填充：</strong></p></li><li><p><strong>问题：</strong>上面的截图是使用IDEA中的 “JOL” 插件静态分析得到的，当我使用 JVisualVM 查看堆dump的时候，发现实际大小好像和上面截图中的结果有些出入，换了环境不断调整参数结果还是不一样。网上找的一些博客资料都是这样算的，emmm我有点怀疑（大概率是我的环境问题吧），姑且先认为上面是对的吧。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
      <url>JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>加载、连接、初始化…</p></blockquote><a id="more"></a><h3 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1. 类加载过程"></a>1. 类加载过程</h3><p>　　伴随着一个类在JVM中从装载到卸载的整个过程，它的生命周期可分为如下图所示的几个阶段：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/NxT5h7X2gcSs.png" alt="类加载过程"></p><p>　　其中加载、验证、准备和初始化有着严格的<strong>先后开始顺序</strong>，即解析可能发生在初始化之后，且各个阶段交错进行，在一个阶段的执行过程中会通知、调用另一个阶段。例如，类文件加载一部分后，调用验证阶段，验证过程中发现类文件有误，随即可以通知加载阶段不再加载；关于解析和初始化的顺序主要是Java运行时的一些特性决定的。</p><h4 id="1-1-加载阶段"><a href="#1-1-加载阶段" class="headerlink" title="1.1 加载阶段"></a>1.1 加载阶段</h4><blockquote><p>区别于JVM类加载与类生命周期中的加载，下面都把JVM类加载称为“装载”；</p></blockquote><ul><li><p>一个类什么时候需要加载？</p><p>对一个类<strong>主动引用</strong>时才加载，JVM规范规定了如下六种情况会对类进行加载：</p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，即</p><ul><li>new 对象时，new数组时的字节码指令是newarray；</li><li>读取或设置一个类的静态属性时；</li><li>调用一个类的静态方法时；</li></ul></li><li><p>使用反射调用Class时；</p></li><li><p>初始化子类时，要先初始化其父类；</p><ul><li>子接口初始化时不要求父接口初始化，真正使用到父接口时才会初始化；</li></ul></li><li><p>接口中定义了默认方法时，初始化其实现类之前要先初始化该接口；</p></li><li><p>虚拟机启动时用户指定的主类（包含main的类）；</p></li><li><p>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p><br/></li></ol></li><li><p>除了主动引用还有<strong>被动引用</strong>，这时不会初始化类：</p><ol><li>通过子类引用父类静态字段，不会初始化子类；</li><li>通过数组定义来引用类；<ul><li>数组不通过加载器而是虚拟机直接在内存中动态构造出来，在解析阶段中会加载数组元素对应的类，生成一个替代的JVM内部维护的类（就是我们看到的类前面加一个‘ [ ’），不会对数组引用的类进行初始化；</li></ul></li><li>类A仅引用类B的常量时；<ul><li>编译阶段会进行<strong>常量传播优化</strong>，已经将B类的常量直接储存到A的常量池中；<ul><li>不包括接口，即引用接口中的常量时，接口会初始化。</li></ul></li></ul></li></ol></li></ul><br/><ul><li><p>加载过程</p><ol><li>通过全限定类名获取定义此类的二进制字节流；<ul><li>来源可以是.class文件，网络，jar包，JSP，或者动态代理生成等；</li></ul></li><li>将字节流所代表的静态结构转换为方法区（元空间）运行时数据结构；</li><li>在堆中生成一个代表这个类的Class对象；</li></ol><p>　　加载阶段是类装载过程中我们可干预性最高的阶段，主要体现在加载阶段我们可以自定义类加载器，而其他阶段都不好预。</p></li></ul><br/><h4 id="1-2-验证阶段"><a href="#1-2-验证阶段" class="headerlink" title="1.2 验证阶段"></a>1.2 验证阶段</h4><p> 　　一直说Java特性是跨平台、封装、继承、多态、安全……而这个<strong>安全性</strong>很大程度上就是由验证阶段保证的。上面加载阶段提到了加载的Class文件可能是以各种形式各种方法获取到的，例如人为的编写字节码文件对不可见的内存区域进行访问破坏，如果虚拟机不对它进行检查，那要出大事；</p>   <br/><pre><code>  1. 文件格式验证：     - 主要是对class文件的格式进行验证，如是否以对应魔数开头、版本号是否兼容、常量池中的常量是否符合要求……  2. 元数据验证：     - 主要是对类结构进行语义分析。如一个类是否有父类、是否继承了不该继承的final类、是否实现所继承抽象类的所有抽象方法……  3. 字节码验证：     - 主要是对类中方法属性等进行语义分析。如方法体中的类型转换是否有效、跳转指令是否合法……  4. 符号引用验证：     - 发生在解析阶段，主要是对该类是否有对它依赖的外部资源的访问权限的验证，如符号引用中描述的全类名能否找到、符号引用中的类的方法和属性能否被当前类访问……     - 符号引用：主要包括类和接口的全类名、字段的名称和描述符、方法的名称和描述符。</code></pre><p>　　验证阶段是一项非常耗时耗力的工作，在可信任的环境中可以通过<code>-Xverify：none</code>关闭大部分验证过程，以减少类加载时间；</p><br/><h4 id="1-3-准备阶段"><a href="#1-3-准备阶段" class="headerlink" title="1.3 准备阶段"></a>1.3 准备阶段</h4><ul><li>　　主要是对类分配到的<strong>内存区域进行初始化工作</strong>，简单点说就是刚分配到一块空闲的内存，谁知道里面放的是什么，准备阶段工作就是对其初始化一下；<ul><li>为类变量（static）分配内存并初始化内存，这里的初始化内存是将这片内存初始化为对应static变量类型的 “0” 值，而不是代码中定义的赋值，后者是初始化阶段的工作；</li><li>需要注意的是类常量（static finall）将在这个过程中直接赋值为代码中定义的值，因为静态常量在编译阶段就会确认；</li></ul></li></ul><h4 id="1-4-解析阶段"><a href="#1-4-解析阶段" class="headerlink" title="1.4 解析阶段"></a>1.4 解析阶段</h4><ul><li>主要是将常量池内的<strong>符号引用替换为直接引用</strong>。<ul><li>符号引用：是用一组符号描述所引用的目标，可以是任何形式的字面量，只要能唯一确定一个目标即可；</li><li>直接引用： 是可以直接指向内存中目标的引用，可以是指针、句柄、相对偏移量……</li></ul></li></ul><p>　　大白话讲就是，符号引用偏向于人类语义，直接引用就相当于指针，解析阶段就是将符号引用转换为实际运行过程中指向对应内存的指针；</p><ul><li><p>什么时候解析？</p><blockquote><p>　　虚拟机规范要求在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p></blockquote><p>　</p></li></ul><h4 id="1-5-初始化阶段"><a href="#1-5-初始化阶段" class="headerlink" title="1.5 初始化阶段"></a>1.5 初始化阶段</h4><p>　　初始化阶段是真正开始执行Java代码的阶段，主要任务是执行类构造器<code>&lt;clinit&gt;()</code>方法，注意区别于实例的构造方法<code>&lt;init&gt;()</code>。</p><blockquote><p>　　<clinit>()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作和静态语句块（static{}块）中的语句合并产生</strong>的，编译器收集的<strong>顺序是由语句在源文件中出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p></blockquote><ul><li><p>JVM会保证子类的&lt;clinit&gt;()方法执行之前执行父类的该方法；</p><ul><li>这就意味着父类static块一定优先于子类执行；</li><li>对接口而言不是这样，只有当父接口中定义的常量被子接口或实现类使用时，才会执行clinit方法；</li></ul></li></ul><ul><li><p>&lt;clinit&gt;()方法对于接口或类而言不是必须的；</p><ul><li>类中没有static块和类变量，接口中没常量（接口不能有static块），就不会生成&lt;clinit&gt;()方法；</li></ul></li></ul><hr><h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><ul><li><p><strong>启动类加载器</strong>（BootstrapClassLoader）：由C++实现，是虚拟机的一部分，无法直接引用。主要负责加载 JAVA_HOME\lib 目录下的类，而且按名称识别只能加载已知类库的类，即把自己写的class放进去也不会加载；</p></li><li><p><strong>其他类加载器</strong>：由Java实现，继承于java.lang.ClassLoader，独立于虚拟机之外，可以直接引用。</p><ul><li>扩展类加载器（ExtensionClassLoader）：用于加载 <JAVA_HOME>\lib\ext 目录下的类；</li><li>应用程序类加载器（ApplicationClassLoader）：用于加载用户类路径下的类，也是程序中默认引用的类加载器；</li></ul></li><li><p><strong>双亲委派模型</strong></p></li></ul><blockquote><p>JDK 9 之前的类加载器采用如下双亲委派模型式的三级结构</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="http://image.henrykang.site/blog/20200310/ppln7eXw3rsQ.png" alt="mark"></p><blockquote><p>　　双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此<strong>所有的加载请求最终都应该传送到最顶层的启动类加载器中</strong>，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p></blockquote><p>　　简单说就是父加载器能加载的不会让给子加载器，这样做使得类随着类加载器拥有了一定的上下级关系，保证了基础类的统一性（类加载器拥有独立的命名空间，即不同类加载器加载的同一个class文件产出的不是同一个类）；</p><ul><li><strong>破坏双亲委派模型</strong></li></ul><blockquote><p>当基础类要调用用户代码时就要破坏双亲委派模型</p></blockquote><p>　　当一些接口的实现放在用户程序的类路径下时，启动类加载器当然无法加载它们。这时候，父加载器就要请求子类加载器进行加载，如 JDBC。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器</title>
      <link href="JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html"/>
      <url>JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><h3 id="1-谁是垃圾？"><a href="#1-谁是垃圾？" class="headerlink" title="1. 谁是垃圾？"></a>1. 谁是垃圾？</h3><p>　　当一个对象不再被外界引用时，就成为了垃圾；GC主要回收的区域是<strong>堆和方法区</strong>，因为程序计数器和栈的生命周期和线程相同。</p><a id="more"></a><h4 id="1-1-堆的回收"><a href="#1-1-堆的回收" class="headerlink" title="1.1 堆的回收"></a>1.1 堆的回收</h4><p>　　怎样确定哪些是垃圾，主要有下面两种方法：</p><ol><li><p>引用计数法</p><blockquote><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p></blockquote><p>　　引用计数法难以解决间接引用或循环引用问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    Object b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String s[])</span></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能在一轮中回收a和b，因为a对象中有一个属性引用到b对象，只有a回收了，b才能回收；</span></span><br><span class="line"><span class="comment">// 还有可能循环引用，就是上述 a和b中的属性互相引用b和a对象，这时候引用计数法永远无法回收a和b；</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>可达性分析法</p><blockquote><p>　　这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p></blockquote></li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/hsIScu10IJtV.png" alt="mark"></p><ul><li><p><strong>哪些可以当做 GC Roots 对象：</strong></p><ul><li>栈中的局部变量，因为方法执行过程中使用到的对象资源当然不能被回收；</li><li>类的静态引用型变量，只要类不卸载，这些引用就一直存在；</li><li>JVM内常驻内存的对象，如基本型的Class对象、异常对象、类加载器等；</li><li>本地方法栈中 JNI （Native方法）引用的对象；</li><li>……</li></ul></li><li><p><strong>过程分析：</strong></p><p>假如有一个静态引用型变量 obj，它就可以作为GC Roots中的一员，从它向下搜索，对引用链上的对象进行标记，如 obj 内有一个A成员对象，A又有B、C两个成员对象，那A、B、C就不会被回收；把GC Roots中的根节点全部按此方法操作一番，剩下没标记的就是垃圾，等待被回收。</p></li></ul><h4 id="1-2-方法区的回收"><a href="#1-2-方法区的回收" class="headerlink" title="1.2 方法区的回收"></a>1.2 方法区的回收</h4><p>　　主要回收<strong>常量池</strong>和卸载<strong>类信息</strong>。</p><ol><li>判定废弃的常量比较容易，像回收堆中对象一样，若没有指向该常量的引用，就可以回收了；</li><li>判定不再使用的类非常困难，需要满足下面的条件：<ul><li>所有该类及其子类的实例都被回收了；</li><li>该类的Class对象没有被引用；</li><li>加载该类的类加载器已经被回收；<ul><li>这一点很难实现，因为大多都是采用默认加载器加载，我们不可能让默认加载器被回收；但其实这些类不卸载也没关系，它们一般不会占太大空间；需要注意的是我们自定义加载器，动态生成的类信息，这些类信息可能会膨胀而需要回收。</li></ul></li></ul></li></ol><hr><h3 id="2-垃圾收集思想"><a href="#2-垃圾收集思想" class="headerlink" title="2. 垃圾收集思想"></a>2. 垃圾收集思想</h3><h4 id="2-1-分代回收理论"><a href="#2-1-分代回收理论" class="headerlink" title="2.1 分代回收理论"></a>2.1 分代回收理论</h4><p>　　收集器将堆划分成具有不同年龄的区域，主要目的是对其进行不同频率的回收。至少分为<strong>新生代</strong>与<strong>老年代</strong>，随着收集次数的增加，那些存活下来的“年长的对象“被转移到老年代，<strong>老年代的对象往往有生命周期往更长发展的趋向性</strong>，我们就可以减少老年代回收垃圾的频率，以提升整个GC的效率。</p><p>　　MinorGC、MajorGC、FullGC 分别对应着新生代回收、老年代回收、整堆回收；GC是很耗费资源的，而FullGC的代价更不用说（一般会进行碎片整理），针对不同的区域采用合适的垃圾回收算法，可以减少FullGC的次数；后面会提到G1收集器，它属于MixedGC 混合回收。</p><p>　　分代回收有一个非常大的问题就是，两代对象之间可能存在<strong>跨代引用</strong>，这样在MinorGC过程中就不得不再遍历老年代对象。而经过实践证明或者由我们猜想可以得知：<strong>存在互相引用关系的两个对象有共存亡的趋向性</strong>。再结合上面说到的老年代有更年长的趋向性可以知道，跨代引用中的新生代对象有着很大的概率也会迈向老年代。因此我们可以不为跨代引用去遍历老年代。</p><h4 id="2-2-垃圾收集算法"><a href="#2-2-垃圾收集算法" class="headerlink" title="2.2 垃圾收集算法"></a>2.2 垃圾收集算法</h4><ol><li><p><strong>标记-清除（Mark-Sweep）</strong></p><p>根据前面说的判断垃圾的方法，对需要回收的对象进行标记，标记完之后进行统一回收；</p><p> 　　<strong>缺点</strong>：产生大量零头，后面如果碰到大对象而没有合适大小内存分配，有可能会引发FullGC；还有就是效率不稳定，随着对象数量的增加，不论是标记还是清除耗费的时间都是<strong>不可控</strong>的。后面会讲到GC追求低延迟，这就要求在时间上要有一定程度的可控性。</p><br/></li><li><p><strong>标记-复制（Mark-Copying）</strong></p><p>复制算法解决了清除算法产生大量零头的问题；</p><p> 　　该算法将内存分成1:1的A、B两块，每次只用其中一块，当 A 满了之后进行标记，将要存活下来的对象复制到另一块 B 上，然后清除 A 块，不断往复。<strong>主要运用于新生代</strong>；</p><p> 　　<strong>缺点</strong>：显而易见，浪费了很大的空间，同时在存活对象较多时复制操作效率也比较低。</p><p> 　　经验发现，新生代对象有将近98%都逃不过第一次回收，即不需要对内存进行1:1的划分，因此又有了下面的<strong>变体形式</strong>：</p><p> 　　将新生代内存分为两块较小的Survivor空间和一块较大的Eden空间，HotSpot默认比例为1:1:8，每次只用Eden和Survivor中的一块，方法和标记-复制一样，每次将存活下来的对象复制到另一块Survivor上；</p><p> 　　<strong>注意</strong>：</p><ul><li>当存活的对象超过一块Survivor大小时，通常需要由老年代内存进行<strong>分配担保</strong>，即有可能将“年龄不够”的对象<strong>提前转入老年代</strong>。</li><li>有一些大对象，如大数组、字符串，会直接进入老年代，避免在新生代的Eden和Survivor之间来回复制。</li></ul><br/></li><li><p><strong>标记-整理（Mark-Compact）</strong></p><p>整理算法和复制算法有异曲同工之妙，它通过移动对象来消除了复制算法中浪费的内存；</p><p>　　标记完之后将存活的对象都向内存的一端移动，然后清除边界以后的对象。<strong>主要用于老年代</strong></p><p>　　<strong>缺点</strong>：整理非常耗费时间，不但如此，移动对象并更新引用还会使<strong>用户进程被暂停</strong>，被形象成为“Stop The World”；</p><p>　　STW主要是由于枚举根节点造成的，因为用户线程运行中的引用关系可能会发生改变，影响根节点枚举结果的准确性，所以必须暂停用户线程；查找引用链工作可以与用户线程并发执行。</p></li></ol><p>　　<br/></p><hr><h3 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h3><blockquote><p>JDK1.8 默认使用 ParallelScavenge + ParallelOld 收集器；</p><p>JDK1.9 默认使用 G1 收集器。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="http://image.henrykang.site/blog/20200314/R7utwIia1JKj.png" alt="mark"></p><p>　　<img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/nOFD4ePsMtDj.png" alt="mark"></p><p>　　可以看到上面显示HotSpot工作在Server模式，相对的还有Client模式，二者的主要区别就在于JVM默认的一些参数和垃圾收集器的选用上有所不同，因为一般桌面端与服务器端的硬件差别是非常大的，在不同的应用场景下选择不同的垃圾收集器可以让用户获取更好的体验。</p><h4 id="3-1-新生代收集器"><a href="#3-1-新生代收集器" class="headerlink" title="3.1 新生代收集器"></a>3.1 新生代收集器</h4><ol><li><strong>Serial收集器</strong></li></ol><p>　　单线程收集器，进行回收时必须暂停其他线程，但是它简单高效，只专心于做垃圾回收没有额外的线程交互开销，因此是HotSpot虚拟机Client模式下默认的新生代收集器。</p><ol start="2"><li><strong>ParNew收集器</strong></li></ol><p>　　是Serial收集器的多线程版，主要用于Server模式，在进行回收时仍会STW。</p><ol start="3"><li><p><strong>ParallelScavenge收集器</strong></p><p>　　在ParNew的基础上追求更高的吞吐量，这就要使垃圾回收时STW的最大时间尽可能的可控。</p></li></ol><p>　　-XX：MaxGCPauseMillis 设置最大垃圾收集停顿时间，设置太小反而会频繁GC；</p><p>　　-XX：GCTimeRatio 设置GC时间比率，取0-99，即GC占总运行时间的倒数 ；</p><p>　　-XX：+UseAdaptiveSizePolicy 自适应调节，运行期间收集数据动态去调整各个参数；</p><h4 id="3-2-老年代收集器"><a href="#3-2-老年代收集器" class="headerlink" title="3.2 老年代收集器"></a>3.2 老年代收集器</h4><ol><li><strong>SerialOld收集器</strong></li></ol><p>　　Serial收集器的老年代版，单线程，主要用于Client端，可以配合Serial、ParNew工作。</p><ol start="2"><li><strong>ParallelOld收集器</strong></li></ol><p>　　ParallelScavenge的老年代版，多线程，在其出现之前，ParallelScavenge只能和SerialOld配合工作，拖慢了整个服务器端GC的速度。</p><ol start="3"><li><strong>CMS收集器</strong></li></ol><p>　　上面的收集器新生代均基于复制算法，老年代基于整理算法，因此回收时都会STW（枚举根节点、复制、整理不可避免STW）。CMS（Concurrent Mark Sweep）收集器追求最短的STW时间，所以采用的是<strong>标记-清除</strong>算法。</p><ul><li><p>运作机制分为下面四个步骤：</p><ol><li>初始标记：速度很快，只标记根节点能直接关联到的对象，枚举根节点会STW；</li><li>并发标记：遍历整个引用链进行标记，速度较慢；</li><li>重新标记：重新标记第2步执行过程中用户线程运作导致的变化，会STW；</li><li>并发清除：清除；</li></ol></li><li><p>缺点：不必说的就是产生大量零头，可能会提前引发FullGC；无法处理“浮动垃圾”（即并发期间产生的新垃圾），只能下一次处理；并发虽然不会STW，但是占用了一部分线程，降低了吞吐量。</p></li></ul><h4 id="3-3-整堆收集器"><a href="#3-3-整堆收集器" class="headerlink" title="3.3 整堆收集器"></a>3.3 整堆收集器</h4><p>　　<strong>GarbageFirst</strong>（G1收集器）主要使用在Server端，它基于将内存划分为很多区域（Region）的思想，实现了<strong>局部回收</strong>的功能。可以通过-XX：MaxGCPauseMillis参数设置一个GC停顿时间的<strong>期望值</strong>，一定程度上达到停顿时间可控。</p><p>　　G1收集器打破了传统的分代回收思想，它将堆划分为多个大小相等的Region，在进行回收时不再判断对象属于哪一代，而是判断哪块Region垃圾最多，回收价值最高，优先去回收这些区域，这也是为什么叫G1收集器。当然G1也没有抛弃分代思想，因为分代很大程度上提升了GC的效率。每一块Region都有其“年龄”，这样GC就可以对这块Region该不该回收根据其年龄进行权衡。</p><ul><li><p>步骤：</p><ol><li><p>初始标记：枚举根节点，会STW；</p></li><li><p>并发标记：可以与用户线程并发；</p></li><li><p>最终标记：会STW；</p><p>前三步与CMS类似；</p></li><li><p>筛选回收：根据回收效益对每个Region的进行优先级排序，再根据用户设置的停顿期望值指定回收计划，将要回收的Region中的存活对象<strong>复制</strong>到另一块空Region上，再清除掉旧Region。当然因为复制移动了对象所以会STW；</p></li></ol></li><li><p><strong>存在的问题</strong>：首先可以看到的是清理不干净，但是这换来了其他地方的提升，只要回收的速度快于分配的速度，那就不会出问题；跨代跨区引用使得G1得在内存中维护大量的表……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时内存结构</title>
      <link href="JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
      <url>JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>运行时内存结构及常见的OOM异常…</p></blockquote><a id="more"></a><h3 id="1-运行时内存结构"><a href="#1-运行时内存结构" class="headerlink" title="1. 运行时内存结构"></a>1. 运行时内存结构</h3><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/fpI4PaPeoDLx.png" alt="mark" style="zoom:50%;" /><ol><li>程序计数器（PC）：指向下一条<strong>字节码指令</strong>的地址，线程私有，如果正在执行Native方法，则 PC 值为空；<br/></li></ol><ol start="2"><li>虚拟机栈：存放描述方法调用的数据结构<strong>栈帧</strong>，包含局部变量表、操作数栈、动态链接、返回地址等信息，一个方法的执行与结束对应着栈帧出入虚拟机栈；<br/></li><li>本地方法栈：作用类似于虚拟机栈，为本地方法服务；HotSpot VM将二者合二为一了；<br/></li></ol><blockquote><p>上面仨都是随着线程的创建而创建；<br/></p></blockquote><ol start="4"><li><p>堆：随着虚拟机的启动而创建，是虚拟机管理的最大的一块内存，也是GC主要回收的内存区域，所有线程共享；目的就是存放对象实例，但不是所有的对象都存在堆中；</p><ul><li>逃逸分析，一种 JIT 优化技术，可以允许直接在栈上分配对象，减少堆的压力；<br/></li></ul></li><li><p>方法区：用于存储已被虚拟机加载的类信息、常量池、静态变量、JIT编译后的代码缓存等数据；</p><ul><li>以前也称为“永久代”，是因为HotSpot将GC扩展到方法区，目的是为了让GC覆盖到方法区的回收；</li><li>JDK 7 中将常量池和静态变量移出到堆中；</li><li>JDK 8 中将剩余内容(类结构信息)移出到<strong>元空间</strong>中；</li></ul></li></ol><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/xygINplYKcFU.png" alt="mark" style="zoom: 67%;" /><br/><ul><li>运行时常量池：包含了编译期间各种<strong>字面量</strong>和<strong>符号引用</strong>；<ul><li>字面量：文本字符串，常量值等；</li><li>符号引用：包含类和接口的全限定类名，属性和方法的名称及描述符；</li></ul></li></ul><hr><h3 id="2-还原OOM异常"><a href="#2-还原OOM异常" class="headerlink" title="2. 还原OOM异常"></a>2. 还原OOM异常</h3><p>　　除了PC以外的上述所有区域都会抛出OutOfMemoryError，其中栈比较特殊，当线程申请栈空间失败时抛出OOM，当线程请求的栈深度大于虚拟机所允许的最大深度时抛出StackOverflowError；</p><blockquote><p>测试环境 JDK1.8</p></blockquote><ul><li>栈溢出<ul><li>思路：要么撑大局部变量表，要么撑大栈深度；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        VMSOF oom = <span class="keyword">new</span> VMSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/QYIRTj94zyGe.png" alt="mark"></p><br/><ul><li>常量池溢出<ul><li>思路：JDK7之后 常量池移到了堆中，所以要对堆大小进行设置；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx2m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/NisOBtISSPoY.png" alt="mark"></p><br/><ul><li>元空间溢出<ul><li>思路：元空间里主要存放类信息，可以不断创建Class对象；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *-XX:MetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *-XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaSpaceOOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><ul><li>堆溢出<ul><li>思路：一直new对象且保持其引用；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *-Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/2Vba35K8EFK1.png" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记</title>
      <link href="Others/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>Others/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h2><blockquote><p>　　2002年Linus选择了一个商业的版本控制系统BitKeeper来管理Linux系统，秉持着开源精神BitKeeper授权Linux社区免费使用这个版本控制系统。而2005年Linux社区的一些人企图破解BitKeep的协议，被发现后Linux社区失去了BitKeeper的免费使用权。正是因此，Linus Torvalds于2005年用__C语言__开发了Git这一款__分布式的__版本控制系统。</p></blockquote><a id="more"></a><h3 id="集中式与分布式"><a href="#集中式与分布式" class="headerlink" title="集中式与分布式"></a>集中式与分布式</h3><ul><li><em>集中式版本控制系统</em> :版本库存放在中央服务器上,当我们准备工作的时候,首先需要从中央服务器获取最新的版本,工作完成后再进行上传.而且这个方式最大的弊端在于必须要联网才能工作.</li><li><em>分布式版本控制系统</em> : 每个人的电脑都是一个完整的版本库,所以工作的时候不需要联网.理论上可以没有中央服务器,而为了多人协作方便,我们同常会使用一台中央服务器作为我们每台电脑交换信息的媒介.</li></ul><h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><ul><li>安装过程略</li><li>安装完成后,需要设置用户名和邮箱</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@email.com&quot;</span> </span><br></pre></td></tr></table></figure><blockquote><p>–global表示全局设定</p></blockquote><h3 id="创建版本库repository"><a href="#创建版本库repository" class="headerlink" title="创建版本库repository"></a>创建版本库repository</h3><ul><li>通过<code>git init</code>命令 将某一目录初始化为Git可以管理的仓库.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/GitTest/.git/</span><br></pre></td></tr></table></figure><ul><li>初始化后会多出来一个名为<code>.Git</code>的隐藏目录,其中存放的是Git管理版本库的信息,小心不要删除了.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ah</span><br><span class="line">./  ../  .git/</span><br></pre></td></tr></table></figure><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><h3 id="1-add与commit"><a href="#1-add与commit" class="headerlink" title="1.add与commit"></a>1.add与commit</h3><blockquote><p>目录中添加了一个readme.txt文件…<br>内容为 I’m studying Git…</p></blockquote><ul><li><code>git add readme.txt</code>将readme.txt添加到暂存区 </li><li><code>git commit -m &quot;a new readme file&quot;</code>将文件提交到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m<span class="string">&quot;a new readme file&quot;</span></span><br><span class="line">[master (root-commit) 1d9a89f] a new readme file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><pre><code>- `-m`控制参数后面是本次提交的说明,建议每次提交都填上正确合理的说明,方便以后的查找.- 为什么是两步呢?因为我们可以add多个文件到暂存区然后一次性commit.</code></pre><blockquote><p>改动了一下readme.txt的内容…<br>增加 Git is easy to use…</p></blockquote><ul><li><code>git status</code>命令可以查看当前仓库的状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>git diff readme.txt</code> 可以查看工作区改动了哪些内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index ba4782a..f2d0b06 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line">-I<span class="string">&#x27;m studying Git...</span></span><br><span class="line"><span class="string">\ No newline at end of file</span></span><br><span class="line"><span class="string">+I&#x27;</span>m studying Git...</span><br><span class="line">+Git is easy to use...</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><blockquote><p>再次提交修改过的文件 <code>$ git commit -m&quot;add git is easy&quot;</code></p></blockquote><h4 id="工作区与版本库"><a href="#工作区与版本库" class="headerlink" title="工作区与版本库"></a>工作区与版本库</h4><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/8YPxYOM6lAE0.png" alt="mark"></p><ul><li>工作区add后到版本库中的暂存区,commit操作将暂存区的内容提交到HEAD指向的某分支上.</li></ul><h3 id="2-版本回退"><a href="#2-版本回退" class="headerlink" title="2.版本回退"></a>2.版本回退</h3><ul><li><code>git log</code> 显示从最近到最远的提交日志<ul><li>添加参数<code>--pretty=oneline</code>可以过滤Author和Date信息,只显示___commitId___和说明</li><li>HEAD指针指向当前版本</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">4d806ebe133fdb37fc7f047c24d276fd47f9d604 (HEAD -&gt; master) add git is easy</span><br><span class="line">1d9a89f3eb4cc4aa4b75b3d5e3be5ce212a998eb a new readme file</span><br></pre></td></tr></table></figure><ul><li><code>git reset --hard HEAD^</code>回退到上一个版本<ul><li>加几个<code>^</code>就是回退几个版本 </li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 1d9a89f a new readme file</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1d9a89f3eb4cc4aa4b75b3d5e3be5ce212a998eb (HEAD -&gt; master)</span><br><span class="line">Author: khy_99 &lt;khy_99@163.com&gt;</span><br><span class="line">Date:   Wed Nov 27 16:42:49 2019 +0800</span><br><span class="line"></span><br><span class="line">    a new readme file</span><br></pre></td></tr></table></figure><ul><li><strong><em>问题</em></strong> : 再使用log发现找不到修改后的提交信息了?<ul><li>解决:如果你的黑窗口还没有关闭,找到第二次提交的版本号 <code>$ git reset --hard 版本ID</code> 注意ID不需要全部输入.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 4d80</span><br><span class="line">HEAD is now at 4d806eb add git is easy</span><br></pre></td></tr></table></figure><pre><code>- 黑窗口关了怎么办? `git reflog` 用来显示你的历史操作,从而找到需要的版本ID</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">4d806eb (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4d80</span><br><span class="line">1d9a89f HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">4d806eb (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to HEAD</span><br><span class="line">4d806eb (HEAD -&gt; master) HEAD@&#123;3&#125;: commit: add git is easy</span><br><span class="line">1d9a89f HEAD@&#123;4&#125;: commit (initial): a new readme file</span><br></pre></td></tr></table></figure><h3 id="3-撤销与删除"><a href="#3-撤销与删除" class="headerlink" title="3.撤销与删除"></a>3.撤销与删除</h3><ul><li><p><code>git checkout -- readme.txt</code> 撤销__工作区__的修改</p><ul><li>若文件已经add到暂存区后又做了修改,则只会回退到add后的状态,就是把工作区版本还原成为暂存区版本.</li><li>切换分支的命令是<code>git checkout</code>,注意<code>--</code>符号.</li></ul></li><li><p><code>git reset HEAD readme.txt</code> 撤销__暂存区__的修改</p><ul><li>暂存区的修改撤销到了工作区</li></ul></li><li><p><code>rm readme.txt</code> 删除工作区文件.</p><ul><li>确认删除需要add与commit.</li><li><code>git checkout -- readme.txt</code>误删了,从版本库里恢复过来. </li></ul></li><li><p><code>git rm readme.txt</code>删除文件同时add到了暂存区.</p><ul><li><code>git commit</code>确定要删除就commit.</li><li>恢复需要两步:<ul><li><code>git reset HEAD readme.txt</code> 从分支恢复到暂存区.</li><li><code>git checkout -- readme.txt</code>再从暂存区恢复到工作区.</li></ul></li></ul></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><blockquote><p>使用GitHub或Gitee充当远程仓库,托管我们的代码,方便多人协作.</p></blockquote><h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1.创建远程仓库"></a>1.创建远程仓库</h3><ul><li><p>首先需要创建SSH密钥对<br><code>rsa ssh-keygen -t -C &quot;email@example.com&quot;</code> + 仨回车.<br>会生成私钥<code>id_rsa</code>与公钥<code>id_rsa.pub</code>存放在当前用户下的<code>.ssh</code>目录中.</p></li><li><p>在GitHub上添加自己的公钥<code>id_rsq.pub</code>.</p></li><li><p>在GitHub上创建一个新的仓库.</p></li><li><p>将本地仓库与之关联</p><ul><li><code>git remote add origin git@github.com:HenryKang99/GitLearning.git</code><br>-上面<code>git@...</code>一串是远程仓库ssh地址,当然也可以使用HTTPS的方式,坏处就是速度慢而且每次都要输入密码.</li></ul></li></ul><h3 id="2-推送与克隆"><a href="#2-推送与克隆" class="headerlink" title="2.推送与克隆"></a>2.推送与克隆</h3><ul><li><code>git push -u origin master</code>推送本地内容到远程仓库.<ul><li><code>-u</code>参数将本地的master与远程的master建立的关联,以后的push或pull就可以简化命令.</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">The authenticity of host <span class="string">&#x27;github.com (52.74.223.119)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes  &lt;-- 第一次推送的时候这里要确认一下</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>github.com,52.74.223.119<span class="string">&#x27; (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Enumerating objects: 6, done.</span></span><br><span class="line"><span class="string">Counting objects: 100% (6/6), done.</span></span><br><span class="line"><span class="string">Delta compression using up to 4 threads</span></span><br><span class="line"><span class="string">Compressing objects: 100% (2/2), done.</span></span><br><span class="line"><span class="string">Writing objects: 100% (6/6), 474 bytes | 118.00 KiB/s, done.</span></span><br><span class="line"><span class="string">Total 6 (delta 0), reused 0 (delta 0)</span></span><br><span class="line"><span class="string">To github.com:HenryKang99/GitLearning.git</span></span><br><span class="line"><span class="string"> * [new branch]      master -&gt; master</span></span><br><span class="line"><span class="string">Branch &#x27;</span>master<span class="string">&#x27; set up to track remote branch &#x27;</span>master<span class="string">&#x27; from &#x27;</span>origin<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure><ul><li><code>git clone git@github.com:HenryKang99/GitLearning.git</code>从远程仓库clone到本地.</li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><blockquote><p>前面一直使用的都是名叫<code>master</code>的主分支</p></blockquote><h3 id="1-分支的创建-合并与删除"><a href="#1-分支的创建-合并与删除" class="headerlink" title="1.分支的创建,合并与删除"></a>1.分支的创建,合并与删除</h3><ul><li><p><code>git checkout -b dev</code>创建并切换分支,相当于</p><ul><li><code>git branch dev</code> 和 <code>git checkout dev</code></li></ul></li><li><p>也可以使用<code>git switch -c dev</code>创建并切换分支.</p></li><li><p><code>git switch master</code> 切换到已有分支.</p></li><li><p><code>git branch</code>列出所有分支,当前分支前面会带有一个<code>*</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><blockquote><p>在dev分支上commit一个devtest.txt文件,再切换回master分支,会发现刚才的文件不见了.</p></blockquote><ul><li><code>git merge dev</code> 将dev分支合并到master上.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$  git merge dev</span><br><span class="line">Updating 4d806eb..3242396</span><br><span class="line">Fast-forward</span><br><span class="line"> devtest.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 devtest.txt</span><br><span class="line"> </span><br><span class="line"> $ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">32423966aa6d6dc0135a48a993d865a668766b43 (HEAD -&gt; master, dev) add a new devtest file</span><br><span class="line">4d806ebe133fdb37fc7f047c24d276fd47f9d604 (origin/master) add git is easy</span><br><span class="line">1d9a89f3eb4cc4aa4b75b3d5e3be5ce212a998eb a new readme file</span><br></pre></td></tr></table></figure><ul><li><p><b>注意</b> : 这里其实合并的时候没有发生冲突,默认使用的是Git中的<code>快速合并</code>模式,相当于直接把<code>HEAD</code>指针指向了合并分支的最新一次commit;</p><ul><li>这样的优点是速度快,缺点是当我们使用<code>git log</code>时我们看不到这一次合并情况.</li><li>想要看到分支合并情况,我们需要在合并的时候使用参数<code>git merge --no-ff</code>,表示禁用<code>快速合并</code>模式.</li></ul></li><li><p><code>git branch -d dev</code> 删除dev分支</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 3242396).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2.解决冲突"></a>2.解决冲突</h3><blockquote><p>在dev分支中修改devtest.txt文件,增加内容”test conflict…”,add&commit;<br>切换到master分支,新增内容Test conflict…”,add&commit;</p></blockquote><ol><li>合并分支dev到master 发现冲突</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Auto-merging devtest.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> devtest.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><ol start="2"><li>打开冲突文件,解决冲突</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This is a devtest file...</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">Test conflict...</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">test conflict</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test conflict</span></span><br></pre></td></tr></table></figure><ol start="3"><li>再次add&commit;使用’git log –graph’ , <code>git log --graph --pretty=oneline --abbrev-commit</code> 查看合并情况,最后删除dev分支<code>git branch -d dev</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   b4fa617 (HEAD -&gt; master) fix conflict</span><br><span class="line">|\</span><br><span class="line">| * 491516a (dev) <span class="built_in">test</span> conflict</span><br><span class="line">* | 3609db5 Test conflict</span><br><span class="line">|/</span><br><span class="line">* 3242396 add a new devtest file</span><br><span class="line">* 4d806eb (origin/master) add git is easy</span><br><span class="line">* 1d9a89f a new readme file</span><br></pre></td></tr></table></figure><h3 id="3-使用git-stash-隐藏工作区工作"><a href="#3-使用git-stash-隐藏工作区工作" class="headerlink" title="3.使用git stash 隐藏工作区工作"></a>3.使用<code>git stash</code> 隐藏工作区工作</h3><blockquote><p>stash 隐藏,贮藏.<br>issue 重要议题,争论的问题.<br>背景 : 当我们在dev分支工作到一半的时候需要紧急去修改master分支上的一个issue…</p></blockquote><ol><li>使用<code>git stash</code>存储现在在dev上的工作;<ul><li>可以使用 <code>git status</code>查看工作区,发现是干净的.</li></ul></li><li><code>git switch -c issue01</code>创建并切换到issue01分支进行工作,完成后add&amp;commit&amp;merge&amp;删除issue01分支.</li><li>回到dev分支,恢复之前的工作:<ul><li><code>git stash list</code> 查看之前隐藏的工作区</li><li><code>git stash apply</code> 和 <code>git stash drop</code>来恢复和删除stash</li><li><code>git stash pop</code>恢复的同时自动删除stash </li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   devtest.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (e936304bc07d6ed71bd6a0f421a432abfffa7fec)</span><br></pre></td></tr></table></figure><blockquote><p>若dev上也有和master同样的issue需要解决,可以直接把issue01提交到master的commit复制到dev上.</p></blockquote><ol start="4"><li><code>cherry-pick commitID</code>复制某一个commit到当前分支.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 7bbada6</span><br><span class="line">[dev 2eb3829] issue fixed...</span><br><span class="line"> Date: Thu Nov 28 21:27:09 2019 +0800</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ul><li><code>git tag v1.0</code> 给当前分支上最新的commit打上标签</li><li><code>git tag v2.0 commitID</code> 给某一个commit打上标签</li><li><code>git tag -d v1.0</code> 删除标签</li><li><code>git tag</code> 查看所有标签</li><li><code>git show v1.0</code> 查看标签的详细信息</li></ul><h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><ul><li><code>git push origin v1.0</code> 将某个标签推到远程</li><li><code>git push origin --tags</code> 将所有未push的标签推到远程</li><li>删除远端标签分为两步<ol><li><code>git tag -d v1.0</code> 先删除本地标签</li><li><code>git push origin :refs/tags/v1.0</code>删除远程的标签</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="JavaSE/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>JavaSE/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><blockquote><p>正则表达式常用语法规则；常用正则表达式 ……</p></blockquote><a id="more"></a><h3 id="1-正则表达式语法"><a href="#1-正则表达式语法" class="headerlink" title="1. 正则表达式语法"></a>1. 正则表达式语法</h3><ol><li><strong>普通字符：</strong>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，在匹配一个字符串的时候，匹配与之相同的一个字符。</li><li><strong>转义字符：</strong>如果要匹配有特殊含义的标点符号，就要使用转义字符。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/CLt553HfEE2W.png" alt="mark"></p><ol start="3"><li><strong>标准字符集合：</strong>是一种能够匹配多种字符的表达式。区分大小写，大写是取反的意思。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Y5iOiygzm0Xn.png" alt="mark"></p><ol start="4"><li><strong>自定义字符集合：</strong>使用方<code>[]</code>来定义想要匹配的集合。要注意的是，在中括号之内的特殊符号除了<code>^</code> 和 <code>-</code>之外都失去其特殊意义。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/Nb7AUXjtEB8d.png" alt="mark"></p><ol start="5"><li><strong>量词：</strong>定义匹配次数，有贪婪模式（默认）和非贪婪模式之分。前者是匹配字符越多越好；后者匹配字符越少越好，在修饰匹配次数的特殊符号后面加上<code>?</code>来表明使用非贪婪模式。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/FcDiLttwVn4C.png" alt="mark"></p><ol start="6"><li><strong>字符边界：</strong>定义边界字符的匹配规则。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/66OG2fsqVlpB.png" alt="mark"></p><ol start="7"><li><strong>匹配模式：</strong><ul><li><strong>IGNORECASE 忽略大小写模式</strong>：匹配时忽略大小写，默认情况下，正则表达式区分大小写；</li><li><strong>SINGLELINE 单行模式</strong>：整个文本看作一个字符串，只有一个开头，一个结尾；</li><li><strong>MULTILINE 多行模式</strong>：每行都是一个字符串，都有开头和结尾。</li></ul></li></ol><p>　</p><hr><h3 id="2-常用正则表达式"><a href="#2-常用正则表达式" class="headerlink" title="2. 常用正则表达式"></a>2. 常用正则表达式</h3><ul><li>因为使用markdown写的，所以下面用的时候最好别直接复制，因为多了一些md的转移字符！</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>匹配中文字符</td><td>[\u4e00-\u9fa5]</td></tr><tr><td>匹配空白行</td><td>\n\s*\r</td></tr><tr><td>匹配HTML标记</td><td>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;</td></tr><tr><td>匹配首尾空白字符</td><td>^\s*</td></tr><tr><td>匹配Email地址</td><td>\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em></td></tr><tr><td>匹配网址URL</td><td>[a-zA-z]+://[^\s]*</td></tr><tr><td>匹配国内电话号码</td><td>\d{3}-\d{8}</td></tr><tr><td>匹配腾讯QQ号</td><td>[1-9][0-9]{4,}</td></tr><tr><td>匹配中国邮政编码</td><td>[1-9]\d{5}(?!\d)</td></tr><tr><td>匹配身份证</td><td>\d{15}</td></tr><tr><td>匹配ip地址</td><td>\d+.\d+.\d+.\d+</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE知识回顾</title>
      <link href="JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html"/>
      <url>JavaSE/JavaSE%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html</url>
      
        <content type="html"><![CDATA[<h3 id="0verview"><a href="#0verview" class="headerlink" title="0verview"></a>0verview</h3><a id="more"></a><h3 id="1-数据类型-amp-运算符"><a href="#1-数据类型-amp-运算符" class="headerlink" title="1. 数据类型 &amp; 运算符"></a>1. 数据类型 &amp; 运算符</h3><ul><li><p><strong>数据类型</strong></p><table><thead><tr><th>类型</th><th align="center">长度/字节</th><th align="left">备注</th><th>对应包装类</th></tr></thead><tbody><tr><td>byte</td><td align="center">1</td><td align="left">-128~127</td><td>Byte</td></tr><tr><td>short</td><td align="center">2</td><td align="left">2^15=32768</td><td>Short</td></tr><tr><td>int</td><td align="center">4</td><td align="left">2^31=2147483648</td><td>Integer</td></tr><tr><td>long</td><td align="center">8</td><td align="left">2^63</td><td>Long</td></tr><tr><td>float（F）</td><td align="center">4</td><td align="left">7~8有效位</td><td>Float</td></tr><tr><td>double</td><td align="center">8</td><td align="left">16有效位</td><td>Double</td></tr><tr><td>char</td><td align="center">2</td><td align="left">Unicode编码</td><td>Character</td></tr><tr><td>boolean</td><td align="center">1</td><td align="left">只有true和false两种表示形式</td><td>Boolean</td></tr><tr><td>String</td><td align="center">*</td><td align="left">不可变类</td><td>*</td></tr><tr><td>数组</td><td align="center">*</td><td align="left">特殊的Object</td><td>*</td></tr></tbody></table><br/></li><li><p><strong>注意：</strong></p><ul><li><p>Java没有无符号形式；</p></li><li><p>byte 能表示 -128~127 是因为补码表示有两种零（0/1,000 0000），所以用负零1,000 0000表示-128，还有就是因为 -127=（1,000 0001）再减1就变成了-128=（1,000 0000）；</p></li><li><p>局部变量使用前必须要初始化，成员变量在类加载准备阶段赋“0”值，初始化阶段赋初值；</p></li><li><p>boolean默认为false，string默认为空串“ ”；</p></li><li><p>Java整形默认为int，浮点型默认为double，float需要加后缀F；</p></li><li><p>byte 和 short 做运算为了不溢出都会转成 int；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//b1 = b1 + b2; 报错</span></span><br><span class="line">b1 = (<span class="keyword">byte</span>) (b1 + b2); <span class="comment">// √ 溢出会截掉高位</span></span><br></pre></td></tr></table></figure></li><li><p>字面量可以使用下划线分割，编译器会去除他们：1_000_000;</p></li><li><p>char 赋值时字面量要用单引号括起来 <code>char c1 = &#39;A&#39; </code>，JVM使用UTF-16编码，赋编码值不用单引号<code>char c2 = 65</code>；</p></li></ul></li><li><p><strong>Unicode VS UTF-8</strong>：</p><ul><li><p>Unicode 是<strong>字符集</strong>，为每一个字符分配一个二进制ID（称为<strong>码点</strong>、码位、CodePoint），虽然定义了码点，但是没有规定如何存储与读取。例如UCS-4标准使用4个字节为全世界的字符分配了ID，但是我们知道英文的ID都是靠前的（想想ASCII编码，一字节就够了），如果都用Unicode作为编码表示，那英文前面一串0，浪费了太多空间，所有才有了一系列的编码规则。</p><ul><li>UCS-2 标准就分配够了常用汉字的ID，因此Unicode 2 字节就够表示汉字。也因为这样，使用了UTF-16编码的 JVM 中 char 能表示汉字。从4E00(100 1110 0000 0000) 到 9FA5(1001 1111 1010 0101)，共20902个。<a href="http://www.chi2ko.com/tool/CJK.htm">在这里查</a></li><li>JVM 内部使用的是UTF-16编码，所有字符都是俩字节，一般我们说JVM使用Unicode编码其实是不严谨的；</li></ul></li><li><p>UTF-8 是 <strong>编码规则</strong>，定义了<strong>将码点转换为字节序列</strong>的规则，是Unicode的一种实现方式；具体实现如下：</p><ul><li><p>对于单字节的符号，字节的第一位设为 0，后面7位为这个符号的 Unicode 码；</p></li><li><p>对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1（这样做计算机读到几个1就知道了要往后读几个字节），第 n + 1 位设为 0，后面字节的前两位一律设为10，空余的二进制位从后往前依次填充这个符号的 Unicode 码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">  (十六进制)         |         （二进制）</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></li><li><p>现在知道为什么UTF-8汉字占三字节，因为上面说到汉字Unicode从4E00-9FA6，要15-16位，而UTF-8 的第二行只有11个空位，不够，所以用第三行，即占三个字节；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;字&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>).length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">&quot;字&quot;</span>.getBytes(<span class="string">&quot;utf-16&quot;</span>).length);<span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="string">&quot;汉字&quot;</span>.getBytes(<span class="string">&quot;utf-16&quot;</span>).length);<span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 为什么是4和6，因为前面有个FE或FF表示大小端</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0b0100_1110_0000_0000</span>; <span class="comment">// 4E00 表示 ‘一’</span></span><br><span class="line">System.out.println(c);<span class="comment">// 一</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>　　</p><ul><li><p><strong>类型转换</strong></p><ul><li><p>自动转换：char&gt;int&gt;<strong>long&gt;float</strong>&gt;double</p></li><li><p>强转字节不够的时候会直接截断高位，产生错误结果，例如 (byte) (0x1_0000_0000) = 0;</p></li><li><p>任何类型和String做运算都会自动转型成String；</p></li><li><p>装箱、拆箱、字符串转化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer aa;</span><br><span class="line">String str；</span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line">aa = Integer.valueOf(a);</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line">aa.intValue(); <span class="comment">// 其实就相当于get方法，get Value属性；</span></span><br><span class="line"><span class="comment">//Object-&gt;字符串</span></span><br><span class="line">str = String.ValueOf(a);</span><br><span class="line">str = a + <span class="string">&quot;&quot;</span>;<span class="comment">// 这个最方便</span></span><br><span class="line"><span class="comment">//字符串-&gt;基本型</span></span><br><span class="line">a = Integer.parseInt(str);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>包装类</strong></p><ul><li>整形和浮点型都继承了抽象类 Number；</li><li>包装类有一个属性value放基本型，而且一旦包装就不能再改变；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java 中四种整形包装类都用数组缓存了-128~127，因此在用==比较这个范围的包装类时返回true；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Byte中的一个内部类 ，其他整形同理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Byte 的valueOf方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Integer 中的 valueOf方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是new Integer(int x)的话，== 返回false</span></span><br></pre></td></tr></table></figure><ul><li>Boolean 中参数为String的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((s != <span class="keyword">null</span>) &amp;&amp; s.equalsIgnoreCase(<span class="string">&quot;true&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new Boolean(&quot;tRuE&quot;); 传参只要是忽略大小写的true就是true，其他false；</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>String</strong></p><ul><li><p>本质是一个final char[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类中属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></li><li><p><code>intern()</code> 方法:</p><ul><li>JDK 1.7 之前，常量池位于方法区，intern方法会将首次遇到的字符串<strong>实例复制</strong>到常量池中，再返回其引用；</li><li>JDK 1.8 之后，常量池搬移到堆中，intern方法会将首次遇到的字符串实例的<strong>引用添加</strong>到常量池中，再返回其引用；</li><li>下面代码环境均为jdk1.8：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">// 首次遇到“abc”，加入到常量池</span></span><br><span class="line">String str2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">// 编译时优化，就是“abc”</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;<span class="comment">// 新开辟一个空间 存“abc”，即和上面俩没关系</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//false </span></span><br><span class="line">System.out.println(str1 == str3.intern());<span class="comment">//true 常量池中有“abc”的引用</span></span><br><span class="line">System.out.println(str3 == str3.intern());<span class="comment">//false intern返回的是str1的引用（因为“abc”首次出现是str1），和str3指向的堆内存的“abc”不是同一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线，和上面代码无关----------------</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(str1.intern() == str1); <span class="comment">// true 常量池中的“abc”就是引用自new 的“abc”，因为首次出现</span></span><br></pre></td></tr></table></figure></li><li><p>new String 不会将字符串的引用放入常量池中（误）：</p><ul><li>new String(“abc”)中的参数abc字符串在类加载的时候也会存入常量池，但是new的时候是复制了一份放在堆中，并返回引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false,说明new String没往常量池中添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线---</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>) + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">str1.intern();<span class="comment">//调用intern()才会添加</span></span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 侧面说明直接创建字符串会添加到常量池，所以不推荐使用new创建String；编译时就将已知的str（双引号创建的str）加入到了该类静态常量池，类加载时进入运行时常量池。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组</strong></p><ul><li><p>数组是一个特殊的对象，也继承自Object，它也封装了属性和一些方法，那它到底是什么类型呢？</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/hV6qqssz9bH0.png" alt="mark"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过getClass.getName看看它是什么类型</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">Integer[] arr2 = <span class="keyword">new</span> Integer[<span class="number">0</span>];</span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">String[][] arr4 = <span class="keyword">new</span> String[<span class="number">0</span>][];</span><br><span class="line"></span><br><span class="line">System.out.println(arr1.getClass().getName());</span><br><span class="line">System.out.println(arr2.getClass().getName());</span><br><span class="line">System.out.println(arr3.getClass().getName());</span><br><span class="line">System.out.println(arr4.getClass().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下:</span></span><br><span class="line"><span class="comment">//  [I</span></span><br><span class="line"><span class="comment">//  [Ljava.lang.Integer</span></span><br><span class="line"><span class="comment">//  [Ljava.lang.String</span></span><br><span class="line"><span class="comment">//  [[Ljava.lang.String</span></span><br><span class="line"><span class="comment">// 使用IDE也搜不到这几个类，可以理解为数组类是JVM内部维护的类。</span></span><br></pre></td></tr></table></figure><ul><li>简单理解就是：数组是一个数据结构，体现在内存上就是一块连续的内存分成若干小块，每个小块可以存储相同类型数据，而JVM帮我们把它封装成了一个特殊的对象，可以通过<code>[ ]</code>访问它的属性，还可以调用它的方法。</li></ul></li></ul></li><li><p>一维数组声明时必须指定长度，初始化值为0；</p></li><li><p>二维数组声明必须指定行数，初始化值为0；实质是数组的数组，所以每一行可以有不同数的列；</p></li><li><p>Java允许数组长度可以为零；</p></li><li><p>String 数组元素默认初始化为 null 而不是空串“ ”；</p></li><li><p>Arrays.toString(Object []) 返回一个包含数组所有元素的字符串[1,2,3,…]；</p></li><li><p>数组拷贝使用 Arrays.copyOf(s,s.length());</p></li></ul><ul><li><p>运算符</p><ul><li><p>两个操作数都是整数时，是整数运算；否则都会扩展精度；</p></li><li><p>整数/0 = 算数异常；</p></li><li><p>浮点数/0 = infinity 无穷大；</p></li><li><p>逻辑运算符：&amp;&amp;  ||  !  ==  !=   </p></li><li><p>位运算：&amp;  |  ~  ^(异或)  &lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</p><ul><li>&gt;&gt; 算术移位，高位填符号位；</li><li>&gt;&gt;&gt; 逻辑移位，高位填0；</li><li>不存在 <code>&lt;&lt;&lt;</code> 因为 原码补码左移低位都填0，其实算数移位和逻辑移位也就只是针对补码(而且是表示负数的补码)的右移来说的；</li></ul></li><li><p><strong>&amp; 和 &amp;&amp; 的区别</strong></p><ul><li>都是可以当做逻辑运算符，要求两个操作数都是boolean型；而且&amp;&amp; 具有短路功能，即第一个条件为false，第二个不用判断。</li><li>&amp; 还可以作为位运算符，要求操作数不是boolean，有啥用呢，比如我们可以使用下面的操作来取一个整形的低几位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%x&quot;</span>, <span class="number">0xff</span> &amp; <span class="number">128</span>);<span class="comment">// 7f ，即低八位</span></span><br></pre></td></tr></table></figure><ul><li>判断奇偶：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a &amp; <span class="number">0b1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>优先级与结合性：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/z1f5ElyVm8DI.png" alt="mark"></p></li></ul><hr><h3 id="2-对象-amp-类"><a href="#2-对象-amp-类" class="headerlink" title="2. 对象 &amp; 类"></a>2. 对象 &amp; 类</h3><ul><li>一些概念：<ul><li>现实中万事万物皆是对象，编程世界中对象是具有一定属性和方法的封装体；计算机中对象是一块内存；</li><li>类是对象的模板，是一系列具有相同属性和方法的对象的抽象集合。</li><li>封装：隐藏自己的成员属性和某些方法，只将对外提供的方法暴露出来；</li><li>继承：基于一个已存在的类构造一个新类；</li><li>多态：多种状态；</li></ul></li><li>构造方法：<ul><li>没有返回值，与类同名；伴随着new操作被调用；</li><li>子类初始化一定会调用父类构造方法（抽象类也有构造方法）；</li><li>子类构造方法调用父类构造方法必须写在第一行，没有显式调用会自动调用父类默认构造方法（无参构造方法），若父类无默认构造方法，则编译会报错；</li><li>静态块：static{ }，类加载时候执行；<ul><li>注意：静态变量的赋值语句和静态块同等级，按代码书写顺序执行。</li></ul></li><li>初始化块：{ }，随着对象的创建而执行，<strong>在构造方法之前执行</strong>；</li></ul></li><li>析构方法：<ul><li>会在GC回收对象之前调用，但不保证会执行完成；</li><li>一般不建议使用，因为我们不知道GC回收对象的准确时机，也就不知道析构执行的时机；</li><li>一个对象只会执行一次；</li></ul></li><li>静态属性与静态方法：<ul><li>属于类但不属于对象的属性和方法，随着类的加载而加载；</li><li>静态变量：static属性由所有实例共享，例如可以使用静态变量统计一下这个类new了多少次实例；</li><li>静态常量：使用 static final 修饰，例如定义很多常量值，还有经常使用的 System.out 就是一个PrintStream静态常量；</li><li>静态方法：静态方法不能访问对象的状态，只能访问类中的静态属性；可以由类名.方法名调用，当然也可以使用对象名调用但是容易造成混淆一般不使用；<ul><li>main()方法：程序的入口，每一个类可以有一个main方法，使用java命令执行哪个类就会从哪个类进入，如果一个类中有main方法但是没有从它进入，那这个main永远不会执行。</li></ul></li></ul></li><li>参数传递：<ul><li>基本类型按值传递，引用类型按引用传递。虽然这个说法具有一定广泛性但却是<strong>错误</strong>的；</li><li>实际上引用类型传递的是引用的拷贝，也是值传递，代码验证：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stu x = <span class="keyword">new</span> Stu(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Stu y = <span class="keyword">new</span> Stu(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">swap(x,y);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line">    Stu temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样想要交换两个对象是不行的，交换的是引用的值，对象在内存中并没有发生交换。</span></span><br></pre></td></tr></table></figure><ul><li><p>方法重载：</p><ul><li>一个类中有多个方法具有相同的方法名，不同的参数列表，称为重载；<ul><li><strong>方法签名 = 方法名 + 参数列表</strong>；</li></ul></li><li>关于异常抛出、修饰符、返回值都没有限制；</li></ul></li><li><p>可变参数：</p><ul><li>可变参数等价于数组，可以互相替换，代表同样的参数列表，即不能把二者互相替换达到重载的目的；</li><li>必须放在最后，否则会引起歧义；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span> <span class="params">(<span class="keyword">double</span> ... values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> largest = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> v : values) <span class="keyword">if</span>(v &gt; largest) largest = v;</span><br><span class="line"><span class="keyword">return</span> largest ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包：</p><ul><li>包的作用是确定唯一的类，因此建议包名为公司域名反写，因为域名肯定是唯一的；</li><li>静态导入（不常用）：导入静态方法和静态属性；例如可以使用import static java.lang.System.* ，这样输出的时候可以直接写out.println(); 甚至导入  java.lang.System.out 可以直接写println()， 当然前提是没有冲突。</li><li>可以通过打jar包的方式将包密封起来。</li></ul></li><li><p>访问权限修饰符：</p><ul><li>类：只有public 和 缺省<ul><li>每个 .java 文件只能有一个public的class，且必须和文件名相同；；<ul><li>可以没有public的class</li></ul></li><li><strong>内部类</strong>相当于类的成员，可以使用protected、private修饰，可见性同成员变量一样；</li><li>缺省则只能被同包访问；</li></ul></li><li>方法与属性：</li></ul></li></ul><table><thead><tr><th align="left">作用域与可见性</th><th align="center">public</th><th align="center">protected</th><th align="center">default</th><th align="center">private</th></tr></thead><tbody><tr><td align="left">当前类</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">同包类（包括其它类+子类）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">x</td></tr><tr><td align="left">不同包子类</td><td align="center">√</td><td align="center">√</td><td align="center">x</td><td align="center">x</td></tr><tr><td align="left">其他</td><td align="center">√</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><ul><li><p>关于继承：</p><ul><li>概念：<strong>基于一个已存在的类构造一个新类</strong>；</li><li>类只能单继承，可以多实现；接口无限制但不能循环，接口的实现也具有传递性；</li><li>子类初始化前必须先初始化父类；若父接口中有default方法，或使用了父接口的常量，则必须先初始化父接口，否则不需要初始化父接口；</li><li><strong>子类可以继承父类所有成员方法和属性；</strong><ul><li>对于private也能继承，只不过不能直接访问，需要通过访问器，通过this都不行；</li><li>对于static方法和属性（包括static final属性），继承的是使用权，即（在有访问权限的前提下）可以通过子类的类名或实例名调用父类中的静态方法和属性，不存在重写一说，若企图“重写”则会隐藏父类的静态方法；<ul><li>如果这点不考虑的话，其实可以说成是：子类可以继承父类所有的<strong>成员</strong>变量和方法，静态是属于类的，不属于类的实例；</li></ul></li><li>对于final方法与属性，方法可以继承但是无法重写，父类final属性若在父类构造器或初始化块中赋值，则可以通过子类构造器或初始化块对继承下来的final属性赋值，否则无法修改；</li></ul></li><li>子类无法删除继承下来的任何属性和方法，可以通过声明同名属性来隐藏父类属性；</li></ul></li></ul><ul><li><p>方法重写：</p><ul><li>子类方法和父类方法拥有<strong>相同的方法签名</strong>，且返回值必须<strong>兼容</strong>；<ul><li>这个兼容有个名词叫<strong>协变</strong>，就是子类重写的返回值范围要<u>小于等于</u>父类的返回值范围。</li></ul></li><li>修饰符：<ul><li>子类访问修饰符必须大于等于父类访问修饰符。</li><li>final 和 static 都不能重写，但是子类按照相同的方法签名“重写”不会报错，这时因为编译器将这个“重写”的方法当做子类自己的方法；通过声明父类创建子类，再调用该方法即可证明，发现调用的始终是父类的方法，即没有发生多态，也就没有发生重写。</li></ul></li><li>异常：不能抛出比父类范围大的异常；</li></ul></li></ul><ul><li><p>多态：</p><ul><li><p>可以<strong>声明父类创建子类</strong>，即父类引用可以指向子类对象，反之不能；</p><ul><li>父类能出现的地方都可以使用子类置换；</li></ul></li><li><p>声明父类就只能调用父类拥有的方法；</p><ul><li>即不能调用子类独有的方法，只能调用父类拥有的方法，但是会调用子类重写的方法；</li><li>这时候想要调用子类独有方法就得<strong>强转</strong>为子类；</li></ul></li><li><p>避免多态的例子：</p><ul><li>子类数组的引用可以直接赋值给父类数组引用，这时父子类引用都指向同一个含有子类元素的数组，这时假设通过父类引用<code>father[0]</code>在数组里面添加一个父类元素，再通过子类引用<code>son[0]</code>去调用子类独有的方法，就会报<strong>ArrayStoreException</strong>，因为实际存的是父类元素，并没有子类独有的方法。</li><li>上面是书上看到的，测试的时候发现父类元素放不进去（jdk1.8），直接报异常，不知道是不是JDK后面版本优化了：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Son[] sonArray = <span class="keyword">new</span> Son[<span class="number">3</span>];</span><br><span class="line">sonArray[<span class="number">1</span>] = <span class="keyword">new</span> Son();</span><br><span class="line">sonArray[<span class="number">2</span>] = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">Father[] fatherArray= sonArray;</span><br><span class="line">fatherArray[<span class="number">0</span>] = <span class="keyword">new</span> Father();<span class="comment">// java.lang.ArrayStoreException</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>强转：</p><ul><li>使用强转前最好使用instanceof进行判断，因为有可能会报ClassCastException；<ul><li>null instanceof object 会返回 false；</li></ul></li></ul></li><li><p>final： </p><ul><li>final 修饰的类不能被继承，<strong>类中方法也默认变为 final</strong>；</li><li>final 修饰的方法可以被继承但不能被重写；</li><li>final 修饰的属性构造后不能再赋值（引用不能修改，引用的内容可以）；</li></ul></li><li><p>抽象类：</p><ul><li>关键字abstract声明的类称为抽象类，与普通类的最大区别是不能实例化；</li><li>不含抽象方法的类也可以声明为abstract类，含有抽象方法的类必须声明为abstract类；</li><li>可以声明抽象类创建非抽象子类；</li></ul></li><li><p>枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如没有枚举</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Week1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">     MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">     THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>枚举类<strong>本质</strong>是一个继承java.lang.Enum的final类，枚举值就是该类的实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ javap Week.class</span><br><span class="line">Compiled from <span class="string">&quot;TestEnum.java&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Week</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MONDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUESDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WEDNESDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THURSDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRIDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SATURDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUNDAY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Week[] values();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>接口：</p><ul><li><p>概念：接口不是类，而是对类的一组规则的描述，一个类要实现某接口就要遵从该接口定义的规则，即实现接口中的方法；</p><ul><li>接口中的方法默认都是public abstract，属性默认都是public static finall，不能含有普通成员变量；</li><li>传递性：父类实现了接口，子类也就实现了该接口（instance 返回 true），继承了父类重写接口的方法。</li></ul></li></ul></li><li><p>Java SE8 允许接口中增加静态方法，目的是减少<strong>伴随类</strong>，比如：我们有时候想要调用某一个类的某个非常简单地静态方法，若这个方法在这个类实现的接口中实现了，那么我们就可以通过接口来使用该方法，而不用再加载这个类。</p></li><li><p>可以将接口中方法声明为<strong>default</strong>并提供默认实现，这样做的意义就在于：假如某个接口中有多个方法，而我们常用的就只是一两个，实现该接口还要重写其他不用的方法，非常不方便，而且代码看起来也杂乱；使用default对方法修饰就可以提供默认实现（实现类中就不会提示重写），注意区别于静态方法，default 方法不能通过接口调用，需要实现类的对象来进行调用；</p></li><li><p>标记接口：只有一个空接口，唯一的目的就是标记身份，使用 instanceof 判断；</p></li><li><p><strong>默认方法冲突</strong>：</p><ul><li>超类优先，由此可以看出来，尽量不要让接口中的default方法重写Object中的toString、equals等方法，因为默认情况下使用的还是Object类的方法；<ul><li>接口IA和IB有相同方法声明（返回值、名称、参数列表）的方法，分下面情况：<ul><li>只要有一个接口中的该方法声明为default，就会冲突，需要在实现的时明确指定，例如<code>return IA.super.function()</code>；</li><li>两接口的该方法都没有声明default，就不会冲突，因为实现类要么实现要么不实现，随实现类而定；</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FA.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IA.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IB.print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonA</span> <span class="keyword">extends</span> <span class="title">FA</span> <span class="keyword">implements</span> <span class="title">IA</span>, <span class="title">IB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SonA s1 = <span class="keyword">new</span> SonA();</span><br><span class="line">        s1.print();<span class="comment">// 不重写的话默认调用父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.print();   <span class="comment">//指定调用父类，等价于不重写</span></span><br><span class="line">      <span class="comment">//IA.super.print();  //指定调用IA</span></span><br><span class="line">      <span class="comment">//IB.super.print();  //指定调用IB    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>内部类：</strong></p><ul><li><p>当两个对象有<strong>紧密的组合关系</strong>时，使用内部类。例如 Person 类包含 Heart 类，如果Heart类来自外部则无法说明其关系的紧密，也无法使用内部类的一些特性；</p></li><li><p><strong>本质</strong>也是一个类的成员属性，可以用修饰符修饰；</p></li><li><p>内部类编译后生成独立的<code>外部类$内部类.class</code>，没有<strong>主动引用</strong>的话，外部类加载不会引发内部类加载；</p><ul><li>所以可以用来实现懒加载单例。</li></ul></li><li><p>内部类可以访问其外部类的<strong>所有</strong>数据；外部类要访问内部类的成员时，必须要建立内部类的对象；</p><ul><li>（非静态）内部类对象不能独立于外部类对象而存在；</li><li>内部类中隐藏了指向外部类的引用<code>OuterClass.this</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内部类的方式</span></span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//或者：（即必须借助外部类）</span></span></span><br><span class="line"><span class="function">Outer outer </span>= <span class="keyword">new</span> Outer();</span><br><span class="line">Inner inner = outer.n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> alive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (alive)</span><br><span class="line">                System.out.println(<span class="string">&quot;-^-^-^&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 可以直接访问外部类私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlive</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内部类中外部类引用不再是this，而是 外围类.this；</span></span><br><span class="line">            Person.<span class="keyword">this</span>.alive = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person.Heart heart = <span class="keyword">new</span> Person().n<span class="function">ew <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line">        heart.jump();           <span class="comment">// -^-^-^</span></span><br><span class="line">        heart.setAlive(<span class="keyword">false</span>);</span><br><span class="line">        heart.jump();           <span class="comment">// -------</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>非静态内部类中所有的静态属性都必须是 final</strong>；</p><ul><li>这里的final静态属性指编译期常量，即基本型和用引号创建的String；非静态内部类中不能有非编译期常量，即<code>static final String str = new String(&quot;xxx&quot;);</code>这样的写法；</li><li>非静态内部类中暗含了一个指向外部类的引用（通过内部类的构造方法传递），也是通过这个引用来引用外部类的属性，所以非静态内部类依赖于外部类，即<strong>加载内部类之前必须先加载外部类</strong>，体现在代码上就是要用具体的外部类对象去创建内部类对象；</li><li>现在假设非静态内部类中存在static属性，则理应可以通过类名<code>Outer.Inner.属性名</code>直接访问，但如果Inner没有被初始化过，这就会出错。Inner的初始化依赖于Outer，Inner虽然是一个类，但本质是Outer的一个属性；声明为final的常量在编译期间就可以确认，通过<code>Outer.Inner.属性名</code>调用会经过<strong>常量传递优化</strong>，直接将此常量传递到调用者的常量池中，不会引发内部类的加载，所以非静态内部类中只能有编译期常量；</li></ul></li><li><p><strong>非静态内部类不能有 static 方法</strong>；</p><ul><li>道理同上。</li></ul></li><li><p><strong>静态内部类</strong></p><ul><li>在<strong>内部类不需要访问外围类对象的时候 ，使用静态内部类</strong>。此时静态内部类就和外部类的其他静态属性一样，外部类加载的时候加载，可以独立于外部类存在；</li><li>静态内部类只能访问外部类的静态属性，原因和静态方法不能访问非静态属性一样，是由于生命周期造成的；</li><li>静态内部类不存在上述 static 必须修饰为 final 的问题； </li><li>打个比方：内部类描述了两个类之间的组合关系，如Person类、Heart类、Hair类；而关系紧密的使用普通内部类，如Heart类不能独立于Person；关系不密切的使用静态内部类，如Hair类可以独立于外部类。</li></ul></li><li><p><strong>局部内部类</strong></p><ul><li>不能使用修饰符，作用域只在声明他的方法体中；</li><li>对外部完全隐藏，只有声明他的方法知道他的存在；</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li><p>本质：是一个<strong>匿名的带有具体实现的子类</strong>；</p></li><li><p>不使用匿名内部类，我们需要：定义子类，重写方法，new 子类对象，调用方法；</p></li><li><p>使用内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People p = <span class="keyword">new</span> People()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;p talk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.talk();</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h3><ul><li>声明 –&gt; 捕获 –&gt; 抛出<ul><li><strong>声明throw：</strong>声明代码可能引发的异常；</li><li><strong>捕获catch：</strong>当异常发生时，应当获取异常信息并作相应处理，通常是给用户以反馈；</li><li><strong>抛出throws：</strong>将控制权从错误产生的地方转移给能够处理这种情况的错误处理器；</li></ul></li><li>继承结构：</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/YEi7albKgRKK.png" alt="mark"></p><ul><li><p>Error：通常是系统内部的错误，如资源耗尽等，遇到此类错误，除了通知用户、保存当前数据外一般只能停机，我们对此没有控制能力；</p></li><li><p>Exception：</p><ul><li>IOException：一般程序本身没有问题，但由于外部资源的异常而引发；</li><li>RuntimeException：程序本身错误导致的异常；<ul><li>注意：Runtime 具有混淆性，其实异常都是运行时期产生的；</li></ul></li></ul></li><li><p><strong>Checked 与 Unchecked 异常：</strong></p><ul><li>Error 和 RuntimeException 称为非受查（Unchecked）异常，其他异常（IO、直接继承Exception的自定义异常等）称为受查（checked）异常；</li><li><strong>任何代码都具有抛出unchecked异常的潜力</strong>，即我们 <strong>不用throws和catch</strong> unchecked异常，例如 ArrayIndexOutOfBoundsException，我们应集中注意去避免这些异常，而不是声明它发生的可能性；如果发生了，虚拟机会帮catch（打印信息，停机）；</li><li>我们何时应该 **throws或catch **checked异常：<ul><li>当调用了抛出checked异常的方法时；</li><li>当方法内 throw new checked异常时；</li></ul></li><li>子类方法重写抛出的受查异常范围不能比父类方法大，若父类方法没有抛出异常，则子类重写时也不能抛出，只能自己catch；</li></ul></li><li><p>自定义异常：</p><ul><li>继承 Exception 或其子类；</li><li>两个构造器：默认 + 传递字符串，Throwable的toString将会打印这个字符串；</li></ul></li><li><p>捕获异常：</p><ul><li>try-catch-finally<ul><li>try中代码抛出了一个catch中声明的异常类，那么try块剩余代码不执行，转去执行catch块代码；</li><li>如果try块中抛出了一个catch中未声明的异常，那么该方法将立即退出；</li><li>finally最后都会执行；</li></ul></li><li>catch还是throws：<ul><li>知道怎么样处理就catch，否则就throws；</li><li>子类重写父类方法，父类方法又没有抛出异常，则子类只能自己catch；</li></ul></li><li>catch 中还可以再 throw new异常，目的是为了转换异常类型；</li><li>注意：有 <strong>return</strong> 时，return在try块中，会在return执行之前执行finally，若finally块也有return则会覆盖try块中的return；</li></ul></li><li><p>​    Closeable 接口：</p><ul><li>我们通常使用finally释放资源，但当try块与finally块同时发生异常抛出时，finally抛出的异常会覆盖掉try块抛出的异常，而我们通常需要的恰好就是try抛出的异常信息，JavaSE7 中实现了这个释放资源的快捷方式 try-with-resources；</li><li>凡是实现了Closeable接口的资源都可以通过声明在try(…)中来自动释放；</li></ul></li></ul><hr><h3 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h3><ul><li><p>为什么要使用泛型：</p><ul><li>使用泛型可以使我们编写的代码被不同类型的对象所重用；</li><li>一些情形下我们不需要再使用Object、强转等操作；</li><li>使得程序具有更好的可读性和安全性（编译器会进行类型检查）；</li></ul></li><li><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>, <span class="title">F</span>, <span class="title">G</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> F second;</span><br><span class="line">    <span class="keyword">private</span> G third;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(T first, F second, G third)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">        <span class="keyword">this</span>.third = third;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericClass&lt;Integer, String, Boolean&gt;(<span class="number">1</span>, <span class="string">&quot;泛型类&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>泛型方法：</p><ul><li>泛型方法不必一定定义在泛型类中；</li><li>使用 <code>extends</code> <strong>限定</strong><code>T</code>的范围，使用<code>&amp;</code>分割多个，称为<strong>限定类型</strong>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable &amp; Serializable&gt; <span class="function">T <span class="title">max</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    T max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (T t : a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.compareTo(max) &gt; <span class="number">0</span>) max = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">GenericClass.&lt;Integer&gt;max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//一般不用写&lt;&gt;，编译器会根据我们写的参数自动确定类型</span></span><br><span class="line">GenericClass.max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>类型擦除</strong>：</p><ul><li>Java 实现的泛型是一种“伪泛型”，使用类型擦除机制；C++ 为每一个模板类型产生真实的类型，称为“模板代码膨胀”；</li><li>泛型类型对应着一个<strong>原始类型</strong>，类名就是擦除类型参数后的泛型类名；变量类型就是擦除类型变量，并替换为第一个限定类型（没限定类型就是Object）；如GenericClass&lt;T&gt;擦除后成为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    <span class="keyword">private</span> Object third;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(Object first, Object second, Object third)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">        <span class="keyword">this</span>.third = third;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型擦除对<strong>参数或返回值是类型参数类型的方法</strong>造成的影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair类 封装某类型为一对</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DateInterval类 表示一时间段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 重写父类方法，保证时间段为正值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(<span class="keyword">this</span>.getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;DateInterval&gt; clazz = DateInterval.class;</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印一下DateInterval的运行时方法发现结果包含下面两条setSecond方法：</span></span><br><span class="line"><span class="comment">// 1. public void DateInterval.setSecond(java.time.LocalDate)</span></span><br><span class="line"><span class="comment">// 2. public void DateInterval.setSecond(java.lang.Object)</span></span><br><span class="line"><span class="comment">//----上面是重写的，下面是继承的-----</span></span><br><span class="line"><span class="comment">// 对比get方法与setFirst方法：</span></span><br><span class="line"><span class="comment">// 3. public java.lang.Object Pair.getFirst()</span></span><br><span class="line"><span class="comment">// 4. public java.lang.Object Pair.getSecond()</span></span><br><span class="line"><span class="comment">// 5. public void Pair.setFirst(java.lang.Object)</span></span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure></li><li><p><strong>分析：</strong></p><ul><li><p>很明显，由于类型擦除，继承<code>Pair&lt;LocalDate&gt;</code>，实际继承的是<code>Pair</code>，类型参数都替换为了<code>Object</code>，那为什么我们还可以重写<code>setSecond(LocalDate second)</code>方法而不报错呢？这就是<strong>类型擦除与多态发生的冲突</strong>；</p></li><li><p>当我们<strong>试图重写</strong>诸如此类方法，编译器为我们在DateInterval中生成<strong>桥方法（bridge method）</strong>来解决这个问题：</p><ul><li>为什么说是试图重写，因为这本来是不符合语法的，从父类继承下来的方法中并没有参数为 LocalDate 的 setSecond 方法；但是我们确实有这样的开发需求，所以让编译器为我们解决；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述 2. public void DateInterval.setSecond(java.lang.Object)就是桥方法，方法体为：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setSecond((LocalDate)second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即就是调用我们重写的setSecond(LocalDate second)方法</span></span><br></pre></td></tr></table></figure><ul><li>总结一下：编译器会根据我们是否重写了此类方法，而帮我们生成桥方法，生成桥方法也是重写父类方法的过程，即根据我们试图重写的方法，帮我们重写了参数为Object的方法；</li></ul></li><li><p>重写中的返回值协变规则也是运用桥方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写DateInterval 的 clone方法</span></span><br><span class="line"><span class="comment">// 实际类中存在两个clone方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DateInterval <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.CloneNotSupportedException</span>;</span><br><span class="line"><span class="keyword">protected</span> java.lang.<span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.CloneNotSupportedException</span></span><br></pre></td></tr></table></figure></li><li><p>那对于get方法这样返回类型是类型参数类型的呢？</p><ul><li><p>像这样的方法，我们一般不会重写，因为调用这样的get方法，编译器会帮我们自动强转；</p></li><li><p>而非要重写的话，结论还是同上，可以重写生成桥方法，但是会生成两个返回值类型不同，方法签名相同的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Object DateInterval.getSecond()</span><br><span class="line">  <span class="keyword">public</span> java.time.LocalDate DateInterval.getSecond()</span><br></pre></td></tr></table></figure></li><li><p>虽然编译器禁止我们写出这样的重载代码，但是它自己就这样写了，这是个特例；</p></li></ul></li></ul></li></ul><ul><li><p>其他要<strong>注意：</strong>（大都是因为类型擦除所引起）</p><ul><li><p>instanceof 与强转只能跟<strong>原始类型</strong>做判断；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种表达都是错误的</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;);</span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a;</span><br></pre></td></tr></table></figure></li><li><p>不要创建数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] pairs = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 分析：擦除后pairs变成了Pair[] 类型；</span></span><br></pre></td></tr></table></figure></li><li><p>不要使用带有类型变量的静态属性与方法；</p><ul><li>泛型类的静态上下文中类型变量无效</li></ul></li><li><p>注意擦除后的冲突；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T)</span> </span>;</span><br><span class="line"><span class="comment">// 擦除后，发生冲突</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Pair&lt;Father&gt; 与 Pair&lt;Son&gt;没有继承关系；</p><ul><li>即不能企图声明父类指向子类；</li></ul></li></ul></li></ul><ul><li><p>**通配符<code>?</code>**：</p><ul><li>子类限定<code>&lt;? extends Father&gt;</code>，只读；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function">extends Father <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setValue</span><span class="params">(? extends Father)</span><span class="comment">// 编译错误</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>超类限定<code>&lt;? super Father&gt;</code>，只写；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function"><span class="keyword">super</span> Father <span class="title">getValue</span><span class="params">()</span><span class="comment">// 编译错误</span></span></span><br><span class="line"><span class="function"><span class="title">setValue</span><span class="params">(? <span class="keyword">super</span> Father)</span></span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="5-集合"><a href="#5-集合" class="headerlink" title="5. 集合"></a>5. 集合</h3><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/76iRq4NO3oKA.png" alt="mark" style="zoom: 67%;" /><br><ul><li><p>List 插入有序，可重复</p><ul><li><p>ArrayList 查询快、增删慢，线程不安全</p></li><li><p>Vector 查询快、增删慢，线程安全</p></li><li><p>LinkedList 查询慢、增删快，线程不安全</p></li></ul></li></ul><ul><li><p>Set 唯一，依赖于<code>hashCode()</code>和<code>equals()</code>方法</p><ul><li><p>HashSet 底层=hash表，无序，可以有null值</p></li><li><p>LinkedHashSet 底层=链表+hash表，插入有序，可以有null值</p></li><li><p>TreeSet 底层=红黑树，有序，不能有null值</p></li></ul></li></ul><ul><li><p>Map 键值对，键唯一</p><ul><li>HashMap 无序，线程不安全，可以有null值</li><li>HashTable（父类是Dictionary） 无序，线程安全，不能有null值</li><li>LinkedHashMap 无序 </li><li>TreeMap 有序</li></ul></li></ul><hr><h3 id="6-注解-Annotation"><a href="#6-注解-Annotation" class="headerlink" title="6. 注解 Annotation"></a>6. 注解 Annotation</h3><ul><li><p>本质是一个接口，继承<code>java.lang.annotation.Annotation</code>接口；</p><ul><li>注解的属性就是接口中的抽象方法；</li><li>可以使用<code>default</code>给属性赋默认值；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Override 注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @SuppressWarnings 注解</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    属性列表 <span class="keyword">default</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>元注解：</strong>描述注解的注解：</p><ul><li><strong>@Target</strong> 声明注解的位置，属性 ElementType<ul><li>TYPE：类与接口上；</li><li>FIELD：成员变量上；</li><li>METHOD：方法体上；</li><li>PARAMETER：方法参数上；</li><li>……</li></ul></li><li><strong>@Retention</strong> 声明注解将被保留的阶段，属性 RetentionPolicy<ul><li>SOURCE：只保留在源文件，编译成class文件时就不再存在；<ul><li>检查性作用，@Override、@SuppressWarning</li></ul></li><li>CLASS（默认）：保留到class文件，加载class时遗弃；<ul><li>编译期生成辅助性代码，@Lombok</li></ul></li><li>RUNTIME：保存到class文件中，随class文件一起被加载进 JVM；<ul><li>运行时获取（通过反射）</li></ul></li></ul></li><li><strong>@Inherited</strong> 声明注解是否被子类继承；</li></ul></li></ul><ul><li><p><strong>反射获取运行时注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> ClassInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldInfo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MethodInfo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClassInfo(&quot;MyAnnotationTest&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FieldInfo</span></span><br><span class="line">    <span class="keyword">int</span> anno;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FieldInfo(888)</span></span><br><span class="line">    <span class="keyword">int</span> tation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MethodInfo(name = &quot;myPrint&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyAnnotation.class;</span><br><span class="line"></span><br><span class="line">        ClassInfo classInfo = clazz.getAnnotation(ClassInfo.class);</span><br><span class="line">        System.out.println(classInfo.value());</span><br><span class="line"></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        FieldInfo fieldInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            fieldInfo = field.getAnnotation(FieldInfo.class);</span><br><span class="line">            System.out.println(fieldInfo.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">        MethodInfo methodInfo = method.getAnnotation(MethodInfo.class);</span><br><span class="line">        System.out.println(methodInfo.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-反射-Reflection"><a href="#7-反射-Reflection" class="headerlink" title="7.  反射 Reflection"></a>7.  反射 Reflection</h3><ul><li><p>Java 是静态语言，但具有一定的动态性。反射就是一个体现，它可以让我们在运行时分析一个类。JVM加载一个类后会为该类生成一个Class&lt;T&gt;类的对象，这个Class对象就封装了类的各个部分信息，我们可以通过Class对象来在运行时对类进行分析，执行其相应方法。</p></li><li><p>获取Class对象的三种方式：</p><ul><li><code>对象名.getClass()</code>，一般不用；</li><li><code>类名.class</code>必须导包，依赖太强，不用；<ul><li>不会初始化 Class对象；</li></ul></li><li><code>Class.forName(全类名)</code>最常用；<ul><li>会初始化 Class对象；</li></ul></li></ul></li><li><p><strong>使用反射</strong></p><ul><li>先定义一个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReflection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> publicField;</span><br><span class="line">    <span class="keyword">private</span> String privateField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyReflection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公有无参构造函数执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyReflection</span><span class="params">(<span class="keyword">int</span> publicField, String privateField)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publicField = publicField;</span><br><span class="line">        <span class="keyword">this</span>.privateField = privateField;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有带参构造函数执行了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get、set方法...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public方法被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private方法被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>获取并执行构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Class对象</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有公有构造方法</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有构造方法，包括私有等</span></span><br><span class="line">    constructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定构造方法，参数为要获取的构造方法的参数的class对象；</span></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class);</span><br><span class="line">    <span class="comment">// 暴力反射，忽略访问修饰符</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 执行构造方法</span></span><br><span class="line">    MyReflection o = (MyReflection) constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印验证</span></span><br><span class="line">    System.out.println(o.getPrivateField() + o.getPublicField());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------执行结果--------</span></span><br><span class="line"><span class="keyword">public</span> com.reflection.MyReflection()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> com.reflection.MyReflection()</span><br><span class="line"><span class="keyword">private</span> com.reflection.MyReflection(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line"></span><br><span class="line">私有带参构造函数执行了</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>获取成员变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有公有属性-----&quot;</span>);</span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有属性-----&quot;</span>);</span><br><span class="line">    fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取指定属性，并调用-----&quot;</span>);</span><br><span class="line">    Field privateField = clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">    privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    MyReflection o = (MyReflection) clazz.getConstructor(<span class="keyword">null</span>).newInstance();</span><br><span class="line">    privateField.set(o,<span class="string">&quot;反射修改了私有属性&quot;</span>);</span><br><span class="line">    System.out.println(o.getPrivateField());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------结果------------</span></span><br><span class="line">-----获取所有公有属性-----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> com.reflection.MyReflection.publicField</span><br><span class="line">-----获取所有属性-----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> com.reflection.MyReflection.publicField</span><br><span class="line"><span class="keyword">private</span> java.lang.String com.reflection.MyReflection.privateField</span><br><span class="line">-----获取指定属性，并调用-----</span><br><span class="line">公有无参构造函数执行了</span><br><span class="line">反射修改了私有属性</span><br></pre></td></tr></table></figure></li><li><p><strong>获取方法并调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(<span class="string">&quot;com.reflection.MyReflection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有公有方法-----&quot;</span>);</span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取所有方法-----&quot;</span>);</span><br><span class="line">    methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----获取指定方法，并调用-----&quot;</span>);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">&quot;showStatic&quot;</span>,String.class);</span><br><span class="line">    <span class="comment">// 参数：执行对象 与 传参</span></span><br><span class="line">    <span class="comment">// 因为是静态方法，所以传递 null</span></span><br><span class="line">    method.invoke(<span class="keyword">null</span>, <span class="string">&quot;静态方法执行了&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    method = clazz.getDeclaredMethod(<span class="string">&quot;showPrivate&quot;</span>);</span><br><span class="line">    MyReflection o = (MyReflection) clazz.getConstructor(<span class="keyword">null</span>).newInstance();</span><br><span class="line">    method.invoke(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----结果-----</span></span><br><span class="line">-----获取所有公有方法-----</span><br><span class="line">    略</span><br><span class="line">-----获取所有方法-----</span><br><span class="line">    略</span><br><span class="line">-----获取指定方法，并调用-----</span><br><span class="line">静态方法执行了</span><br><span class="line">公有无参构造函数执行了</span><br><span class="line"><span class="keyword">private</span>方法被调用了</span><br></pre></td></tr></table></figure></li></ul><ul><li>应用场景：获取运行时注解，读取配置文件反射创建对象……</li></ul><hr><h3 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8. 多线程"></a>8. 多线程</h3><blockquote><p>　　一个程序同时执行多个任务，通常每一个任务称为一个线程（ thread），可以同时运行一个以上线程的程序称为多线程程序（ multi-threaded ) 。</p></blockquote><ul><li><p><strong>进程（process） VS 线程（thread）</strong></p><ul><li>进程是操作系统资源分配的基本单位，是程序的一次执行过程。进程间隔离性强，较安全但是进程间通信效率低；</li><li>线程是CPU进行调度的基本单位，是进程内的一个执行单元。进程间可以共享内存，便于通信但是伴随着风险，同时线程调度也要耗费一定资源；</li></ul><p>　　运行一个Java程序，开启一个JVM就是一个进程；一个Java程序最少有两个线程，即main线程和GC线程；</p></li><li><p><strong>Java中创建多线程</strong></p><ol><li>继承Thread类或实现Runnable接口（是一个函数式接口）；</li><li>重写run方法，run方法就是线程要做的工作；</li></ol></li></ul><ol start="3"><li>创建Thread类对象调用start方法启动线程；</li></ol><ul><li><p><strong>线程安全问题</strong></p><p>当多个线程同时对公有变量进行读写、写写操作时就可能出现线程安全问题；</p><ul><li>同步代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个锁对象</span></span><br><span class="line">Object lock = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="comment">// 获取锁对象，没有获取到则进入阻塞</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同步方法</p><ul><li>对于普通方法，锁是this；对于static方法，锁是该类的class对象；</li></ul></li><li><p>可重入锁 reentrantlock</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lock.lock(); </span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock(); </span><br></pre></td></tr></table></figure></li><li><p><strong>线程的状态</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/g2Qt5IlyFOWy.png" alt="mark"></p></li></ul><ol><li><p>New 新创建：即 new Thread(r) 后还没有调用start方法时，线程还没有开始运行；</p></li><li><p>Runnable 可运行：线程处在随时可以运行的状态，但可能在运行也可能没有运行，取决于是否得到了时间片；</p></li><li><p>Blocked 被阻塞 ；</p></li><li><p>Waiting 等待；</p></li><li><p>Timed Waiting 计时等待；</p><blockquote><p>　　当线程处于被阻塞或等待状态时，它暂时不活动 ，它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。 </p><p>　　当一个线程试图获得另一个线程持有的锁时，进入阻塞；</p><p>　　当线程等待另一个线程通知调度器一个<strong>条件</strong>时（线程通信），进入等待；</p><p>　　当调用了<code>Thread.sleep</code>、<code>Object.wait</code>、<code>Thread.join</code>、<code>Lock.tryLock</code>以及<code>Condition.await</code>的方法时进入计时等待；</p></blockquote></li><li><p>Terminated 被终止：run方法正常结束，或因为一个没有捕获的异常导致run方法终止，则线程死亡。</p></li></ol><ul><li><strong>线程的属性</strong></li></ul><ol><li><p>优先级：Java中使用<code>setPriority</code>方法设置线程优先级在[1,10]之间越来越高，默认为5；</p><ul><li><p>线程优先级高度依赖于宿主机系统的实现，即Java将优先级映射到宿主机的线程实现机制上，例如 Windows 有7个优先级，Oracle为Linux提供的 JVM 中没有线程优先级；</p></li><li><p>若高优先级的线程没有进入非活动状态，那么低优先级的线程可能会饿死；</p></li><li><p><code>static void yield()</code>，线程礼让；</p></li></ul></li><li><p>守护线程：在线程启动之前调用<code>thread.setDaemon(true)</code>声明该线程为守护线程，守护线程唯一的作用是为其他线程提供服务，例如计时线程；</p></li></ol><ul><li><p><strong>线程通信</strong></p><p>线程之间不仅仅只有竞争关系，还有协作关系；当一个线程进人临界区，却发现在某一条件满足（或者说其他线程执行完某一操作）之后它才能执行，这时要使用一个<strong>条件对象</strong>来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p><ul><li>一个锁对象可以有一个或多个相关的条件对象，使用<code>new Condition</code>获取一个条件对象，习惯命名为能反映该条件的名称；当一个线程获得了锁但是发现执行的条件不足时，会<strong>使用条件对象调用</strong><code>await</code>方法，主动放弃该锁，进入Waiting状态，注意区别于线程调用await方法。这时只能等待另一线程调用同一条件上的<code>signalAll</code>方法才会被唤醒，被唤醒后还要重新加入对锁的竞争行列；</li><li>await 和 signalAll 对应着 wait 和 notifyAll 方法；</li></ul></li><li><p><strong>线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(线程数);</span><br><span class="line"><span class="comment">// 获取线程对象并执行</span></span><br><span class="line">service.submit(runnable);</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-IO流"><a href="#9-IO流" class="headerlink" title="9. IO流"></a>9. IO流</h3><p>（插眼）</p><hr><h3 id="10-网络编程"><a href="#10-网络编程" class="headerlink" title="10. 网络编程"></a>10. 网络编程</h3><p>（插眼）</p><hr><h3 id="11-lambda-amp-函数式接口-amp-Stream流"><a href="#11-lambda-amp-函数式接口-amp-Stream流" class="headerlink" title="11. lambda &amp; 函数式接口 &amp; Stream流"></a>11. lambda &amp; 函数式接口 &amp; Stream流</h3><ul><li>lambda 表达式是一个可以<strong>推导、传递</strong>的<strong>代码块</strong>，主要解决了 Java 过分面向对象的缺点，因为我们有时候<strong>只关注做什么产生什么结果</strong>，而不关注是<strong>”谁“</strong>用什么方法产生的这个结果，这个”谁“就是lambda帮我们省略的对象；</li><li><strong>格式：</strong><ul><li><code>()</code> 表示参数列表，无参为空，参数类型一定时可以省略类型；</li><li><code>-&gt;</code> 表示推导传递之意；</li><li><code>&#123; &#125;</code> 表示方法体，只有一条语句时可以省略花括号、分号和return；</li></ul></li><li><strong>lambda的推导作用：</strong><ul><li>回想匿名内部类解决了什么样的问题，原本我们需要写一个类、继承接口、实现方法、在需要的地方new对象调用方法，匿名内部类让我们可以直接声明接口创建匿名实现类，并直接重写其方法，从而简化了步骤；而lambda表达式在这一基础上再次简化，更加方便我们使用，但是使用 lambda推导是有条件的，那就是进行推导的接口必须是一个函数式接口；<ul><li>函数式接口：有且只有一个抽象方法的接口，重载也不行；默认方法、静态方法、重新声明的Object方法都不考虑；</li><li><code>@FunctionalInterface</code>注解可以检查该接口是否满足函数式接口条件；</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法参数有一个函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">talkSth</span><span class="params">(String s, People p)</span> </span>&#123;</span><br><span class="line">        p.talk(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类方式</span></span><br><span class="line">    MyLambda.talkSth(<span class="string">&quot;使用匿名内部类&quot;</span>, <span class="keyword">new</span> People() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// lambda方式</span></span><br><span class="line">    MyLambda.talkSth(<span class="string">&quot;使用lambda表达式&quot;</span>, (s) -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>lambda传递作用——方法引用</strong></p><ul><li>上面 lambda方式的代码还是显得有点冗余，可以传递方法引用简化之：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLambda.talkSth(<span class="string">&quot;使用lambda表达式&quot;</span>, System.out::println);</span><br></pre></td></tr></table></figure><ul><li>说明：<code>::</code> 是方法引用符；lambda推导时我们使用自己重写的方法，而传递方法引用可以让我们使用已有的方法；</li></ul></li></ul><ul><li><p><strong>常用函数式接口</strong></p><ul><li><code>java.util.function</code>包下</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/a5aHeF0nttmC.png" alt="mark"></p></li></ul><ul><li><p><strong>Stream 流思想</strong></p><ul><li><p>获取流：</p><ul><li>Collection 集合通过默认方法 stream() 获取；</li><li>数组通过Stream&lt;T&gt; 接口的of方法获取；</li><li>Map 要将keyValue封装成entry再调用stream()方法获取；</li></ul></li><li><p>常用流处理方法：</p><ul><li>返回值不为 Stream 即会终结流；</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void forEach(Consumer&lt;? super T&gt; action)</code></td><td>将流中每一个元素交给Consumer处理</td></tr><tr><td><code>long count()</code></td><td>返回流中元素个数</td></tr><tr><td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td>接受Predicate作为筛选条件，返回true则保留元素，否则剔除元素</td></tr><tr><td><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td><td>将T类型转换为R类型</td></tr><tr><td><code>Stream&lt;T&gt; limit(long maxSize)</code></td><td>保留前几个元素</td></tr><tr><td><code>Stream&lt;T&gt; skip(long n)</code></td><td>删除前几个元素</td></tr><tr><td><code>Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td><td>合并流</td></tr></tbody></table></li></ul></li></ul><hr><h3 id="12-常用类与接口"><a href="#12-常用类与接口" class="headerlink" title="12. 常用类与接口"></a>12. 常用类与接口</h3><p>　　Java 包结构：</p><p><img src= "https://cdn.jsdelivr.net/gh/HenryKang99/HenryKang99.github.io/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/HenryKang99/blog_img/img/4N3oz33zbRAK.png" alt="mark"></p><p>　</p><ul><li><p><strong>Scanner</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure></li><li><p><strong>Random</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// 返回 [0，10）之间的随机数</span></span><br><span class="line"><span class="keyword">int</span> i = r.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Math</strong></p><ul><li>StrictMath　更加精确，但是效率没有Math高；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.abs();  <span class="comment">// 取绝对值</span></span><br><span class="line">Math.ceil();  <span class="comment">// 向上取整</span></span><br><span class="line">Math.floor(); <span class="comment">// 向下取整</span></span><br><span class="line">Math.round(); <span class="comment">// 四舍五入</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Arrays</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString(arr);</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.copyOf(arr,<span class="keyword">int</span> newLength);</span><br><span class="line"><span class="comment">// copyOf底层调用的是System的 arraycopy方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>Date</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date构造</span></span><br><span class="line">Date();</span><br><span class="line">Date(<span class="keyword">long</span> 毫秒值);</span><br><span class="line"><span class="comment">// DateFormat的实现类SimpleDateFormat，进行格式化</span></span><br><span class="line">SimpleDateFormat(String pattern); <span class="comment">//yyyy-MM-dd HH-mm-ss</span></span><br><span class="line">sdf.format(date);<span class="comment">//日期-&gt;字符串</span></span><br><span class="line">sdf.parse(str);<span class="comment">//字符串-&gt;日期</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Calendar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span>;<span class="comment">// 获取</span></span><br><span class="line"><span class="function">Date <span class="title">getTime</span><span class="params">()</span></span>;<span class="comment">// 转化为Date</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>; <span class="comment">// 根据域获取值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span></span>;<span class="comment">// 根据域设置值</span></span><br><span class="line"><span class="comment">/* filed 取值：</span></span><br><span class="line"><span class="comment">YEAR,MONTH,DAY_OF_MONTH;</span></span><br><span class="line"><span class="comment">HOUR,HOUR_OF_DAY;</span></span><br><span class="line"><span class="comment">MINUTE,SECOND;</span></span><br><span class="line"><span class="comment">DAY_OF_WEEK;(周日为1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>**StringBuilder **</p><p>Stringbuffer 线程安全；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder(<span class="keyword">int</span> capacity);<span class="comment">// 默认16</span></span><br><span class="line">StringBuilder(String str);</span><br><span class="line">append();</span><br><span class="line">toString();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="Others/hello-world.html"/>
      <url>Others/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
